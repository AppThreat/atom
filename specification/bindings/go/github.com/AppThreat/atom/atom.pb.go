// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v6.33.1
// source: atom.proto

//*
// Atom is a novel intermediate representation for applications. The representation is optimized for operations such as slicing useful for application analytics.
//
// ![Atom logo](./docs/Atom-logo.png)
// Atom v1.0.0 specification is currently compatible with Joern CPG v1.1 specification with 1 modification
// - imports edges are not hidden in atom
// [https://cpg.joern.io](https://cpg.joern.io)

package atom

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Enum for the name of a node property
type NodePropertyName int32

const (
	NodePropertyName_UNKNOWN_NODE_PROPERTY NodePropertyName = 0
	// This optional field provides the line number of the program construct represented by the node.
	NodePropertyName_LINE_NUMBER NodePropertyName = 2
	// AST node type name emitted by parser.
	NodePropertyName_PARSER_TYPE_NAME NodePropertyName = 3
	// This integer indicates the position of the node among its siblings in the AST. The left-most child has an order of 0.
	NodePropertyName_ORDER NodePropertyName = 4
	// Name of represented object, e.g., method name (e.g. "run")
	NodePropertyName_NAME NodePropertyName = 5
	// This is the fully-qualified name of an entity, e.g., the fully-qualified name of a method or type. The details of what constitutes a fully-qualified name are language specific. This field SHOULD be human readable.
	NodePropertyName_FULL_NAME NodePropertyName = 6
	// Indicates that the construct (METHOD or TYPE_DECL) is external, that is, it is referenced but not defined in the code (applies both to insular parsing and to library functions where we have header files only)
	NodePropertyName_IS_EXTERNAL NodePropertyName = 7
	// This property denotes a string value as used in a key-value pair.
	NodePropertyName_VALUE NodePropertyName = 8
	// This optional fields provides the column number of the program construct represented by the node.
	NodePropertyName_COLUMN_NUMBER NodePropertyName = 11
	// This optional fields provides the line number at which the program construct represented by the node ends.
	NodePropertyName_LINE_NUMBER_END NodePropertyName = 12
	// A version, given as a string. Used, for example, in the META_DATA node to indicate which version of the CPG spec this CPG conforms to.
	NodePropertyName_VERSION NodePropertyName = 13
	// For formal method input parameters, output parameters, and return parameters, this field holds the evaluation strategy, which is one of the following: 1) `BY_REFERENCE` indicates that the parameter is passed by reference, 2) `BY_VALUE` indicates that it is passed by value, that is, a copy is made, 3) `BY_SHARING` the parameter is a pointer/reference and it is shared with the caller/callee. While a copy of the pointer is made, a copy of the object that it points to is not made.
	NodePropertyName_EVALUATION_STRATEGY NodePropertyName = 15
	// This optional fields provides the column number at which the program construct represented by the node ends.
	NodePropertyName_COLUMN_NUMBER_END NodePropertyName = 16
	// This field indicates which CPG language frontend generated the CPG. Frontend developers may freely choose a value that describes their frontend so long as it is not used by an existing frontend. Reserved values are to date: C, LLVM, GHIDRA, PHP.
	NodePropertyName_LANGUAGE NodePropertyName = 19
	// Certain files, e.g., configuration files, may be included in the CPG as-is. For such files, the `CONTENT` field contains the files content.
	NodePropertyName_CONTENT NodePropertyName = 20
	// This field holds the code snippet that the node represents.
	NodePropertyName_CODE NodePropertyName = 21
	// The method signature encodes the types of parameters in a string. The string SHOULD be human readable and suitable for differentiating methods with different parameter types sufficiently to allow for resolving of function overloading. The present specification does not enforce a strict format for the signature, that is, it can be chosen by the frontend implementor to fit the source language.
	NodePropertyName_SIGNATURE NodePropertyName = 22
	// This field holds the dispatch type of a call, which is either `STATIC_DISPATCH` or `DYNAMIC_DISPATCH`. For statically dispatched method calls, the call target is known at compile time while for dynamically dispatched calls, it can only be determined at runtime as it may depend on the type of an object (as is the case for virtual method calls) or calculation of an offset.
	NodePropertyName_DISPATCH_TYPE NodePropertyName = 25
	// The modifier type is a free-form string. The following are known modifier types: `STATIC`, `PUBLIC`, `PROTECTED`, `PRIVATE`, `ABSTRACT`, `NATIVE`, `CONSTRUCTOR`, `VIRTUAL`.
	NodePropertyName_MODIFIER_TYPE NodePropertyName = 26
	// The `CONTROL_STRUCTURE_TYPE` field indicates which kind of control structure a `CONTROL_STRUCTURE` node represents. The available types are the following: BREAK, CONTINUE, DO, WHILE, FOR, GOTO, IF, ELSE, TRY, THROW and SWITCH.
	NodePropertyName_CONTROL_STRUCTURE_TYPE NodePropertyName = 27
	// AST-children of CALL nodes have an argument index, that is used to match call-site arguments with callee parameters. Explicit parameters are numbered from 1 to N, while index 0 is reserved for implicit self / this parameter. CALLs without implicit parameter therefore have arguments starting with index 1. AST-children of BLOCK nodes may have an argument index as well; in this case, the last argument index determines the return expression of a BLOCK expression. If the `PARAMETER_NAME` field is set, then the `ARGUMENT_INDEX` field is ignored. It is suggested to set it to -1.
	NodePropertyName_ARGUMENT_INDEX NodePropertyName = 40
	// Identifier which uniquely describes a CLOSURE_BINDING. This property is used to match captured LOCAL nodes with the corresponding CLOSURE_BINDING nodes.
	NodePropertyName_CLOSURE_BINDING_ID NodePropertyName = 50
	// This field contains the fully-qualified static type name of the program construct represented by a node. It is the name of an instantiated type, e.g., `java.util.List<Integer>`, rather than `java.util.List[T]`. If the type cannot be determined, this field should be set to the empty string.
	NodePropertyName_TYPE_FULL_NAME NodePropertyName = 51
	// The static type decl of a TYPE. This property is matched against the FULL_NAME of TYPE_DECL nodes. It is required to have exactly one TYPE_DECL for each different TYPE_DECL_FULL_NAME.
	NodePropertyName_TYPE_DECL_FULL_NAME NodePropertyName = 52
	// The static types a TYPE_DECL inherits from. This property is matched against the FULL_NAME of TYPE nodes and thus it is required to have at least one TYPE node for each TYPE_FULL_NAME.
	NodePropertyName_INHERITS_FROM_TYPE_FULL_NAME NodePropertyName = 53
	// The FULL_NAME of a method. Used to link CALL and METHOD nodes. It is required to have exactly one METHOD node for each METHOD_FULL_NAME.
	NodePropertyName_METHOD_FULL_NAME NodePropertyName = 54
	// The type of the AST parent. Since this is only used in some parts of the graph, the list does not include all possible parents by intention. Possible parents: METHOD, TYPE_DECL, NAMESPACE_BLOCK.
	NodePropertyName_AST_PARENT_TYPE NodePropertyName = 56
	// This field holds the FULL_NAME of the AST parent of an entity.
	NodePropertyName_AST_PARENT_FULL_NAME NodePropertyName = 57
	// The group ID for a dependency
	NodePropertyName_DEPENDENCY_GROUP_ID NodePropertyName = 58
	// Symbols
	NodePropertyName_SYMBOL NodePropertyName = 100
	// Method short name.
	NodePropertyName_METHOD_SHORT_NAME NodePropertyName = 102
	// Method package name.
	NodePropertyName_PACKAGE_NAME NodePropertyName = 103
	// Method class name.
	NodePropertyName_CLASS_NAME NodePropertyName = 104
	// Label for the node which could be code.
	NodePropertyName_NODE_LABEL NodePropertyName = 105
	// The path of the source file this node was generated from, relative to the root path in the meta data node. This field must be set but may be set to the value `<unknown>` to indicate that no source file can be associated with the node, e.g., because the node represents an entity known to exist because it is referenced, but for which the file that is is declared in is unknown.
	NodePropertyName_FILENAME NodePropertyName = 106
	// The field contains the names of the overlays applied to this CPG, in order of their application. Names are free-form strings, that is, this specification does not dictate them but rather requires tool producers and consumers to communicate them between each other.
	NodePropertyName_OVERLAYS NodePropertyName = 118
	// This property contains a hash value in the form of a string. Hashes can be used to summarize data, e.g., to summarize the contents of source files or sub graphs. Such summaries are useful to determine whether code has already been analyzed in incremental analysis pipelines. This property is optional to allow its calculation to be deferred or skipped if the hash is not needed.
	NodePropertyName_HASH NodePropertyName = 120
	// For calls involving named parameters, the `ARGUMENT_NAME` field holds the name of the parameter initialized by the expression. For all other calls, this field is unset.
	NodePropertyName_ARGUMENT_NAME NodePropertyName = 130
	// This property denotes a key of a key-value pair.
	NodePropertyName_KEY NodePropertyName = 131
	// Class short name
	NodePropertyName_CLASS_SHORT_NAME NodePropertyName = 132
	// This property holds the fully qualified name of the type that the node is a type alias of.
	NodePropertyName_ALIAS_TYPE_FULL_NAME NodePropertyName = 158
	// The original name of the (potentially mangled) captured variable
	NodePropertyName_CLOSURE_ORIGINAL_NAME NodePropertyName = 159
	// Specifies whether a parameter is the variadic argument handling parameter of a variadic method. Only one parameter of a method is allowed to have this property set to true.
	NodePropertyName_IS_VARIADIC NodePropertyName = 221
	// The path to the root directory of the source/binary this CPG is generated from.
	NodePropertyName_ROOT NodePropertyName = 1199
	// Type hint for the dynamic type.
	NodePropertyName_DYNAMIC_TYPE_HINT_FULL_NAME NodePropertyName = 1591
	// Specifies an index, e.g., for a parameter or argument. Explicit parameters are numbered from 1 to N, while index 0 is reserved for implicit self / this parameter.
	NodePropertyName_INDEX NodePropertyName = 2223
	// This field holds the canonical name of a `FIELD_IDENTIFIER`. It is typically identical to the CODE field, but canonicalized according to source language semantics. Human readable names are preferable. `FIELD_IDENTIFIER` nodes must share identical `CANONICAL_NAME` if and only if they alias, e.g., in C-style unions (if the aliasing relationship is unknown or there are partial overlaps, then one must make a reasonable guess, and trade off between false negatives and false positives).
	NodePropertyName_CANONICAL_NAME NodePropertyName = 2001092
	// References to other nodes. This is not a real property; it exists here for the sake of proto serialization only. valueType and cardinality are meaningless.
	NodePropertyName_CONTAINED_REF NodePropertyName = 2007161
)

// Enum value maps for NodePropertyName.
var (
	NodePropertyName_name = map[int32]string{
		0:       "UNKNOWN_NODE_PROPERTY",
		2:       "LINE_NUMBER",
		3:       "PARSER_TYPE_NAME",
		4:       "ORDER",
		5:       "NAME",
		6:       "FULL_NAME",
		7:       "IS_EXTERNAL",
		8:       "VALUE",
		11:      "COLUMN_NUMBER",
		12:      "LINE_NUMBER_END",
		13:      "VERSION",
		15:      "EVALUATION_STRATEGY",
		16:      "COLUMN_NUMBER_END",
		19:      "LANGUAGE",
		20:      "CONTENT",
		21:      "CODE",
		22:      "SIGNATURE",
		25:      "DISPATCH_TYPE",
		26:      "MODIFIER_TYPE",
		27:      "CONTROL_STRUCTURE_TYPE",
		40:      "ARGUMENT_INDEX",
		50:      "CLOSURE_BINDING_ID",
		51:      "TYPE_FULL_NAME",
		52:      "TYPE_DECL_FULL_NAME",
		53:      "INHERITS_FROM_TYPE_FULL_NAME",
		54:      "METHOD_FULL_NAME",
		56:      "AST_PARENT_TYPE",
		57:      "AST_PARENT_FULL_NAME",
		58:      "DEPENDENCY_GROUP_ID",
		100:     "SYMBOL",
		102:     "METHOD_SHORT_NAME",
		103:     "PACKAGE_NAME",
		104:     "CLASS_NAME",
		105:     "NODE_LABEL",
		106:     "FILENAME",
		118:     "OVERLAYS",
		120:     "HASH",
		130:     "ARGUMENT_NAME",
		131:     "KEY",
		132:     "CLASS_SHORT_NAME",
		158:     "ALIAS_TYPE_FULL_NAME",
		159:     "CLOSURE_ORIGINAL_NAME",
		221:     "IS_VARIADIC",
		1199:    "ROOT",
		1591:    "DYNAMIC_TYPE_HINT_FULL_NAME",
		2223:    "INDEX",
		2001092: "CANONICAL_NAME",
		2007161: "CONTAINED_REF",
	}
	NodePropertyName_value = map[string]int32{
		"UNKNOWN_NODE_PROPERTY":        0,
		"LINE_NUMBER":                  2,
		"PARSER_TYPE_NAME":             3,
		"ORDER":                        4,
		"NAME":                         5,
		"FULL_NAME":                    6,
		"IS_EXTERNAL":                  7,
		"VALUE":                        8,
		"COLUMN_NUMBER":                11,
		"LINE_NUMBER_END":              12,
		"VERSION":                      13,
		"EVALUATION_STRATEGY":          15,
		"COLUMN_NUMBER_END":            16,
		"LANGUAGE":                     19,
		"CONTENT":                      20,
		"CODE":                         21,
		"SIGNATURE":                    22,
		"DISPATCH_TYPE":                25,
		"MODIFIER_TYPE":                26,
		"CONTROL_STRUCTURE_TYPE":       27,
		"ARGUMENT_INDEX":               40,
		"CLOSURE_BINDING_ID":           50,
		"TYPE_FULL_NAME":               51,
		"TYPE_DECL_FULL_NAME":          52,
		"INHERITS_FROM_TYPE_FULL_NAME": 53,
		"METHOD_FULL_NAME":             54,
		"AST_PARENT_TYPE":              56,
		"AST_PARENT_FULL_NAME":         57,
		"DEPENDENCY_GROUP_ID":          58,
		"SYMBOL":                       100,
		"METHOD_SHORT_NAME":            102,
		"PACKAGE_NAME":                 103,
		"CLASS_NAME":                   104,
		"NODE_LABEL":                   105,
		"FILENAME":                     106,
		"OVERLAYS":                     118,
		"HASH":                         120,
		"ARGUMENT_NAME":                130,
		"KEY":                          131,
		"CLASS_SHORT_NAME":             132,
		"ALIAS_TYPE_FULL_NAME":         158,
		"CLOSURE_ORIGINAL_NAME":        159,
		"IS_VARIADIC":                  221,
		"ROOT":                         1199,
		"DYNAMIC_TYPE_HINT_FULL_NAME":  1591,
		"INDEX":                        2223,
		"CANONICAL_NAME":               2001092,
		"CONTAINED_REF":                2007161,
	}
)

func (x NodePropertyName) Enum() *NodePropertyName {
	p := new(NodePropertyName)
	*p = x
	return p
}

func (x NodePropertyName) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (NodePropertyName) Descriptor() protoreflect.EnumDescriptor {
	return file_atom_proto_enumTypes[0].Descriptor()
}

func (NodePropertyName) Type() protoreflect.EnumType {
	return &file_atom_proto_enumTypes[0]
}

func (x NodePropertyName) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use NodePropertyName.Descriptor instead.
func (NodePropertyName) EnumDescriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{0}
}

// Enum for the name of an edge
type EdgePropertyName int32

const (
	EdgePropertyName_UNKNOWN_EDGE_PROPERTY EdgePropertyName = 0
	// This edge property represents the variable propagated by a reaching definition edge.
	EdgePropertyName_VARIABLE EdgePropertyName = 11
)

// Enum value maps for EdgePropertyName.
var (
	EdgePropertyName_name = map[int32]string{
		0:  "UNKNOWN_EDGE_PROPERTY",
		11: "VARIABLE",
	}
	EdgePropertyName_value = map[string]int32{
		"UNKNOWN_EDGE_PROPERTY": 0,
		"VARIABLE":              11,
	}
)

func (x EdgePropertyName) Enum() *EdgePropertyName {
	p := new(EdgePropertyName)
	*p = x
	return p
}

func (x EdgePropertyName) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (EdgePropertyName) Descriptor() protoreflect.EnumDescriptor {
	return file_atom_proto_enumTypes[1].Descriptor()
}

func (EdgePropertyName) Type() protoreflect.EnumType {
	return &file_atom_proto_enumTypes[1]
}

func (x EdgePropertyName) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use EdgePropertyName.Descriptor instead.
func (EdgePropertyName) EnumDescriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{1}
}

// Enum for the possible modifier types for symbols, methods and class nodes
type ModifierTypes int32

const (
	ModifierTypes_UNKNOWN_MODIFIER_TYPE ModifierTypes = 0
	// The static modifier
	ModifierTypes_STATIC ModifierTypes = 1
	// The public modifier
	ModifierTypes_PUBLIC ModifierTypes = 2
	// The protected modifier
	ModifierTypes_PROTECTED ModifierTypes = 3
	// The private modifier
	ModifierTypes_PRIVATE ModifierTypes = 4
	// The abstract modifier
	ModifierTypes_ABSTRACT ModifierTypes = 5
	// The native modifier
	ModifierTypes_NATIVE ModifierTypes = 6
	// The constructor modifier
	ModifierTypes_CONSTRUCTOR ModifierTypes = 7
	// The virtual modifier
	ModifierTypes_VIRTUAL ModifierTypes = 8
	// The internal modifier
	ModifierTypes_INTERNAL ModifierTypes = 9
	// The final modifier
	ModifierTypes_FINAL ModifierTypes = 10
	// The readonly modifier
	ModifierTypes_READONLY ModifierTypes = 11
)

// Enum value maps for ModifierTypes.
var (
	ModifierTypes_name = map[int32]string{
		0:  "UNKNOWN_MODIFIER_TYPE",
		1:  "STATIC",
		2:  "PUBLIC",
		3:  "PROTECTED",
		4:  "PRIVATE",
		5:  "ABSTRACT",
		6:  "NATIVE",
		7:  "CONSTRUCTOR",
		8:  "VIRTUAL",
		9:  "INTERNAL",
		10: "FINAL",
		11: "READONLY",
	}
	ModifierTypes_value = map[string]int32{
		"UNKNOWN_MODIFIER_TYPE": 0,
		"STATIC":                1,
		"PUBLIC":                2,
		"PROTECTED":             3,
		"PRIVATE":               4,
		"ABSTRACT":              5,
		"NATIVE":                6,
		"CONSTRUCTOR":           7,
		"VIRTUAL":               8,
		"INTERNAL":              9,
		"FINAL":                 10,
		"READONLY":              11,
	}
)

func (x ModifierTypes) Enum() *ModifierTypes {
	p := new(ModifierTypes)
	*p = x
	return p
}

func (x ModifierTypes) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ModifierTypes) Descriptor() protoreflect.EnumDescriptor {
	return file_atom_proto_enumTypes[2].Descriptor()
}

func (ModifierTypes) Type() protoreflect.EnumType {
	return &file_atom_proto_enumTypes[2]
}

func (x ModifierTypes) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ModifierTypes.Descriptor instead.
func (ModifierTypes) EnumDescriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{2}
}

// Enum to represent the frontend language
type LANGUAGES int32

const (
	// Unknown language
	LANGUAGES_UNKNOWN_LANGUAGE LANGUAGES = 0
	// Java
	LANGUAGES_JAVA LANGUAGES = 1
	// JavaScript and TypeScript
	LANGUAGES_JAVASCRIPT LANGUAGES = 2
	// Go
	LANGUAGES_GOLANG LANGUAGES = 3
	// csharp / dotnet
	LANGUAGES_CSHARP LANGUAGES = 4
	// C/C++
	LANGUAGES_C LANGUAGES = 5
	// Python
	LANGUAGES_PYTHON LANGUAGES = 6
	// llvm
	LANGUAGES_LLVM LANGUAGES = 7
	// PHP
	LANGUAGES_PHP LANGUAGES = 8
	// Test
	LANGUAGES_FUZZY_TEST_LANG LANGUAGES = 9
	// generic reverse engineering framework
	LANGUAGES_GHIDRA LANGUAGES = 10
	// Kotlin
	LANGUAGES_KOTLIN LANGUAGES = 11
	// Eclipse CDT based parser for C/C++
	LANGUAGES_NEWC LANGUAGES = 12
	// Source-based front-end for Java
	LANGUAGES_JAVASRC LANGUAGES = 13
	// Source-based front-end for Python
	LANGUAGES_PYTHONSRC LANGUAGES = 14
	// Source-based JS frontend based on Babel
	LANGUAGES_JSSRC LANGUAGES = 15
	// Solidity language frontend
	LANGUAGES_SOLIDITY LANGUAGES = 16
	// Source-based frontend for Ruby
	LANGUAGES_RUBYSRC LANGUAGES = 17
)

// Enum value maps for LANGUAGES.
var (
	LANGUAGES_name = map[int32]string{
		0:  "UNKNOWN_LANGUAGE",
		1:  "JAVA",
		2:  "JAVASCRIPT",
		3:  "GOLANG",
		4:  "CSHARP",
		5:  "C",
		6:  "PYTHON",
		7:  "LLVM",
		8:  "PHP",
		9:  "FUZZY_TEST_LANG",
		10: "GHIDRA",
		11: "KOTLIN",
		12: "NEWC",
		13: "JAVASRC",
		14: "PYTHONSRC",
		15: "JSSRC",
		16: "SOLIDITY",
		17: "RUBYSRC",
	}
	LANGUAGES_value = map[string]int32{
		"UNKNOWN_LANGUAGE": 0,
		"JAVA":             1,
		"JAVASCRIPT":       2,
		"GOLANG":           3,
		"CSHARP":           4,
		"C":                5,
		"PYTHON":           6,
		"LLVM":             7,
		"PHP":              8,
		"FUZZY_TEST_LANG":  9,
		"GHIDRA":           10,
		"KOTLIN":           11,
		"NEWC":             12,
		"JAVASRC":          13,
		"PYTHONSRC":        14,
		"JSSRC":            15,
		"SOLIDITY":         16,
		"RUBYSRC":          17,
	}
)

func (x LANGUAGES) Enum() *LANGUAGES {
	p := new(LANGUAGES)
	*p = x
	return p
}

func (x LANGUAGES) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (LANGUAGES) Descriptor() protoreflect.EnumDescriptor {
	return file_atom_proto_enumTypes[3].Descriptor()
}

func (LANGUAGES) Type() protoreflect.EnumType {
	return &file_atom_proto_enumTypes[3]
}

func (x LANGUAGES) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use LANGUAGES.Descriptor instead.
func (LANGUAGES) EnumDescriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{3}
}

// Enum representing the evaluation strategy of the underlying parameter or method or literal.
type EvaluationStrategies int32

const (
	EvaluationStrategies_UNKNOWN_EVALUATION_STRATEGY EvaluationStrategies = 0
	// A parameter or return of a function is passed by reference which means an address is used behind the scenes
	EvaluationStrategies_BY_REFERENCE EvaluationStrategies = 1
	// Only applicable to object parameter or return values. The pointer to the object is passed by value but the object itself is not copied and changes to it are thus propagated out of the method context
	EvaluationStrategies_BY_SHARING EvaluationStrategies = 2
	// A parameter or return of a function passed by value which means a flat copy is used
	EvaluationStrategies_BY_VALUE EvaluationStrategies = 3
)

// Enum value maps for EvaluationStrategies.
var (
	EvaluationStrategies_name = map[int32]string{
		0: "UNKNOWN_EVALUATION_STRATEGY",
		1: "BY_REFERENCE",
		2: "BY_SHARING",
		3: "BY_VALUE",
	}
	EvaluationStrategies_value = map[string]int32{
		"UNKNOWN_EVALUATION_STRATEGY": 0,
		"BY_REFERENCE":                1,
		"BY_SHARING":                  2,
		"BY_VALUE":                    3,
	}
)

func (x EvaluationStrategies) Enum() *EvaluationStrategies {
	p := new(EvaluationStrategies)
	*p = x
	return p
}

func (x EvaluationStrategies) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (EvaluationStrategies) Descriptor() protoreflect.EnumDescriptor {
	return file_atom_proto_enumTypes[4].Descriptor()
}

func (EvaluationStrategies) Type() protoreflect.EnumType {
	return &file_atom_proto_enumTypes[4]
}

func (x EvaluationStrategies) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use EvaluationStrategies.Descriptor instead.
func (EvaluationStrategies) EnumDescriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{4}
}

// Enum representing the dispatch types
type DispatchTypes int32

const (
	DispatchTypes_UNKNOWN_DISPATCH_TYPE DispatchTypes = 0
	// For statically dispatched calls the call target is known before program execution
	DispatchTypes_STATIC_DISPATCH DispatchTypes = 1
	// For dynamically dispatched calls the target is determined during runtime
	DispatchTypes_DYNAMIC_DISPATCH DispatchTypes = 2
	// For macro expansions, code is inlined.
	DispatchTypes_INLINED DispatchTypes = 3
)

// Enum value maps for DispatchTypes.
var (
	DispatchTypes_name = map[int32]string{
		0: "UNKNOWN_DISPATCH_TYPE",
		1: "STATIC_DISPATCH",
		2: "DYNAMIC_DISPATCH",
		3: "INLINED",
	}
	DispatchTypes_value = map[string]int32{
		"UNKNOWN_DISPATCH_TYPE": 0,
		"STATIC_DISPATCH":       1,
		"DYNAMIC_DISPATCH":      2,
		"INLINED":               3,
	}
)

func (x DispatchTypes) Enum() *DispatchTypes {
	p := new(DispatchTypes)
	*p = x
	return p
}

func (x DispatchTypes) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DispatchTypes) Descriptor() protoreflect.EnumDescriptor {
	return file_atom_proto_enumTypes[5].Descriptor()
}

func (DispatchTypes) Type() protoreflect.EnumType {
	return &file_atom_proto_enumTypes[5]
}

func (x DispatchTypes) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DispatchTypes.Descriptor instead.
func (DispatchTypes) EnumDescriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{5}
}

// Enum representing the control structure types
type CONTROL_STRUCTURE_TYPES int32

const (
	CONTROL_STRUCTURE_TYPES_UNKNOWN_CONTROL_STRUCTURE_TYPE CONTROL_STRUCTURE_TYPES = 0
	// Represents a break statement. Labeled breaks are expected to have a JUMP_LABEL node AST child with ORDER 1
	CONTROL_STRUCTURE_TYPES_BREAK CONTROL_STRUCTURE_TYPES = 1
	// Represents a continue statement. Labeled continues are expected to have a JUMP_LABEL node AST child with ORDER 1
	CONTROL_STRUCTURE_TYPES_CONTINUE CONTROL_STRUCTURE_TYPES = 2
	// Represents a while statement
	CONTROL_STRUCTURE_TYPES_WHILE CONTROL_STRUCTURE_TYPES = 3
	// Represents a do statement
	CONTROL_STRUCTURE_TYPES_DO CONTROL_STRUCTURE_TYPES = 4
	// Represents a for statement
	CONTROL_STRUCTURE_TYPES_FOR CONTROL_STRUCTURE_TYPES = 5
	// Represents a goto statement
	CONTROL_STRUCTURE_TYPES_GOTO CONTROL_STRUCTURE_TYPES = 6
	// Represents an if statement
	CONTROL_STRUCTURE_TYPES_IF CONTROL_STRUCTURE_TYPES = 7
	// Represents an else statement
	CONTROL_STRUCTURE_TYPES_ELSE CONTROL_STRUCTURE_TYPES = 8
	// Represents a switch statement
	CONTROL_STRUCTURE_TYPES_SWITCH CONTROL_STRUCTURE_TYPES = 9
	// Represents a try statement
	CONTROL_STRUCTURE_TYPES_TRY CONTROL_STRUCTURE_TYPES = 10
	// Represents a throw statement
	CONTROL_STRUCTURE_TYPES_THROW CONTROL_STRUCTURE_TYPES = 11
	// Represents a match expression
	CONTROL_STRUCTURE_TYPES_MATCH CONTROL_STRUCTURE_TYPES = 12
	// Represents a yield expression
	CONTROL_STRUCTURE_TYPES_YIELD CONTROL_STRUCTURE_TYPES = 13
)

// Enum value maps for CONTROL_STRUCTURE_TYPES.
var (
	CONTROL_STRUCTURE_TYPES_name = map[int32]string{
		0:  "UNKNOWN_CONTROL_STRUCTURE_TYPE",
		1:  "BREAK",
		2:  "CONTINUE",
		3:  "WHILE",
		4:  "DO",
		5:  "FOR",
		6:  "GOTO",
		7:  "IF",
		8:  "ELSE",
		9:  "SWITCH",
		10: "TRY",
		11: "THROW",
		12: "MATCH",
		13: "YIELD",
	}
	CONTROL_STRUCTURE_TYPES_value = map[string]int32{
		"UNKNOWN_CONTROL_STRUCTURE_TYPE": 0,
		"BREAK":                          1,
		"CONTINUE":                       2,
		"WHILE":                          3,
		"DO":                             4,
		"FOR":                            5,
		"GOTO":                           6,
		"IF":                             7,
		"ELSE":                           8,
		"SWITCH":                         9,
		"TRY":                            10,
		"THROW":                          11,
		"MATCH":                          12,
		"YIELD":                          13,
	}
)

func (x CONTROL_STRUCTURE_TYPES) Enum() *CONTROL_STRUCTURE_TYPES {
	p := new(CONTROL_STRUCTURE_TYPES)
	*p = x
	return p
}

func (x CONTROL_STRUCTURE_TYPES) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CONTROL_STRUCTURE_TYPES) Descriptor() protoreflect.EnumDescriptor {
	return file_atom_proto_enumTypes[6].Descriptor()
}

func (CONTROL_STRUCTURE_TYPES) Type() protoreflect.EnumType {
	return &file_atom_proto_enumTypes[6]
}

func (x CONTROL_STRUCTURE_TYPES) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CONTROL_STRUCTURE_TYPES.Descriptor instead.
func (CONTROL_STRUCTURE_TYPES) EnumDescriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{6}
}

// *
// Programming languages offer many closely-related concepts for describing blocks of code that can be executed with input parameters and return output parameters, possibly causing side effects. In the CPG specification, we refer to all of these concepts (procedures, functions, methods, etc.) as methods. A single METHOD node must exist for each method found in the source program.
// The `FULL_NAME` field specifies the method's fully-qualified name, including information about the namespace it is contained in if applicable, the name field is the function's short name. The field `IS_EXTERNAL` indicates whether it was possible to identify a method body for the method. This is true for methods that are defined in the source program, and false for methods that are dynamically linked to the program, that is, methods that exist in an external dependency.
// Line and column number information is specified in the optional fields `LINE_NUMBER`, `COLUMN_NUMBER`, `LINE_NUMBER_END`, and `COLUMN_NUMBER_END` and the name of the source file is specified in `FILENAME`. An optional hash value MAY be calculated over the function contents and included in the `HASH` field.
// Finally, the fully qualified name of the program constructs that the method is immediately contained in is stored in the `AST_PARENT_FULL_NAME` field and its type is indicated in the `AST_PARENT_TYPE` field to be one of `METHOD`, `TYPE_DECL` or `NAMESPACE_BLOCK`.
type NodeType int32

const (
	NodeType_UNKNOWN_NODE_TYPE NodeType = 0
	// Method Nodes
	NodeType_METHOD NodeType = 1
	// This node represents an (unnamed) formal method return parameter. It carries its fully qualified type name in `TYPE_FULL_NAME`. The `CODE` field MAY be set freely, e.g., to the constant `RET`, however, subsequent layer creators MUST NOT depend on this value.
	NodeType_METHOD_RETURN NodeType = 3
	// A method annotation. The semantics of the FULL_NAME property on this node differ from the usual FULL_NAME semantics in the sense that FULL_NAME describes the represented annotation class/interface itself and not the ANNOTATION node.
	NodeType_ANNOTATION NodeType = 5
	// Assignment of annotation argument to annotation parameter
	NodeType_ANNOTATION_PARAMETER_ASSIGN NodeType = 6
	// Formal annotation parameter
	NodeType_ANNOTATION_PARAMETER NodeType = 7
	// This node represents a literal such as an integer or string constant. Literals are symbols included in the code in verbatim form and which are immutable. The `TYPE_FULL_NAME` field stores the literal's fully-qualified type name, e.g., `java.lang.Integer`.
	NodeType_LITERAL NodeType = 8
	// This node represents a type member of a class, struct or union, e.g., for the type declaration `class Foo{ int i ; }`, it represents the declaration of the variable `i`.
	NodeType_MEMBER NodeType = 9
	// Initialization construct for arrays
	NodeType_ARRAY_INITIALIZER NodeType = 14
	// A (function/method/procedure) call. The `METHOD_FULL_NAME` property is the name of the invoked method (the callee) while the `TYPE_FULL_NAME` is its return type, and therefore, the return type of the call when viewing it as an expression. For languages like Javascript, it is common that we may know the (short-) name of the invoked method, but we do not know at compile time which method will actually be invoked, e.g., because it depends on a dynamic import. In this case, we leave `METHOD_FULL_NAME` blank but at least fill out `NAME`, which contains the method's (short-) name and `SIGNATURE`, which contains any information we may have about the types of arguments and return value.
	NodeType_CALL NodeType = 15
	// This node represents a local variable. Its fully qualified type name is stored in the `TYPE_FULL_NAME` field and its name in the `NAME` field. The `CODE` field contains the entire local variable declaration without initialization, e.g., for `int x = 10;`, it contains `int x`.
	NodeType_LOCAL NodeType = 23
	// This node represents a tag.
	NodeType_TAG NodeType = 24
	// A location node summarizes a source code location.
	NodeType_LOCATION NodeType = 25
	// This node represents an identifier as used when referring to a variable by name. It holds the identifier's name in the `NAME` field and its fully-qualified type name in `TYPE_FULL_NAME`.
	NodeType_IDENTIFIER NodeType = 27
	// This node represents a return instruction, e.g., `return x`. Note that it does NOT represent a formal return parameter as formal return parameters are represented via `METHOD_RETURN` nodes.
	NodeType_RETURN NodeType = 30
	// This node represents a compound statement. Compound statements are used in many languages to allow grouping a sequence of statements. For example, in C and Java, compound statements are statements enclosed by curly braces. Function/Method bodies are compound statements. We do not use the term "compound statement" because "statement" would imply that the block does not yield a value upon evaluation, that is, that it is not an expression. This is true in languages such as C and Java, but not for languages such as Scala where the value of the block is given by that of the last expression it contains. In fact, the Scala grammar uses the term "BlockExpr" (short for "block expression") to describe what in the CPG we call "Block".
	NodeType_BLOCK NodeType = 31
	// This node represents a formal output parameter. Corresponding output parameters for input parameters MUST NOT be created by the frontend as they are automatically created upon first loading the CPG.
	NodeType_METHOD_PARAMETER_OUT NodeType = 33
	// This node represents a formal input parameter. The field `NAME` contains its name, while the field `TYPE_FULL_NAME` contains the fully qualified type name.
	NodeType_METHOD_PARAMETER_IN NodeType = 34
	// This node represents a dependency
	NodeType_DEPENDENCY NodeType = 35
	// *
	// File nodes represent source files or a shared objects from which the CPG was generated. File nodes serve as indices, that is, they allow looking up all elements of the code by file.
	// For each file, the graph MUST contain exactly one File node. As file nodes are root nodes of abstract syntax tress, they are AstNodes and their order field is set to 0. This is because they have no sibling nodes, not because they are the first node of the AST.
	// Each CPG MUST contain a special file node with name set to `<unknown>`. This node is a placeholder used in cases where a file cannot be determined at compile time. As an example, consider external library functions. As their code is not available on CPG construction, the file name is unknown.
	// File nodes MUST NOT be created by the language frontend. Instead, the language frontend is assumed to fill out the `FILENAME` field wherever possible, allowing File nodes to be created automatically upon first loading the CPG.
	NodeType_FILE NodeType = 38
	// This node contains the CPG meta data. Exactly one node of this type MUST exist per CPG. The `HASH` property MAY contain a hash value calculated over the source files this CPG was generated from. The `VERSION` MUST be set to the version of the specification ("1.1"). The language field indicates which language frontend was used to generate the CPG and the list property `OVERLAYS` specifies which overlays have been applied to the CPG.
	NodeType_META_DATA NodeType = 39
	// This node represents a namespace. Similar to FILE nodes, NAMESPACE nodes serve as indices that allow all definitions inside a namespace to be obtained by following outgoing edges from a NAMESPACE node.
	// NAMESPACE nodes MUST NOT be created by language frontends. Instead, they are generated from NAMESPACE_BLOCK nodes automatically upon first loading of the CPG.
	NodeType_NAMESPACE NodeType = 40
	// *
	// A reference to a namespace.
	// We borrow the concept of a "namespace block" from C++, that is, a namespace block is a block of code that has been placed in the same namespace by a programmer. This block may be introduced via a `package` statement in Java or a `namespace{ }` statement in C++.
	// The `FULL_NAME` field contains a unique identifier to represent the namespace block itself not just the namespace it references. So in addition to the namespace name it can be useful to use the containing file name to derive a unique identifier.
	//
	// The `NAME` field contains the namespace name in a human-readable format. The name should be given in dot-separated form where a dot indicates that the right hand side is a sub namespace of the left hand side, e.g., `foo.bar` denotes the namespace `bar` contained in the namespace `foo`.
	NodeType_NAMESPACE_BLOCK NodeType = 41
	// Any AST node that the frontend would like to include in the AST but for which no suitable AST node is specified in the CPG specification may be included using a node of type `UNKNOWN`.
	NodeType_UNKNOWN NodeType = 44
	// This node represents a type instance, that is, a concrete instantiation of a type declaration.
	NodeType_TYPE NodeType = 45
	// *
	// This node represents a type declaration as for example given by a class-, struct-, or union declaration. In contrast to a `TYPE` node, this node does not represent a concrete instantiation of a type, e.g., for the parametrized type `List[T]`, it represents `List[T]`, but not `List[Integer]` where `Integer` is a concrete type.
	// The language frontend MUST create type declarations for all types declared in the source program and MAY provide type declarations for types that are not declared but referenced by the source program. If a declaration is present in the source program, the field `IS_EXTERNAL` is set to `false`. Otherwise, it is set to `true`.
	// The `FULL_NAME` field specifies the type's fully-qualified name, including information about the namespace it is contained in if applicable, the name field is the type's short name. Line and column number information is specified in the optional fields `LINE_NUMBER`, `COLUMN_NUMBER`, `LINE_NUMBER_END`, and `COLUMN_NUMBER_END` and the name of the source file is specified in `FILENAME`.
	// Base types can be specified via the `INHERITS_FROM_TYPE_FULL_NAME` list, where each entry contains the fully-qualified name of a base type. If the type is known to be an alias of another type (as for example introduced via the C `typedef` statement), the name of the alias is stored in `ALIAS_TYPE_FULL_NAME`.
	// Finally, the fully qualified name of the program constructs that the type declaration is immediately contained in is stored in the `AST_PARENT_FULL_NAME` field and its type is indicated in the `AST_PARENT_TYPE` field to be one of `METHOD`, `TYPE_DECL` or `NAMESPACE_BLOCK`.
	NodeType_TYPE_DECL NodeType = 46
	// This node represents a formal type parameter, that is, the type parameter as given in a type-parametrized method or type declaration. Examples for languages that support type parameters are Java (via Generics) and C++ (via templates). Apart from the standard fields of AST nodes, the type parameter carries only a `NAME` field that holds the parameters name.
	NodeType_TYPE_PARAMETER NodeType = 47
	// An (actual) type argument as used to instantiate a parametrized type, in the same way an (actual) arguments provides concrete values for a parameter at method call sites. As it true for arguments, the method is not expected to  interpret the type argument. It MUST however store its code in the `CODE` field.
	NodeType_TYPE_ARGUMENT NodeType = 48
	// A literal value assigned to an ANNOTATION_PARAMETER
	NodeType_ANNOTATION_LITERAL NodeType = 49
	// This node type represent a configuration file, where `NAME` is the name of the file and `content` is its content. The exact representation of the name is left undefined and can be chosen as required by consumers of the corresponding configuration files.
	NodeType_CONFIG_FILE NodeType = 50
	// `BINDING` nodes represent name-signature pairs that can be resolved at a type declaration (`TYPE_DECL`). They are connected to `TYPE_DECL` nodes via incoming `BINDS` edges. The bound method is either associated with an outgoing `REF` edge to a `METHOD` or with the `METHOD_FULL_NAME` property. The `REF` edge if present has priority.
	NodeType_BINDING NodeType = 146
	// This node contains an arbitrary node and an associated tag node.
	NodeType_TAG_NODE_PAIR NodeType = 208
	// Finding nodes may be used to store analysis results in the graph that are to be exposed to an end-user, e.g., information about potential vulnerabilities or dangerous programming practices.
	// A Finding node may contain an abitrary list of key value pairs that characterize the finding, as well as a list of nodes that serve as evidence for the finding.
	NodeType_FINDING NodeType = 214
	// This node represents a key value pair, where both the key and the value are strings.
	NodeType_KEY_VALUE_PAIR NodeType = 217
	// This field represents a (language-dependent) modifier such as `static`, `private` or `public`. Unlike most other AST nodes, it is NOT an expression, that is, it cannot be evaluated and cannot be passed as an argument in function calls.
	NodeType_MODIFIER NodeType = 300
	// This node represents a reference to a method/function/procedure as it appears when a method is passed as an argument in a call. The `METHOD_FULL_NAME` field holds the fully-qualified name of the referenced method and the `TYPE_FULL_NAME` holds its fully-qualified type name.
	NodeType_METHOD_REF NodeType = 333
	// Represents the binding of a LOCAL or METHOD_PARAMETER_IN into the closure of a method
	NodeType_CLOSURE_BINDING NodeType = 334
	// Reference to a type/class
	NodeType_TYPE_REF NodeType = 335
	// In addition to the `CONTROL_STRUCTURE_TYPE` field, the `PARSER_TYPE_NAME` field MAY be used by frontends to store the name of the control structure as emitted by the parser or disassembler, however, the value of this field is not relevant for construction of the control flow layer.
	NodeType_CONTROL_STRUCTURE NodeType = 339
	// A jump target is any location in the code that has been specifically marked as the target of a jump, e.g., via a label. The `NAME` field holds the name of the label while the `PARSER_TYPE_NAME` field holds the name of language construct that this jump target is created from, e.g., "Label".
	NodeType_JUMP_TARGET NodeType = 340
	// A jump label specifies the label and thus the JUMP_TARGET of control structures BREAK and CONTINUE. The `NAME` field holds the name of the label while the `PARSER_TYPE_NAME` field holds the name of language construct that this jump label is created from, e.g., "Label".
	NodeType_JUMP_LABEL NodeType = 341
	// This node represents a DOM node used in template languages, e.g., JSX/TSX
	NodeType_TEMPLATE_DOM NodeType = 417
	// A source code comment
	NodeType_COMMENT NodeType = 511
	// This node represents the field accessed in a field access, e.g., in `a.b`, it represents `b`. The field name as it occurs in the code is stored in the `CODE` field. This may mean that the `CODE` field holds an expression. The `CANONICAL_NAME` field MAY contain the same value is the `CODE` field but SHOULD contain the normalized name that results from evaluating `CODE` as an expression if such an evaluation is possible for the language frontend. The objective is to store an identifier in `CANONICAL_NAME` that is the same for two nodes iff they refer to the same field, regardless of whether they use the same expression to reference it.
	NodeType_FIELD_IDENTIFIER NodeType = 2001081
)

// Enum value maps for NodeType.
var (
	NodeType_name = map[int32]string{
		0:       "UNKNOWN_NODE_TYPE",
		1:       "METHOD",
		3:       "METHOD_RETURN",
		5:       "ANNOTATION",
		6:       "ANNOTATION_PARAMETER_ASSIGN",
		7:       "ANNOTATION_PARAMETER",
		8:       "LITERAL",
		9:       "MEMBER",
		14:      "ARRAY_INITIALIZER",
		15:      "CALL",
		23:      "LOCAL",
		24:      "TAG",
		25:      "LOCATION",
		27:      "IDENTIFIER",
		30:      "RETURN",
		31:      "BLOCK",
		33:      "METHOD_PARAMETER_OUT",
		34:      "METHOD_PARAMETER_IN",
		35:      "DEPENDENCY",
		38:      "FILE",
		39:      "META_DATA",
		40:      "NAMESPACE",
		41:      "NAMESPACE_BLOCK",
		44:      "UNKNOWN",
		45:      "TYPE",
		46:      "TYPE_DECL",
		47:      "TYPE_PARAMETER",
		48:      "TYPE_ARGUMENT",
		49:      "ANNOTATION_LITERAL",
		50:      "CONFIG_FILE",
		146:     "BINDING",
		208:     "TAG_NODE_PAIR",
		214:     "FINDING",
		217:     "KEY_VALUE_PAIR",
		300:     "MODIFIER",
		333:     "METHOD_REF",
		334:     "CLOSURE_BINDING",
		335:     "TYPE_REF",
		339:     "CONTROL_STRUCTURE",
		340:     "JUMP_TARGET",
		341:     "JUMP_LABEL",
		417:     "TEMPLATE_DOM",
		511:     "COMMENT",
		2001081: "FIELD_IDENTIFIER",
	}
	NodeType_value = map[string]int32{
		"UNKNOWN_NODE_TYPE":           0,
		"METHOD":                      1,
		"METHOD_RETURN":               3,
		"ANNOTATION":                  5,
		"ANNOTATION_PARAMETER_ASSIGN": 6,
		"ANNOTATION_PARAMETER":        7,
		"LITERAL":                     8,
		"MEMBER":                      9,
		"ARRAY_INITIALIZER":           14,
		"CALL":                        15,
		"LOCAL":                       23,
		"TAG":                         24,
		"LOCATION":                    25,
		"IDENTIFIER":                  27,
		"RETURN":                      30,
		"BLOCK":                       31,
		"METHOD_PARAMETER_OUT":        33,
		"METHOD_PARAMETER_IN":         34,
		"DEPENDENCY":                  35,
		"FILE":                        38,
		"META_DATA":                   39,
		"NAMESPACE":                   40,
		"NAMESPACE_BLOCK":             41,
		"UNKNOWN":                     44,
		"TYPE":                        45,
		"TYPE_DECL":                   46,
		"TYPE_PARAMETER":              47,
		"TYPE_ARGUMENT":               48,
		"ANNOTATION_LITERAL":          49,
		"CONFIG_FILE":                 50,
		"BINDING":                     146,
		"TAG_NODE_PAIR":               208,
		"FINDING":                     214,
		"KEY_VALUE_PAIR":              217,
		"MODIFIER":                    300,
		"METHOD_REF":                  333,
		"CLOSURE_BINDING":             334,
		"TYPE_REF":                    335,
		"CONTROL_STRUCTURE":           339,
		"JUMP_TARGET":                 340,
		"JUMP_LABEL":                  341,
		"TEMPLATE_DOM":                417,
		"COMMENT":                     511,
		"FIELD_IDENTIFIER":            2001081,
	}
)

func (x NodeType) Enum() *NodeType {
	p := new(NodeType)
	*p = x
	return p
}

func (x NodeType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (NodeType) Descriptor() protoreflect.EnumDescriptor {
	return file_atom_proto_enumTypes[7].Descriptor()
}

func (NodeType) Type() protoreflect.EnumType {
	return &file_atom_proto_enumTypes[7]
}

func (x NodeType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use NodeType.Descriptor instead.
func (NodeType) EnumDescriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{7}
}

// Edge type.
type CpgStruct_Edge_EdgeType int32

const (
	CpgStruct_Edge_UNKNOWN_EDGE_TYPE CpgStruct_Edge_EdgeType = 0
	// This edge connects a parent node to its child in the syntax tree.
	CpgStruct_Edge_AST CpgStruct_Edge_EdgeType = 3
	// This edge connects call sites, i.e., nodes with the type `CALL`, to the method node that represent the method they invoke. The frontend MAY create `CALL` edges but is not required to do so. Instead, of the `METHOD_FULL_NAME` field of the `CALL` node is set correctly, `CALL` edges are created automatically as the CPG is first loaded.
	CpgStruct_Edge_CALL CpgStruct_Edge_EdgeType = 6
	// This edge indicates that the source node is an identifier that denotes access to the destination node. For example, an identifier may reference a local variable.
	CpgStruct_Edge_REF CpgStruct_Edge_EdgeType = 10
	// Edges from nodes to the tags they are tagged by.
	CpgStruct_Edge_TAGGED_BY CpgStruct_Edge_EdgeType = 11
	// This edge connects a method input parameter to the corresponding method output parameter.
	CpgStruct_Edge_PARAMETER_LINK CpgStruct_Edge_EdgeType = 12
	// This edge indicates control flow from the source to the destination node.
	CpgStruct_Edge_CFG CpgStruct_Edge_EdgeType = 19
	// This edge connects a node to its evaluation type.
	CpgStruct_Edge_EVAL_TYPE CpgStruct_Edge_EdgeType = 21
	// This edge connects type arguments to type parameters to indicate that the type argument is used to instantiate the type parameter.
	CpgStruct_Edge_BINDS_TO CpgStruct_Edge_EdgeType = 22
	// Inheritance relation between a type declaration and a type. This edge MUST NOT be created by the language frontend as it is automatically created from `INHERITS_FROM_TYPE_FULL_NAME` fields then the CPG is first loaded.
	CpgStruct_Edge_INHERITS_FROM CpgStruct_Edge_EdgeType = 23
	// This edge connects a node to the method that contains it.
	CpgStruct_Edge_CONTAINS CpgStruct_Edge_EdgeType = 28
	// Represents the capturing of a variable into a closure
	CpgStruct_Edge_CAPTURE CpgStruct_Edge_EdgeType = 40
	// Connection between a captured LOCAL and the corresponding CLOSURE_BINDING
	CpgStruct_Edge_CAPTURED_BY CpgStruct_Edge_EdgeType = 41
	// Similar to `ARGUMENT` edges, `RECEIVER` edges connect call sites to their receiver arguments. A receiver argument is the object on which a method operates, that is, it is the expression that is assigned to the `this` pointer as control is transferred to the method.
	CpgStruct_Edge_RECEIVER CpgStruct_Edge_EdgeType = 55
	// The edge connects control structure nodes to the expressions that holds their conditions.
	CpgStruct_Edge_CONDITION CpgStruct_Edge_EdgeType = 56
	// A reaching definition edge indicates that a variable produced at the source node reaches the destination node without being reassigned on the way. The `VARIABLE` property indicates which variable is propagated.
	CpgStruct_Edge_REACHING_DEF CpgStruct_Edge_EdgeType = 137
	// This edge represents an alias relation between a type declaration and a type. The language frontend MUST NOT create `ALIAS_OF` edges as they are created automatically based on `ALIAS_TYPE_FULL_NAME` fields when the CPG is first loaded.
	CpgStruct_Edge_ALIAS_OF CpgStruct_Edge_EdgeType = 138
	// This edge connects a type declaration (`TYPE_DECL`) with a binding node (`BINDING`) and indicates that the type declaration has the binding represented by the binding node, in other words, there is a (name, signature) pair that can be resolved for the type declaration as stored in the binding node.
	CpgStruct_Edge_BINDS CpgStruct_Edge_EdgeType = 155
	// Argument edges connect call sites (node type `CALL`) to their arguments (node type `EXPRESSION`) as well as `RETURN` nodes to the expressions that return.
	CpgStruct_Edge_ARGUMENT CpgStruct_Edge_EdgeType = 156
	// This edge connects a node to the node that represents its source file. These edges MUST not be created by the language frontend but are automatically created based on `FILENAME` fields.
	CpgStruct_Edge_SOURCE_FILE CpgStruct_Edge_EdgeType = 157
	// This edge indicates that the source node immediately dominates the destination node.
	CpgStruct_Edge_DOMINATE CpgStruct_Edge_EdgeType = 181
	// This edge indicates that the source node immediately post dominates the destination node.
	CpgStruct_Edge_POST_DOMINATE CpgStruct_Edge_EdgeType = 182
	// A CDG edge expresses that the destination node is control dependent on the source node.
	CpgStruct_Edge_CDG CpgStruct_Edge_EdgeType = 183
	// Edge from imports to dependencies
	CpgStruct_Edge_IMPORTS CpgStruct_Edge_EdgeType = 23663
	// Edge from CALL statement in the AST to the IMPORT. We use this edge to traverse from the logical representation of the IMPORT to the corresponding import statement in the AST.
	CpgStruct_Edge_IS_CALL_FOR_IMPORT CpgStruct_Edge_EdgeType = 23664
)

// Enum value maps for CpgStruct_Edge_EdgeType.
var (
	CpgStruct_Edge_EdgeType_name = map[int32]string{
		0:     "UNKNOWN_EDGE_TYPE",
		3:     "AST",
		6:     "CALL",
		10:    "REF",
		11:    "TAGGED_BY",
		12:    "PARAMETER_LINK",
		19:    "CFG",
		21:    "EVAL_TYPE",
		22:    "BINDS_TO",
		23:    "INHERITS_FROM",
		28:    "CONTAINS",
		40:    "CAPTURE",
		41:    "CAPTURED_BY",
		55:    "RECEIVER",
		56:    "CONDITION",
		137:   "REACHING_DEF",
		138:   "ALIAS_OF",
		155:   "BINDS",
		156:   "ARGUMENT",
		157:   "SOURCE_FILE",
		181:   "DOMINATE",
		182:   "POST_DOMINATE",
		183:   "CDG",
		23663: "IMPORTS",
		23664: "IS_CALL_FOR_IMPORT",
	}
	CpgStruct_Edge_EdgeType_value = map[string]int32{
		"UNKNOWN_EDGE_TYPE":  0,
		"AST":                3,
		"CALL":               6,
		"REF":                10,
		"TAGGED_BY":          11,
		"PARAMETER_LINK":     12,
		"CFG":                19,
		"EVAL_TYPE":          21,
		"BINDS_TO":           22,
		"INHERITS_FROM":      23,
		"CONTAINS":           28,
		"CAPTURE":            40,
		"CAPTURED_BY":        41,
		"RECEIVER":           55,
		"CONDITION":          56,
		"REACHING_DEF":       137,
		"ALIAS_OF":           138,
		"BINDS":              155,
		"ARGUMENT":           156,
		"SOURCE_FILE":        157,
		"DOMINATE":           181,
		"POST_DOMINATE":      182,
		"CDG":                183,
		"IMPORTS":            23663,
		"IS_CALL_FOR_IMPORT": 23664,
	}
)

func (x CpgStruct_Edge_EdgeType) Enum() *CpgStruct_Edge_EdgeType {
	p := new(CpgStruct_Edge_EdgeType)
	*p = x
	return p
}

func (x CpgStruct_Edge_EdgeType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CpgStruct_Edge_EdgeType) Descriptor() protoreflect.EnumDescriptor {
	return file_atom_proto_enumTypes[8].Descriptor()
}

func (CpgStruct_Edge_EdgeType) Type() protoreflect.EnumType {
	return &file_atom_proto_enumTypes[8]
}

func (x CpgStruct_Edge_EdgeType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CpgStruct_Edge_EdgeType.Descriptor instead.
func (CpgStruct_Edge_EdgeType) EnumDescriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{8, 1, 0}
}

// Label type.
type UsageSlice_LabelType int32

const (
	// Any is used to represent multiple mechanisms
	UsageSlice_ANY UsageSlice_LabelType = 0
	// Represents a local transfer of data via aliasing. The data defined is via some alias.
	UsageSlice_LOCAL UsageSlice_LabelType = 1
	// Represents a literal.
	UsageSlice_LITERAL UsageSlice_LabelType = 2
	// Represents data introduced via a parameter.
	UsageSlice_PARAM UsageSlice_LabelType = 3
	// Represents data introduced by the return value of a call.
	UsageSlice_CALL UsageSlice_LabelType = 4
	// Identifier
	UsageSlice_IDENTIFIER UsageSlice_LabelType = 5
	// Type ref
	UsageSlice_TYPE_REF UsageSlice_LabelType = 6
	// Represents data introduced by an unhandled data structure.
	UsageSlice_UNKNOWN UsageSlice_LabelType = 10
)

// Enum value maps for UsageSlice_LabelType.
var (
	UsageSlice_LabelType_name = map[int32]string{
		0:  "ANY",
		1:  "LOCAL",
		2:  "LITERAL",
		3:  "PARAM",
		4:  "CALL",
		5:  "IDENTIFIER",
		6:  "TYPE_REF",
		10: "UNKNOWN",
	}
	UsageSlice_LabelType_value = map[string]int32{
		"ANY":        0,
		"LOCAL":      1,
		"LITERAL":    2,
		"PARAM":      3,
		"CALL":       4,
		"IDENTIFIER": 5,
		"TYPE_REF":   6,
		"UNKNOWN":    10,
	}
)

func (x UsageSlice_LabelType) Enum() *UsageSlice_LabelType {
	p := new(UsageSlice_LabelType)
	*p = x
	return p
}

func (x UsageSlice_LabelType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (UsageSlice_LabelType) Descriptor() protoreflect.EnumDescriptor {
	return file_atom_proto_enumTypes[9].Descriptor()
}

func (UsageSlice_LabelType) Type() protoreflect.EnumType {
	return &file_atom_proto_enumTypes[9]
}

func (x UsageSlice_LabelType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use UsageSlice_LabelType.Descriptor instead.
func (UsageSlice_LabelType) EnumDescriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{13, 0}
}

// Message to store the property values such as string or int values
type PropertyValue struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Value:
	//
	//	*PropertyValue_StringValue
	//	*PropertyValue_BoolValue
	//	*PropertyValue_IntValue
	//	*PropertyValue_LongValue
	//	*PropertyValue_FloatValue
	//	*PropertyValue_DoubleValue
	//	*PropertyValue_StringList
	//	*PropertyValue_BoolList
	//	*PropertyValue_IntList
	//	*PropertyValue_LongList
	//	*PropertyValue_FloatList
	//	*PropertyValue_DoubleList
	//	*PropertyValue_ContainedRefs
	Value         isPropertyValue_Value `protobuf_oneof:"value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PropertyValue) Reset() {
	*x = PropertyValue{}
	mi := &file_atom_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PropertyValue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PropertyValue) ProtoMessage() {}

func (x *PropertyValue) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PropertyValue.ProtoReflect.Descriptor instead.
func (*PropertyValue) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{0}
}

func (x *PropertyValue) GetValue() isPropertyValue_Value {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *PropertyValue) GetStringValue() string {
	if x != nil {
		if x, ok := x.Value.(*PropertyValue_StringValue); ok {
			return x.StringValue
		}
	}
	return ""
}

func (x *PropertyValue) GetBoolValue() bool {
	if x != nil {
		if x, ok := x.Value.(*PropertyValue_BoolValue); ok {
			return x.BoolValue
		}
	}
	return false
}

func (x *PropertyValue) GetIntValue() int32 {
	if x != nil {
		if x, ok := x.Value.(*PropertyValue_IntValue); ok {
			return x.IntValue
		}
	}
	return 0
}

func (x *PropertyValue) GetLongValue() int64 {
	if x != nil {
		if x, ok := x.Value.(*PropertyValue_LongValue); ok {
			return x.LongValue
		}
	}
	return 0
}

func (x *PropertyValue) GetFloatValue() float32 {
	if x != nil {
		if x, ok := x.Value.(*PropertyValue_FloatValue); ok {
			return x.FloatValue
		}
	}
	return 0
}

func (x *PropertyValue) GetDoubleValue() float64 {
	if x != nil {
		if x, ok := x.Value.(*PropertyValue_DoubleValue); ok {
			return x.DoubleValue
		}
	}
	return 0
}

func (x *PropertyValue) GetStringList() *StringList {
	if x != nil {
		if x, ok := x.Value.(*PropertyValue_StringList); ok {
			return x.StringList
		}
	}
	return nil
}

func (x *PropertyValue) GetBoolList() *BoolList {
	if x != nil {
		if x, ok := x.Value.(*PropertyValue_BoolList); ok {
			return x.BoolList
		}
	}
	return nil
}

func (x *PropertyValue) GetIntList() *IntList {
	if x != nil {
		if x, ok := x.Value.(*PropertyValue_IntList); ok {
			return x.IntList
		}
	}
	return nil
}

func (x *PropertyValue) GetLongList() *LongList {
	if x != nil {
		if x, ok := x.Value.(*PropertyValue_LongList); ok {
			return x.LongList
		}
	}
	return nil
}

func (x *PropertyValue) GetFloatList() *FloatList {
	if x != nil {
		if x, ok := x.Value.(*PropertyValue_FloatList); ok {
			return x.FloatList
		}
	}
	return nil
}

func (x *PropertyValue) GetDoubleList() *DoubleList {
	if x != nil {
		if x, ok := x.Value.(*PropertyValue_DoubleList); ok {
			return x.DoubleList
		}
	}
	return nil
}

func (x *PropertyValue) GetContainedRefs() *ContainedRefs {
	if x != nil {
		if x, ok := x.Value.(*PropertyValue_ContainedRefs); ok {
			return x.ContainedRefs
		}
	}
	return nil
}

type isPropertyValue_Value interface {
	isPropertyValue_Value()
}

type PropertyValue_StringValue struct {
	StringValue string `protobuf:"bytes,1,opt,name=string_value,json=stringValue,proto3,oneof"`
}

type PropertyValue_BoolValue struct {
	BoolValue bool `protobuf:"varint,2,opt,name=bool_value,json=boolValue,proto3,oneof"`
}

type PropertyValue_IntValue struct {
	IntValue int32 `protobuf:"varint,3,opt,name=int_value,json=intValue,proto3,oneof"`
}

type PropertyValue_LongValue struct {
	LongValue int64 `protobuf:"varint,4,opt,name=long_value,json=longValue,proto3,oneof"`
}

type PropertyValue_FloatValue struct {
	FloatValue float32 `protobuf:"fixed32,5,opt,name=float_value,json=floatValue,proto3,oneof"`
}

type PropertyValue_DoubleValue struct {
	DoubleValue float64 `protobuf:"fixed64,6,opt,name=double_value,json=doubleValue,proto3,oneof"`
}

type PropertyValue_StringList struct {
	StringList *StringList `protobuf:"bytes,7,opt,name=string_list,json=stringList,proto3,oneof"`
}

type PropertyValue_BoolList struct {
	BoolList *BoolList `protobuf:"bytes,8,opt,name=bool_list,json=boolList,proto3,oneof"`
}

type PropertyValue_IntList struct {
	IntList *IntList `protobuf:"bytes,9,opt,name=int_list,json=intList,proto3,oneof"`
}

type PropertyValue_LongList struct {
	LongList *LongList `protobuf:"bytes,10,opt,name=long_list,json=longList,proto3,oneof"`
}

type PropertyValue_FloatList struct {
	FloatList *FloatList `protobuf:"bytes,11,opt,name=float_list,json=floatList,proto3,oneof"`
}

type PropertyValue_DoubleList struct {
	DoubleList *DoubleList `protobuf:"bytes,12,opt,name=double_list,json=doubleList,proto3,oneof"`
}

type PropertyValue_ContainedRefs struct {
	ContainedRefs *ContainedRefs `protobuf:"bytes,13,opt,name=contained_refs,json=containedRefs,proto3,oneof"`
}

func (*PropertyValue_StringValue) isPropertyValue_Value() {}

func (*PropertyValue_BoolValue) isPropertyValue_Value() {}

func (*PropertyValue_IntValue) isPropertyValue_Value() {}

func (*PropertyValue_LongValue) isPropertyValue_Value() {}

func (*PropertyValue_FloatValue) isPropertyValue_Value() {}

func (*PropertyValue_DoubleValue) isPropertyValue_Value() {}

func (*PropertyValue_StringList) isPropertyValue_Value() {}

func (*PropertyValue_BoolList) isPropertyValue_Value() {}

func (*PropertyValue_IntList) isPropertyValue_Value() {}

func (*PropertyValue_LongList) isPropertyValue_Value() {}

func (*PropertyValue_FloatList) isPropertyValue_Value() {}

func (*PropertyValue_DoubleList) isPropertyValue_Value() {}

func (*PropertyValue_ContainedRefs) isPropertyValue_Value() {}

type ContainedRefs struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	LocalName     string                 `protobuf:"bytes,1,opt,name=local_name,json=localName,proto3" json:"local_name,omitempty"`
	Refs          []int64                `protobuf:"varint,2,rep,packed,name=refs,proto3" json:"refs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ContainedRefs) Reset() {
	*x = ContainedRefs{}
	mi := &file_atom_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ContainedRefs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContainedRefs) ProtoMessage() {}

func (x *ContainedRefs) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContainedRefs.ProtoReflect.Descriptor instead.
func (*ContainedRefs) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{1}
}

func (x *ContainedRefs) GetLocalName() string {
	if x != nil {
		return x.LocalName
	}
	return ""
}

func (x *ContainedRefs) GetRefs() []int64 {
	if x != nil {
		return x.Refs
	}
	return nil
}

type StringList struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Values        []string               `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StringList) Reset() {
	*x = StringList{}
	mi := &file_atom_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StringList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StringList) ProtoMessage() {}

func (x *StringList) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StringList.ProtoReflect.Descriptor instead.
func (*StringList) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{2}
}

func (x *StringList) GetValues() []string {
	if x != nil {
		return x.Values
	}
	return nil
}

type BoolList struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Values        []bool                 `protobuf:"varint,1,rep,packed,name=values,proto3" json:"values,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BoolList) Reset() {
	*x = BoolList{}
	mi := &file_atom_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BoolList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BoolList) ProtoMessage() {}

func (x *BoolList) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BoolList.ProtoReflect.Descriptor instead.
func (*BoolList) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{3}
}

func (x *BoolList) GetValues() []bool {
	if x != nil {
		return x.Values
	}
	return nil
}

type IntList struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Values        []int32                `protobuf:"varint,1,rep,packed,name=values,proto3" json:"values,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IntList) Reset() {
	*x = IntList{}
	mi := &file_atom_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IntList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IntList) ProtoMessage() {}

func (x *IntList) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IntList.ProtoReflect.Descriptor instead.
func (*IntList) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{4}
}

func (x *IntList) GetValues() []int32 {
	if x != nil {
		return x.Values
	}
	return nil
}

type LongList struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Values        []int64                `protobuf:"varint,1,rep,packed,name=values,proto3" json:"values,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LongList) Reset() {
	*x = LongList{}
	mi := &file_atom_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LongList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LongList) ProtoMessage() {}

func (x *LongList) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LongList.ProtoReflect.Descriptor instead.
func (*LongList) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{5}
}

func (x *LongList) GetValues() []int64 {
	if x != nil {
		return x.Values
	}
	return nil
}

type FloatList struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Values        []float32              `protobuf:"fixed32,1,rep,packed,name=values,proto3" json:"values,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FloatList) Reset() {
	*x = FloatList{}
	mi := &file_atom_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FloatList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FloatList) ProtoMessage() {}

func (x *FloatList) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FloatList.ProtoReflect.Descriptor instead.
func (*FloatList) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{6}
}

func (x *FloatList) GetValues() []float32 {
	if x != nil {
		return x.Values
	}
	return nil
}

type DoubleList struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Values        []float64              `protobuf:"fixed64,1,rep,packed,name=values,proto3" json:"values,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DoubleList) Reset() {
	*x = DoubleList{}
	mi := &file_atom_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DoubleList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DoubleList) ProtoMessage() {}

func (x *DoubleList) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DoubleList.ProtoReflect.Descriptor instead.
func (*DoubleList) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{7}
}

func (x *DoubleList) GetValues() []float64 {
	if x != nil {
		return x.Values
	}
	return nil
}

// *
// This is the CORE structure that represents a Code Property Graph for the given language
// This structure must be serialized as bytes and stored in a zip file (such as app.atom) with the name "cpg.proto"
//
// Example code snippet in Python
// ```python
// atom_struct = atom.CpgStruct(node=[method])
// with ZipFile(file_name, "w") as zip_file:
//
//	zip_file.writestr("cpg.proto", bytes(atom_struct))
//
// ```
//
// Example code snippet in TypeScript
// ```typescript
//
//	const methodFullName = new atom.CpgStruct.Node.Property({
//	 name: atom.NodePropertyName.FULL_NAME,
//	 value: new atom.PropertyValue({ string_value: "main" }),
//	});
//
//	const method = new atom.CpgStruct.Node({
//	  key: 1,
//	  type: atom.NodeType.METHOD,
//	  property: [methodFullName],
//	});
//
// const atomStruct = new atom.CpgStruct({ node: [method] });
// const serializedBytes = atomStruct.serialize();
// ```
type CpgStruct struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Node          []*CpgStruct_Node      `protobuf:"bytes,1,rep,name=node,proto3" json:"node,omitempty"`
	Edge          []*CpgStruct_Edge      `protobuf:"bytes,2,rep,name=edge,proto3" json:"edge,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CpgStruct) Reset() {
	*x = CpgStruct{}
	mi := &file_atom_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CpgStruct) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CpgStruct) ProtoMessage() {}

func (x *CpgStruct) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CpgStruct.ProtoReflect.Descriptor instead.
func (*CpgStruct) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{8}
}

func (x *CpgStruct) GetNode() []*CpgStruct_Node {
	if x != nil {
		return x.Node
	}
	return nil
}

func (x *CpgStruct) GetEdge() []*CpgStruct_Edge {
	if x != nil {
		return x.Edge
	}
	return nil
}

type AdditionalNodeProperty struct {
	state         protoimpl.MessageState   `protogen:"open.v1"`
	NodeId        int64                    `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Property      *CpgStruct_Node_Property `protobuf:"bytes,2,opt,name=property,proto3" json:"property,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AdditionalNodeProperty) Reset() {
	*x = AdditionalNodeProperty{}
	mi := &file_atom_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AdditionalNodeProperty) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AdditionalNodeProperty) ProtoMessage() {}

func (x *AdditionalNodeProperty) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AdditionalNodeProperty.ProtoReflect.Descriptor instead.
func (*AdditionalNodeProperty) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{9}
}

func (x *AdditionalNodeProperty) GetNodeId() int64 {
	if x != nil {
		return x.NodeId
	}
	return 0
}

func (x *AdditionalNodeProperty) GetProperty() *CpgStruct_Node_Property {
	if x != nil {
		return x.Property
	}
	return nil
}

type AdditionalEdgeProperty struct {
	state         protoimpl.MessageState   `protogen:"open.v1"`
	EdgeId        int64                    `protobuf:"varint,1,opt,name=edge_id,json=edgeId,proto3" json:"edge_id,omitempty"`
	Property      *CpgStruct_Edge_Property `protobuf:"bytes,2,opt,name=property,proto3" json:"property,omitempty"`
	OutNodeKey    int64                    `protobuf:"varint,3,opt,name=out_node_key,json=outNodeKey,proto3" json:"out_node_key,omitempty"`
	InNodeKey     int64                    `protobuf:"varint,4,opt,name=in_node_key,json=inNodeKey,proto3" json:"in_node_key,omitempty"`
	EdgeType      CpgStruct_Edge_EdgeType  `protobuf:"varint,5,opt,name=edge_type,json=edgeType,proto3,enum=atom.CpgStruct_Edge_EdgeType" json:"edge_type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AdditionalEdgeProperty) Reset() {
	*x = AdditionalEdgeProperty{}
	mi := &file_atom_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AdditionalEdgeProperty) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AdditionalEdgeProperty) ProtoMessage() {}

func (x *AdditionalEdgeProperty) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AdditionalEdgeProperty.ProtoReflect.Descriptor instead.
func (*AdditionalEdgeProperty) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{10}
}

func (x *AdditionalEdgeProperty) GetEdgeId() int64 {
	if x != nil {
		return x.EdgeId
	}
	return 0
}

func (x *AdditionalEdgeProperty) GetProperty() *CpgStruct_Edge_Property {
	if x != nil {
		return x.Property
	}
	return nil
}

func (x *AdditionalEdgeProperty) GetOutNodeKey() int64 {
	if x != nil {
		return x.OutNodeKey
	}
	return 0
}

func (x *AdditionalEdgeProperty) GetInNodeKey() int64 {
	if x != nil {
		return x.InNodeKey
	}
	return 0
}

func (x *AdditionalEdgeProperty) GetEdgeType() CpgStruct_Edge_EdgeType {
	if x != nil {
		return x.EdgeType
	}
	return CpgStruct_Edge_UNKNOWN_EDGE_TYPE
}

// Overlays can be stacked onto each other, therefor their node ids must be globally unique.
type CpgOverlay struct {
	state         protoimpl.MessageState    `protogen:"open.v1"`
	Node          []*CpgStruct_Node         `protobuf:"bytes,1,rep,name=node,proto3" json:"node,omitempty"`
	Edge          []*CpgStruct_Edge         `protobuf:"bytes,2,rep,name=edge,proto3" json:"edge,omitempty"`
	NodeProperty  []*AdditionalNodeProperty `protobuf:"bytes,3,rep,name=node_property,json=nodeProperty,proto3" json:"node_property,omitempty"`
	EdgeProperty  []*AdditionalEdgeProperty `protobuf:"bytes,4,rep,name=edge_property,json=edgeProperty,proto3" json:"edge_property,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CpgOverlay) Reset() {
	*x = CpgOverlay{}
	mi := &file_atom_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CpgOverlay) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CpgOverlay) ProtoMessage() {}

func (x *CpgOverlay) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CpgOverlay.ProtoReflect.Descriptor instead.
func (*CpgOverlay) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{11}
}

func (x *CpgOverlay) GetNode() []*CpgStruct_Node {
	if x != nil {
		return x.Node
	}
	return nil
}

func (x *CpgOverlay) GetEdge() []*CpgStruct_Edge {
	if x != nil {
		return x.Edge
	}
	return nil
}

func (x *CpgOverlay) GetNodeProperty() []*AdditionalNodeProperty {
	if x != nil {
		return x.NodeProperty
	}
	return nil
}

func (x *CpgOverlay) GetEdgeProperty() []*AdditionalEdgeProperty {
	if x != nil {
		return x.EdgeProperty
	}
	return nil
}

// DiffGraphs can be created independently of each other and therefor when _adding_ nodes|edges,
// each DiffGraph has its own ID space. However, when removing nodes|edges, the nodeIds refer to the
// globally unique graph id space.
type DiffGraph struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Entries       []*DiffGraph_Entry     `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DiffGraph) Reset() {
	*x = DiffGraph{}
	mi := &file_atom_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DiffGraph) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DiffGraph) ProtoMessage() {}

func (x *DiffGraph) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DiffGraph.ProtoReflect.Descriptor instead.
func (*DiffGraph) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{12}
}

func (x *DiffGraph) GetEntries() []*DiffGraph_Entry {
	if x != nil {
		return x.Entries
	}
	return nil
}

// *
// The usages slice describes how a variable interacts within its procedure. This is perhaps a more "descriptive" slice in some ways. The variables are locals and parameters and the referencing identifiers are tracked to find what the variable calls and what calls it forms an argument of.
// There are two lists. There is a list of MethodUsageSlice with key "objectSlices" and a list of UserDefinedTypes with key "userDefinedTypes"
//
// ![Usage slices overview](./docs/Library%20Usages.png)
type UsageSlice struct {
	state            protoimpl.MessageState         `protogen:"open.v1"`
	ObjectSlices     []*UsageSlice_MethodUsageSlice `protobuf:"bytes,1,rep,name=objectSlices,proto3" json:"objectSlices,omitempty"`
	UserDefinedTypes []*UsageSlice_UserDefinedTypes `protobuf:"bytes,2,rep,name=userDefinedTypes,proto3" json:"userDefinedTypes,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *UsageSlice) Reset() {
	*x = UsageSlice{}
	mi := &file_atom_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UsageSlice) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UsageSlice) ProtoMessage() {}

func (x *UsageSlice) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UsageSlice.ProtoReflect.Descriptor instead.
func (*UsageSlice) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{13}
}

func (x *UsageSlice) GetObjectSlices() []*UsageSlice_MethodUsageSlice {
	if x != nil {
		return x.ObjectSlices
	}
	return nil
}

func (x *UsageSlice) GetUserDefinedTypes() []*UsageSlice_UserDefinedTypes {
	if x != nil {
		return x.UserDefinedTypes
	}
	return nil
}

type Nodes struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Id of the node
	Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Label
	Label NodeType `protobuf:"varint,2,opt,name=label,proto3,enum=atom.NodeType" json:"label,omitempty"`
	// Name of the call or identifier or parameter
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// Full name of the call
	FullName string `protobuf:"bytes,4,opt,name=fullName,proto3" json:"fullName,omitempty"`
	// Method signature of the call
	Signature string `protobuf:"bytes,5,opt,name=signature,proto3" json:"signature,omitempty"`
	// Boolean to indicate if this call belongs to an external method
	IsExternal bool `protobuf:"varint,6,opt,name=isExternal,proto3" json:"isExternal,omitempty"`
	// Source code
	Code string `protobuf:"bytes,7,opt,name=code,proto3" json:"code,omitempty"`
	// Type full name
	TypeFullName string `protobuf:"bytes,8,opt,name=typeFullName,proto3" json:"typeFullName,omitempty"`
	// Parent method name
	ParentMethodName string `protobuf:"bytes,9,opt,name=parentMethodName,proto3" json:"parentMethodName,omitempty"`
	// Parent method signature
	ParentMethodSignature string `protobuf:"bytes,10,opt,name=parentMethodSignature,proto3" json:"parentMethodSignature,omitempty"`
	// Parent filename
	ParentFileName string `protobuf:"bytes,11,opt,name=parentFileName,proto3" json:"parentFileName,omitempty"`
	// Parent package name
	ParentPackageName string `protobuf:"bytes,12,opt,name=parentPackageName,proto3" json:"parentPackageName,omitempty"`
	// Parent class name
	ParentClassName string `protobuf:"bytes,13,opt,name=parentClassName,proto3" json:"parentClassName,omitempty"`
	// Line number
	LineNumber uint32 `protobuf:"varint,14,opt,name=lineNumber,proto3" json:"lineNumber,omitempty"`
	// Column number
	ColumnNumber uint32 `protobuf:"varint,15,opt,name=columnNumber,proto3" json:"columnNumber,omitempty"`
	// Tags. Can contain simple names including package url
	Tags          string `protobuf:"bytes,16,opt,name=tags,proto3" json:"tags,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Nodes) Reset() {
	*x = Nodes{}
	mi := &file_atom_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Nodes) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Nodes) ProtoMessage() {}

func (x *Nodes) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Nodes.ProtoReflect.Descriptor instead.
func (*Nodes) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{14}
}

func (x *Nodes) GetId() uint32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *Nodes) GetLabel() NodeType {
	if x != nil {
		return x.Label
	}
	return NodeType_UNKNOWN_NODE_TYPE
}

func (x *Nodes) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Nodes) GetFullName() string {
	if x != nil {
		return x.FullName
	}
	return ""
}

func (x *Nodes) GetSignature() string {
	if x != nil {
		return x.Signature
	}
	return ""
}

func (x *Nodes) GetIsExternal() bool {
	if x != nil {
		return x.IsExternal
	}
	return false
}

func (x *Nodes) GetCode() string {
	if x != nil {
		return x.Code
	}
	return ""
}

func (x *Nodes) GetTypeFullName() string {
	if x != nil {
		return x.TypeFullName
	}
	return ""
}

func (x *Nodes) GetParentMethodName() string {
	if x != nil {
		return x.ParentMethodName
	}
	return ""
}

func (x *Nodes) GetParentMethodSignature() string {
	if x != nil {
		return x.ParentMethodSignature
	}
	return ""
}

func (x *Nodes) GetParentFileName() string {
	if x != nil {
		return x.ParentFileName
	}
	return ""
}

func (x *Nodes) GetParentPackageName() string {
	if x != nil {
		return x.ParentPackageName
	}
	return ""
}

func (x *Nodes) GetParentClassName() string {
	if x != nil {
		return x.ParentClassName
	}
	return ""
}

func (x *Nodes) GetLineNumber() uint32 {
	if x != nil {
		return x.LineNumber
	}
	return 0
}

func (x *Nodes) GetColumnNumber() uint32 {
	if x != nil {
		return x.ColumnNumber
	}
	return 0
}

func (x *Nodes) GetTags() string {
	if x != nil {
		return x.Tags
	}
	return ""
}

// *
// DataFlow slices offers a list of nodes and edges exported from data dependency graph
//
// ![Data Flow slices overview](./docs/Data%20Flows.png)
type DataFlowSlice struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Graph         *DataFlowSlice_Graph   `protobuf:"bytes,1,opt,name=graph,proto3" json:"graph,omitempty"`
	Path          *DataFlowSlice_Paths   `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DataFlowSlice) Reset() {
	*x = DataFlowSlice{}
	mi := &file_atom_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DataFlowSlice) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DataFlowSlice) ProtoMessage() {}

func (x *DataFlowSlice) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DataFlowSlice.ProtoReflect.Descriptor instead.
func (*DataFlowSlice) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{15}
}

func (x *DataFlowSlice) GetGraph() *DataFlowSlice_Graph {
	if x != nil {
		return x.Graph
	}
	return nil
}

func (x *DataFlowSlice) GetPath() *DataFlowSlice_Paths {
	if x != nil {
		return x.Path
	}
	return nil
}

// *
// Reachables slices offers a list of reachable nodes based on automated tags exported from data dependency graph
type ReachableSlice struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Flows         []*Nodes               `protobuf:"bytes,1,rep,name=flows,proto3" json:"flows,omitempty"`
	Purls         []string               `protobuf:"bytes,2,rep,name=purls,proto3" json:"purls,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReachableSlice) Reset() {
	*x = ReachableSlice{}
	mi := &file_atom_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReachableSlice) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReachableSlice) ProtoMessage() {}

func (x *ReachableSlice) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReachableSlice.ProtoReflect.Descriptor instead.
func (*ReachableSlice) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{16}
}

func (x *ReachableSlice) GetFlows() []*Nodes {
	if x != nil {
		return x.Flows
	}
	return nil
}

func (x *ReachableSlice) GetPurls() []string {
	if x != nil {
		return x.Purls
	}
	return nil
}

type ReachableSliceList struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Slices        []*ReachableSlice      `protobuf:"bytes,1,rep,name=slices,proto3" json:"slices,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReachableSliceList) Reset() {
	*x = ReachableSliceList{}
	mi := &file_atom_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReachableSliceList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReachableSliceList) ProtoMessage() {}

func (x *ReachableSliceList) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReachableSliceList.ProtoReflect.Descriptor instead.
func (*ReachableSliceList) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{17}
}

func (x *ReachableSliceList) GetSlices() []*ReachableSlice {
	if x != nil {
		return x.Slices
	}
	return nil
}

type CpgStruct_Node struct {
	state         protoimpl.MessageState     `protogen:"open.v1"`
	Key           int64                      `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	Type          NodeType                   `protobuf:"varint,2,opt,name=type,proto3,enum=atom.NodeType" json:"type,omitempty"`
	Property      []*CpgStruct_Node_Property `protobuf:"bytes,3,rep,name=property,proto3" json:"property,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CpgStruct_Node) Reset() {
	*x = CpgStruct_Node{}
	mi := &file_atom_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CpgStruct_Node) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CpgStruct_Node) ProtoMessage() {}

func (x *CpgStruct_Node) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CpgStruct_Node.ProtoReflect.Descriptor instead.
func (*CpgStruct_Node) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{8, 0}
}

func (x *CpgStruct_Node) GetKey() int64 {
	if x != nil {
		return x.Key
	}
	return 0
}

func (x *CpgStruct_Node) GetType() NodeType {
	if x != nil {
		return x.Type
	}
	return NodeType_UNKNOWN_NODE_TYPE
}

func (x *CpgStruct_Node) GetProperty() []*CpgStruct_Node_Property {
	if x != nil {
		return x.Property
	}
	return nil
}

// Represents a directed edge of a graph
type CpgStruct_Edge struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Source node.
	Src int64 `protobuf:"varint,1,opt,name=src,proto3" json:"src,omitempty"`
	// Destination node.
	Dst           int64                      `protobuf:"varint,2,opt,name=dst,proto3" json:"dst,omitempty"`
	Type          CpgStruct_Edge_EdgeType    `protobuf:"varint,3,opt,name=type,proto3,enum=atom.CpgStruct_Edge_EdgeType" json:"type,omitempty"`
	Property      []*CpgStruct_Edge_Property `protobuf:"bytes,4,rep,name=property,proto3" json:"property,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CpgStruct_Edge) Reset() {
	*x = CpgStruct_Edge{}
	mi := &file_atom_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CpgStruct_Edge) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CpgStruct_Edge) ProtoMessage() {}

func (x *CpgStruct_Edge) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CpgStruct_Edge.ProtoReflect.Descriptor instead.
func (*CpgStruct_Edge) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{8, 1}
}

func (x *CpgStruct_Edge) GetSrc() int64 {
	if x != nil {
		return x.Src
	}
	return 0
}

func (x *CpgStruct_Edge) GetDst() int64 {
	if x != nil {
		return x.Dst
	}
	return 0
}

func (x *CpgStruct_Edge) GetType() CpgStruct_Edge_EdgeType {
	if x != nil {
		return x.Type
	}
	return CpgStruct_Edge_UNKNOWN_EDGE_TYPE
}

func (x *CpgStruct_Edge) GetProperty() []*CpgStruct_Edge_Property {
	if x != nil {
		return x.Property
	}
	return nil
}

// Node properties.
type CpgStruct_Node_Property struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          NodePropertyName       `protobuf:"varint,1,opt,name=name,proto3,enum=atom.NodePropertyName" json:"name,omitempty"`
	Value         *PropertyValue         `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CpgStruct_Node_Property) Reset() {
	*x = CpgStruct_Node_Property{}
	mi := &file_atom_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CpgStruct_Node_Property) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CpgStruct_Node_Property) ProtoMessage() {}

func (x *CpgStruct_Node_Property) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CpgStruct_Node_Property.ProtoReflect.Descriptor instead.
func (*CpgStruct_Node_Property) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{8, 0, 0}
}

func (x *CpgStruct_Node_Property) GetName() NodePropertyName {
	if x != nil {
		return x.Name
	}
	return NodePropertyName_UNKNOWN_NODE_PROPERTY
}

func (x *CpgStruct_Node_Property) GetValue() *PropertyValue {
	if x != nil {
		return x.Value
	}
	return nil
}

// Edge properties.
type CpgStruct_Edge_Property struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          EdgePropertyName       `protobuf:"varint,1,opt,name=name,proto3,enum=atom.EdgePropertyName" json:"name,omitempty"`
	Value         *PropertyValue         `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CpgStruct_Edge_Property) Reset() {
	*x = CpgStruct_Edge_Property{}
	mi := &file_atom_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CpgStruct_Edge_Property) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CpgStruct_Edge_Property) ProtoMessage() {}

func (x *CpgStruct_Edge_Property) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CpgStruct_Edge_Property.ProtoReflect.Descriptor instead.
func (*CpgStruct_Edge_Property) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{8, 1, 0}
}

func (x *CpgStruct_Edge_Property) GetName() EdgePropertyName {
	if x != nil {
		return x.Name
	}
	return EdgePropertyName_UNKNOWN_EDGE_PROPERTY
}

func (x *CpgStruct_Edge_Property) GetValue() *PropertyValue {
	if x != nil {
		return x.Value
	}
	return nil
}

type DiffGraph_RemoveNode struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Key           int64                  `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DiffGraph_RemoveNode) Reset() {
	*x = DiffGraph_RemoveNode{}
	mi := &file_atom_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DiffGraph_RemoveNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DiffGraph_RemoveNode) ProtoMessage() {}

func (x *DiffGraph_RemoveNode) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DiffGraph_RemoveNode.ProtoReflect.Descriptor instead.
func (*DiffGraph_RemoveNode) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{12, 0}
}

func (x *DiffGraph_RemoveNode) GetKey() int64 {
	if x != nil {
		return x.Key
	}
	return 0
}

type DiffGraph_RemoveNodeProperty struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Key           int64                  `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	Name          NodePropertyName       `protobuf:"varint,2,opt,name=name,proto3,enum=atom.NodePropertyName" json:"name,omitempty"`
	LocalName     string                 `protobuf:"bytes,3,opt,name=local_name,json=localName,proto3" json:"local_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DiffGraph_RemoveNodeProperty) Reset() {
	*x = DiffGraph_RemoveNodeProperty{}
	mi := &file_atom_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DiffGraph_RemoveNodeProperty) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DiffGraph_RemoveNodeProperty) ProtoMessage() {}

func (x *DiffGraph_RemoveNodeProperty) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DiffGraph_RemoveNodeProperty.ProtoReflect.Descriptor instead.
func (*DiffGraph_RemoveNodeProperty) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{12, 1}
}

func (x *DiffGraph_RemoveNodeProperty) GetKey() int64 {
	if x != nil {
		return x.Key
	}
	return 0
}

func (x *DiffGraph_RemoveNodeProperty) GetName() NodePropertyName {
	if x != nil {
		return x.Name
	}
	return NodePropertyName_UNKNOWN_NODE_PROPERTY
}

func (x *DiffGraph_RemoveNodeProperty) GetLocalName() string {
	if x != nil {
		return x.LocalName
	}
	return ""
}

type DiffGraph_RemoveEdge struct {
	state          protoimpl.MessageState  `protogen:"open.v1"`
	OutNodeKey     int64                   `protobuf:"varint,1,opt,name=out_node_key,json=outNodeKey,proto3" json:"out_node_key,omitempty"`
	InNodeKey      int64                   `protobuf:"varint,2,opt,name=in_node_key,json=inNodeKey,proto3" json:"in_node_key,omitempty"`
	EdgeType       CpgStruct_Edge_EdgeType `protobuf:"varint,3,opt,name=edge_type,json=edgeType,proto3,enum=atom.CpgStruct_Edge_EdgeType" json:"edge_type,omitempty"`
	PropertiesHash []byte                  `protobuf:"bytes,4,opt,name=propertiesHash,proto3" json:"propertiesHash,omitempty"` // used to identify edges (since our edges don't have ids)
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *DiffGraph_RemoveEdge) Reset() {
	*x = DiffGraph_RemoveEdge{}
	mi := &file_atom_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DiffGraph_RemoveEdge) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DiffGraph_RemoveEdge) ProtoMessage() {}

func (x *DiffGraph_RemoveEdge) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DiffGraph_RemoveEdge.ProtoReflect.Descriptor instead.
func (*DiffGraph_RemoveEdge) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{12, 2}
}

func (x *DiffGraph_RemoveEdge) GetOutNodeKey() int64 {
	if x != nil {
		return x.OutNodeKey
	}
	return 0
}

func (x *DiffGraph_RemoveEdge) GetInNodeKey() int64 {
	if x != nil {
		return x.InNodeKey
	}
	return 0
}

func (x *DiffGraph_RemoveEdge) GetEdgeType() CpgStruct_Edge_EdgeType {
	if x != nil {
		return x.EdgeType
	}
	return CpgStruct_Edge_UNKNOWN_EDGE_TYPE
}

func (x *DiffGraph_RemoveEdge) GetPropertiesHash() []byte {
	if x != nil {
		return x.PropertiesHash
	}
	return nil
}

type DiffGraph_RemoveEdgeProperty struct {
	state          protoimpl.MessageState  `protogen:"open.v1"`
	OutNodeKey     int64                   `protobuf:"varint,1,opt,name=out_node_key,json=outNodeKey,proto3" json:"out_node_key,omitempty"`
	InNodeKey      int64                   `protobuf:"varint,2,opt,name=in_node_key,json=inNodeKey,proto3" json:"in_node_key,omitempty"`
	EdgeType       CpgStruct_Edge_EdgeType `protobuf:"varint,3,opt,name=edge_type,json=edgeType,proto3,enum=atom.CpgStruct_Edge_EdgeType" json:"edge_type,omitempty"`
	PropertiesHash []byte                  `protobuf:"bytes,4,opt,name=propertiesHash,proto3" json:"propertiesHash,omitempty"` // used to identify edges (since our edges don't have ids)
	PropertyName   EdgePropertyName        `protobuf:"varint,5,opt,name=property_name,json=propertyName,proto3,enum=atom.EdgePropertyName" json:"property_name,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *DiffGraph_RemoveEdgeProperty) Reset() {
	*x = DiffGraph_RemoveEdgeProperty{}
	mi := &file_atom_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DiffGraph_RemoveEdgeProperty) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DiffGraph_RemoveEdgeProperty) ProtoMessage() {}

func (x *DiffGraph_RemoveEdgeProperty) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DiffGraph_RemoveEdgeProperty.ProtoReflect.Descriptor instead.
func (*DiffGraph_RemoveEdgeProperty) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{12, 3}
}

func (x *DiffGraph_RemoveEdgeProperty) GetOutNodeKey() int64 {
	if x != nil {
		return x.OutNodeKey
	}
	return 0
}

func (x *DiffGraph_RemoveEdgeProperty) GetInNodeKey() int64 {
	if x != nil {
		return x.InNodeKey
	}
	return 0
}

func (x *DiffGraph_RemoveEdgeProperty) GetEdgeType() CpgStruct_Edge_EdgeType {
	if x != nil {
		return x.EdgeType
	}
	return CpgStruct_Edge_UNKNOWN_EDGE_TYPE
}

func (x *DiffGraph_RemoveEdgeProperty) GetPropertiesHash() []byte {
	if x != nil {
		return x.PropertiesHash
	}
	return nil
}

func (x *DiffGraph_RemoveEdgeProperty) GetPropertyName() EdgePropertyName {
	if x != nil {
		return x.PropertyName
	}
	return EdgePropertyName_UNKNOWN_EDGE_PROPERTY
}

type DiffGraph_Entry struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Value:
	//
	//	*DiffGraph_Entry_Node
	//	*DiffGraph_Entry_Edge
	//	*DiffGraph_Entry_NodeProperty
	//	*DiffGraph_Entry_EdgeProperty
	//	*DiffGraph_Entry_RemoveNode
	//	*DiffGraph_Entry_RemoveNodeProperty
	//	*DiffGraph_Entry_RemoveEdge
	//	*DiffGraph_Entry_RemoveEdgeProperty
	Value         isDiffGraph_Entry_Value `protobuf_oneof:"value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DiffGraph_Entry) Reset() {
	*x = DiffGraph_Entry{}
	mi := &file_atom_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DiffGraph_Entry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DiffGraph_Entry) ProtoMessage() {}

func (x *DiffGraph_Entry) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DiffGraph_Entry.ProtoReflect.Descriptor instead.
func (*DiffGraph_Entry) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{12, 4}
}

func (x *DiffGraph_Entry) GetValue() isDiffGraph_Entry_Value {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *DiffGraph_Entry) GetNode() *CpgStruct_Node {
	if x != nil {
		if x, ok := x.Value.(*DiffGraph_Entry_Node); ok {
			return x.Node
		}
	}
	return nil
}

func (x *DiffGraph_Entry) GetEdge() *CpgStruct_Edge {
	if x != nil {
		if x, ok := x.Value.(*DiffGraph_Entry_Edge); ok {
			return x.Edge
		}
	}
	return nil
}

func (x *DiffGraph_Entry) GetNodeProperty() *AdditionalNodeProperty {
	if x != nil {
		if x, ok := x.Value.(*DiffGraph_Entry_NodeProperty); ok {
			return x.NodeProperty
		}
	}
	return nil
}

func (x *DiffGraph_Entry) GetEdgeProperty() *AdditionalEdgeProperty {
	if x != nil {
		if x, ok := x.Value.(*DiffGraph_Entry_EdgeProperty); ok {
			return x.EdgeProperty
		}
	}
	return nil
}

func (x *DiffGraph_Entry) GetRemoveNode() *DiffGraph_RemoveNode {
	if x != nil {
		if x, ok := x.Value.(*DiffGraph_Entry_RemoveNode); ok {
			return x.RemoveNode
		}
	}
	return nil
}

func (x *DiffGraph_Entry) GetRemoveNodeProperty() *DiffGraph_RemoveNodeProperty {
	if x != nil {
		if x, ok := x.Value.(*DiffGraph_Entry_RemoveNodeProperty); ok {
			return x.RemoveNodeProperty
		}
	}
	return nil
}

func (x *DiffGraph_Entry) GetRemoveEdge() *DiffGraph_RemoveEdge {
	if x != nil {
		if x, ok := x.Value.(*DiffGraph_Entry_RemoveEdge); ok {
			return x.RemoveEdge
		}
	}
	return nil
}

func (x *DiffGraph_Entry) GetRemoveEdgeProperty() *DiffGraph_RemoveEdgeProperty {
	if x != nil {
		if x, ok := x.Value.(*DiffGraph_Entry_RemoveEdgeProperty); ok {
			return x.RemoveEdgeProperty
		}
	}
	return nil
}

type isDiffGraph_Entry_Value interface {
	isDiffGraph_Entry_Value()
}

type DiffGraph_Entry_Node struct {
	Node *CpgStruct_Node `protobuf:"bytes,1,opt,name=node,proto3,oneof"`
}

type DiffGraph_Entry_Edge struct {
	Edge *CpgStruct_Edge `protobuf:"bytes,2,opt,name=edge,proto3,oneof"`
}

type DiffGraph_Entry_NodeProperty struct {
	NodeProperty *AdditionalNodeProperty `protobuf:"bytes,3,opt,name=node_property,json=nodeProperty,proto3,oneof"`
}

type DiffGraph_Entry_EdgeProperty struct {
	EdgeProperty *AdditionalEdgeProperty `protobuf:"bytes,4,opt,name=edge_property,json=edgeProperty,proto3,oneof"`
}

type DiffGraph_Entry_RemoveNode struct {
	RemoveNode *DiffGraph_RemoveNode `protobuf:"bytes,5,opt,name=remove_node,json=removeNode,proto3,oneof"`
}

type DiffGraph_Entry_RemoveNodeProperty struct {
	RemoveNodeProperty *DiffGraph_RemoveNodeProperty `protobuf:"bytes,6,opt,name=remove_node_property,json=removeNodeProperty,proto3,oneof"`
}

type DiffGraph_Entry_RemoveEdge struct {
	RemoveEdge *DiffGraph_RemoveEdge `protobuf:"bytes,7,opt,name=remove_edge,json=removeEdge,proto3,oneof"`
}

type DiffGraph_Entry_RemoveEdgeProperty struct {
	RemoveEdgeProperty *DiffGraph_RemoveEdgeProperty `protobuf:"bytes,8,opt,name=remove_edge_property,json=removeEdgeProperty,proto3,oneof"`
}

func (*DiffGraph_Entry_Node) isDiffGraph_Entry_Value() {}

func (*DiffGraph_Entry_Edge) isDiffGraph_Entry_Value() {}

func (*DiffGraph_Entry_NodeProperty) isDiffGraph_Entry_Value() {}

func (*DiffGraph_Entry_EdgeProperty) isDiffGraph_Entry_Value() {}

func (*DiffGraph_Entry_RemoveNode) isDiffGraph_Entry_Value() {}

func (*DiffGraph_Entry_RemoveNodeProperty) isDiffGraph_Entry_Value() {}

func (*DiffGraph_Entry_RemoveEdge) isDiffGraph_Entry_Value() {}

func (*DiffGraph_Entry_RemoveEdgeProperty) isDiffGraph_Entry_Value() {}

// Represents a source of data-generation, i.e., where data is defined and can be assigned to some variable or used in an argument.
type UsageSlice_TargetObj struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// variable or parameter name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Fullname of the data type
	TypeFullName string `protobuf:"bytes,2,opt,name=typeFullName,proto3" json:"typeFullName,omitempty"`
	// Position of the parameter or argument
	Position uint32 `protobuf:"varint,3,opt,name=position,proto3" json:"position,omitempty"`
	// Boolean to indicate if the call belongs to an external method. label=CALL
	IsExternal bool `protobuf:"varint,4,opt,name=isExternal,proto3" json:"isExternal,omitempty"`
	// Line number in the file
	LineNumber uint32 `protobuf:"varint,5,opt,name=lineNumber,proto3" json:"lineNumber,omitempty"`
	// Column number
	ColumnNumber  uint32               `protobuf:"varint,6,opt,name=columnNumber,proto3" json:"columnNumber,omitempty"`
	Label         UsageSlice_LabelType `protobuf:"varint,7,opt,name=label,proto3,enum=atom.UsageSlice_LabelType" json:"label,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UsageSlice_TargetObj) Reset() {
	*x = UsageSlice_TargetObj{}
	mi := &file_atom_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UsageSlice_TargetObj) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UsageSlice_TargetObj) ProtoMessage() {}

func (x *UsageSlice_TargetObj) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UsageSlice_TargetObj.ProtoReflect.Descriptor instead.
func (*UsageSlice_TargetObj) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{13, 0}
}

func (x *UsageSlice_TargetObj) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *UsageSlice_TargetObj) GetTypeFullName() string {
	if x != nil {
		return x.TypeFullName
	}
	return ""
}

func (x *UsageSlice_TargetObj) GetPosition() uint32 {
	if x != nil {
		return x.Position
	}
	return 0
}

func (x *UsageSlice_TargetObj) GetIsExternal() bool {
	if x != nil {
		return x.IsExternal
	}
	return false
}

func (x *UsageSlice_TargetObj) GetLineNumber() uint32 {
	if x != nil {
		return x.LineNumber
	}
	return 0
}

func (x *UsageSlice_TargetObj) GetColumnNumber() uint32 {
	if x != nil {
		return x.ColumnNumber
	}
	return 0
}

func (x *UsageSlice_TargetObj) GetLabel() UsageSlice_LabelType {
	if x != nil {
		return x.Label
	}
	return UsageSlice_ANY
}

// Places where the given symbol is defined
type UsageSlice_DefinedBy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// variable or parameter name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Fullname of the data type
	TypeFullName string `protobuf:"bytes,2,opt,name=typeFullName,proto3" json:"typeFullName,omitempty"`
	// Method name
	ResolvedMethod string `protobuf:"bytes,3,opt,name=resolvedMethod,proto3" json:"resolvedMethod,omitempty"`
	// Position
	Position uint32 `protobuf:"varint,4,opt,name=position,proto3" json:"position,omitempty"`
	// Boolean to indicate if the call belongs to an external method. label=CALL
	IsExternal bool `protobuf:"varint,5,opt,name=isExternal,proto3" json:"isExternal,omitempty"`
	// Line number
	LineNumber uint32 `protobuf:"varint,6,opt,name=lineNumber,proto3" json:"lineNumber,omitempty"`
	// Column number
	ColumnNumber uint32 `protobuf:"varint,7,opt,name=columnNumber,proto3" json:"columnNumber,omitempty"`
	// Label describing the resolved method or position
	Label         string `protobuf:"bytes,8,opt,name=label,proto3" json:"label,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UsageSlice_DefinedBy) Reset() {
	*x = UsageSlice_DefinedBy{}
	mi := &file_atom_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UsageSlice_DefinedBy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UsageSlice_DefinedBy) ProtoMessage() {}

func (x *UsageSlice_DefinedBy) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UsageSlice_DefinedBy.ProtoReflect.Descriptor instead.
func (*UsageSlice_DefinedBy) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{13, 1}
}

func (x *UsageSlice_DefinedBy) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *UsageSlice_DefinedBy) GetTypeFullName() string {
	if x != nil {
		return x.TypeFullName
	}
	return ""
}

func (x *UsageSlice_DefinedBy) GetResolvedMethod() string {
	if x != nil {
		return x.ResolvedMethod
	}
	return ""
}

func (x *UsageSlice_DefinedBy) GetPosition() uint32 {
	if x != nil {
		return x.Position
	}
	return 0
}

func (x *UsageSlice_DefinedBy) GetIsExternal() bool {
	if x != nil {
		return x.IsExternal
	}
	return false
}

func (x *UsageSlice_DefinedBy) GetLineNumber() uint32 {
	if x != nil {
		return x.LineNumber
	}
	return 0
}

func (x *UsageSlice_DefinedBy) GetColumnNumber() uint32 {
	if x != nil {
		return x.ColumnNumber
	}
	return 0
}

func (x *UsageSlice_DefinedBy) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

// The calls this object is observed to call.
type UsageSlice_InvokedCalls struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Call method name
	CallName string `protobuf:"bytes,1,opt,name=callName,proto3" json:"callName,omitempty"`
	// Full name of the resolved method
	ResolvedMethod string `protobuf:"bytes,2,opt,name=resolvedMethod,proto3" json:"resolvedMethod,omitempty"`
	// Types of the parameters
	ParamTypes []string `protobuf:"bytes,3,rep,name=paramTypes,proto3" json:"paramTypes,omitempty"`
	// Return type
	ReturnType string `protobuf:"bytes,4,opt,name=returnType,proto3" json:"returnType,omitempty"`
	// Boolean to indicate if the call belongs to an external method
	IsExternal bool `protobuf:"varint,5,opt,name=isExternal,proto3" json:"isExternal,omitempty"`
	// Line number
	LineNumber uint32 `protobuf:"varint,6,opt,name=lineNumber,proto3" json:"lineNumber,omitempty"`
	// Column number
	ColumnNumber  uint32 `protobuf:"varint,7,opt,name=columnNumber,proto3" json:"columnNumber,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UsageSlice_InvokedCalls) Reset() {
	*x = UsageSlice_InvokedCalls{}
	mi := &file_atom_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UsageSlice_InvokedCalls) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UsageSlice_InvokedCalls) ProtoMessage() {}

func (x *UsageSlice_InvokedCalls) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UsageSlice_InvokedCalls.ProtoReflect.Descriptor instead.
func (*UsageSlice_InvokedCalls) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{13, 2}
}

func (x *UsageSlice_InvokedCalls) GetCallName() string {
	if x != nil {
		return x.CallName
	}
	return ""
}

func (x *UsageSlice_InvokedCalls) GetResolvedMethod() string {
	if x != nil {
		return x.ResolvedMethod
	}
	return ""
}

func (x *UsageSlice_InvokedCalls) GetParamTypes() []string {
	if x != nil {
		return x.ParamTypes
	}
	return nil
}

func (x *UsageSlice_InvokedCalls) GetReturnType() string {
	if x != nil {
		return x.ReturnType
	}
	return ""
}

func (x *UsageSlice_InvokedCalls) GetIsExternal() bool {
	if x != nil {
		return x.IsExternal
	}
	return false
}

func (x *UsageSlice_InvokedCalls) GetLineNumber() uint32 {
	if x != nil {
		return x.LineNumber
	}
	return 0
}

func (x *UsageSlice_InvokedCalls) GetColumnNumber() uint32 {
	if x != nil {
		return x.ColumnNumber
	}
	return 0
}

// The calls this object is observed to be an argument of.
type UsageSlice_ArgToCalls struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Call method name
	CallName string `protobuf:"bytes,1,opt,name=callName,proto3" json:"callName,omitempty"`
	// Full name of the resolved method
	ResolvedMethod string `protobuf:"bytes,2,opt,name=resolvedMethod,proto3" json:"resolvedMethod,omitempty"`
	// Types of the parameters
	ParamTypes []string `protobuf:"bytes,3,rep,name=paramTypes,proto3" json:"paramTypes,omitempty"`
	// Return type
	ReturnType string `protobuf:"bytes,4,opt,name=returnType,proto3" json:"returnType,omitempty"`
	// Argument position
	Position uint32 `protobuf:"varint,5,opt,name=position,proto3" json:"position,omitempty"`
	// Boolean to indicate if the call belongs to an external method
	IsExternal bool `protobuf:"varint,6,opt,name=isExternal,proto3" json:"isExternal,omitempty"`
	// Line number
	LineNumber uint32 `protobuf:"varint,7,opt,name=lineNumber,proto3" json:"lineNumber,omitempty"`
	// Column number
	ColumnNumber  uint32 `protobuf:"varint,8,opt,name=columnNumber,proto3" json:"columnNumber,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UsageSlice_ArgToCalls) Reset() {
	*x = UsageSlice_ArgToCalls{}
	mi := &file_atom_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UsageSlice_ArgToCalls) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UsageSlice_ArgToCalls) ProtoMessage() {}

func (x *UsageSlice_ArgToCalls) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UsageSlice_ArgToCalls.ProtoReflect.Descriptor instead.
func (*UsageSlice_ArgToCalls) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{13, 3}
}

func (x *UsageSlice_ArgToCalls) GetCallName() string {
	if x != nil {
		return x.CallName
	}
	return ""
}

func (x *UsageSlice_ArgToCalls) GetResolvedMethod() string {
	if x != nil {
		return x.ResolvedMethod
	}
	return ""
}

func (x *UsageSlice_ArgToCalls) GetParamTypes() []string {
	if x != nil {
		return x.ParamTypes
	}
	return nil
}

func (x *UsageSlice_ArgToCalls) GetReturnType() string {
	if x != nil {
		return x.ReturnType
	}
	return ""
}

func (x *UsageSlice_ArgToCalls) GetPosition() uint32 {
	if x != nil {
		return x.Position
	}
	return 0
}

func (x *UsageSlice_ArgToCalls) GetIsExternal() bool {
	if x != nil {
		return x.IsExternal
	}
	return false
}

func (x *UsageSlice_ArgToCalls) GetLineNumber() uint32 {
	if x != nil {
		return x.LineNumber
	}
	return 0
}

func (x *UsageSlice_ArgToCalls) GetColumnNumber() uint32 {
	if x != nil {
		return x.ColumnNumber
	}
	return 0
}

// Describes where and how the given external object/type is used
type UsageSlice_ObjectUsageSlice struct {
	state         protoimpl.MessageState     `protogen:"open.v1"`
	TargetObj     *UsageSlice_TargetObj      `protobuf:"bytes,1,opt,name=targetObj,proto3" json:"targetObj,omitempty"`
	DefinedBy     *UsageSlice_DefinedBy      `protobuf:"bytes,2,opt,name=definedBy,proto3" json:"definedBy,omitempty"`
	InvokedCalls  []*UsageSlice_InvokedCalls `protobuf:"bytes,3,rep,name=invokedCalls,proto3" json:"invokedCalls,omitempty"`
	ArgToCalls    []*UsageSlice_ArgToCalls   `protobuf:"bytes,4,rep,name=argToCalls,proto3" json:"argToCalls,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UsageSlice_ObjectUsageSlice) Reset() {
	*x = UsageSlice_ObjectUsageSlice{}
	mi := &file_atom_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UsageSlice_ObjectUsageSlice) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UsageSlice_ObjectUsageSlice) ProtoMessage() {}

func (x *UsageSlice_ObjectUsageSlice) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UsageSlice_ObjectUsageSlice.ProtoReflect.Descriptor instead.
func (*UsageSlice_ObjectUsageSlice) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{13, 4}
}

func (x *UsageSlice_ObjectUsageSlice) GetTargetObj() *UsageSlice_TargetObj {
	if x != nil {
		return x.TargetObj
	}
	return nil
}

func (x *UsageSlice_ObjectUsageSlice) GetDefinedBy() *UsageSlice_DefinedBy {
	if x != nil {
		return x.DefinedBy
	}
	return nil
}

func (x *UsageSlice_ObjectUsageSlice) GetInvokedCalls() []*UsageSlice_InvokedCalls {
	if x != nil {
		return x.InvokedCalls
	}
	return nil
}

func (x *UsageSlice_ObjectUsageSlice) GetArgToCalls() []*UsageSlice_ArgToCalls {
	if x != nil {
		return x.ArgToCalls
	}
	return nil
}

// Packages the object usage slices along with location and an optional method source code.
type UsageSlice_MethodUsageSlice struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Raw source code of the method
	Code string `protobuf:"bytes,1,opt,name=code,proto3" json:"code,omitempty"`
	// Method full name
	FullName string `protobuf:"bytes,2,opt,name=fullName,proto3" json:"fullName,omitempty"`
	// File name
	FileName string `protobuf:"bytes,3,opt,name=fileName,proto3" json:"fileName,omitempty"`
	// Line number
	LineNumber uint32 `protobuf:"varint,4,opt,name=lineNumber,proto3" json:"lineNumber,omitempty"`
	// Column number
	ColumnNumber  uint32                         `protobuf:"varint,5,opt,name=columnNumber,proto3" json:"columnNumber,omitempty"`
	Usages        []*UsageSlice_ObjectUsageSlice `protobuf:"bytes,6,rep,name=usages,proto3" json:"usages,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UsageSlice_MethodUsageSlice) Reset() {
	*x = UsageSlice_MethodUsageSlice{}
	mi := &file_atom_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UsageSlice_MethodUsageSlice) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UsageSlice_MethodUsageSlice) ProtoMessage() {}

func (x *UsageSlice_MethodUsageSlice) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UsageSlice_MethodUsageSlice.ProtoReflect.Descriptor instead.
func (*UsageSlice_MethodUsageSlice) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{13, 5}
}

func (x *UsageSlice_MethodUsageSlice) GetCode() string {
	if x != nil {
		return x.Code
	}
	return ""
}

func (x *UsageSlice_MethodUsageSlice) GetFullName() string {
	if x != nil {
		return x.FullName
	}
	return ""
}

func (x *UsageSlice_MethodUsageSlice) GetFileName() string {
	if x != nil {
		return x.FileName
	}
	return ""
}

func (x *UsageSlice_MethodUsageSlice) GetLineNumber() uint32 {
	if x != nil {
		return x.LineNumber
	}
	return 0
}

func (x *UsageSlice_MethodUsageSlice) GetColumnNumber() uint32 {
	if x != nil {
		return x.ColumnNumber
	}
	return 0
}

func (x *UsageSlice_MethodUsageSlice) GetUsages() []*UsageSlice_ObjectUsageSlice {
	if x != nil {
		return x.Usages
	}
	return nil
}

// Represents a local transfer of data via aliasing. The data defined is via some alias.
type UsageSlice_Fields struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Name of the local variable
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Full name of the type
	TypeFullName string `protobuf:"bytes,2,opt,name=typeFullName,proto3" json:"typeFullName,omitempty"`
	// Line number
	LineNumber uint32 `protobuf:"varint,3,opt,name=lineNumber,proto3" json:"lineNumber,omitempty"`
	// Column number
	ColumnNumber uint32 `protobuf:"varint,4,opt,name=columnNumber,proto3" json:"columnNumber,omitempty"`
	// Type of the definition. Usually LOCAL
	Label         UsageSlice_LabelType `protobuf:"varint,5,opt,name=label,proto3,enum=atom.UsageSlice_LabelType" json:"label,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UsageSlice_Fields) Reset() {
	*x = UsageSlice_Fields{}
	mi := &file_atom_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UsageSlice_Fields) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UsageSlice_Fields) ProtoMessage() {}

func (x *UsageSlice_Fields) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UsageSlice_Fields.ProtoReflect.Descriptor instead.
func (*UsageSlice_Fields) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{13, 6}
}

func (x *UsageSlice_Fields) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *UsageSlice_Fields) GetTypeFullName() string {
	if x != nil {
		return x.TypeFullName
	}
	return ""
}

func (x *UsageSlice_Fields) GetLineNumber() uint32 {
	if x != nil {
		return x.LineNumber
	}
	return 0
}

func (x *UsageSlice_Fields) GetColumnNumber() uint32 {
	if x != nil {
		return x.ColumnNumber
	}
	return 0
}

func (x *UsageSlice_Fields) GetLabel() UsageSlice_LabelType {
	if x != nil {
		return x.Label
	}
	return UsageSlice_ANY
}

// Details related to an observed call.
type UsageSlice_Procedures struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Name of the method or call
	CallName string `protobuf:"bytes,1,opt,name=callName,proto3" json:"callName,omitempty"`
	// Full name of the resolved method
	ResolvedMethod string `protobuf:"bytes,2,opt,name=resolvedMethod,proto3" json:"resolvedMethod,omitempty"`
	// Types of the parameters
	ParamTypes []string `protobuf:"bytes,3,rep,name=paramTypes,proto3" json:"paramTypes,omitempty"`
	// Type of the return value
	ReturnType string `protobuf:"bytes,4,opt,name=returnType,proto3" json:"returnType,omitempty"`
	// Line number
	LineNumber uint32 `protobuf:"varint,5,opt,name=lineNumber,proto3" json:"lineNumber,omitempty"`
	// Column number
	ColumnNumber  uint32 `protobuf:"varint,6,opt,name=columnNumber,proto3" json:"columnNumber,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UsageSlice_Procedures) Reset() {
	*x = UsageSlice_Procedures{}
	mi := &file_atom_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UsageSlice_Procedures) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UsageSlice_Procedures) ProtoMessage() {}

func (x *UsageSlice_Procedures) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UsageSlice_Procedures.ProtoReflect.Descriptor instead.
func (*UsageSlice_Procedures) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{13, 7}
}

func (x *UsageSlice_Procedures) GetCallName() string {
	if x != nil {
		return x.CallName
	}
	return ""
}

func (x *UsageSlice_Procedures) GetResolvedMethod() string {
	if x != nil {
		return x.ResolvedMethod
	}
	return ""
}

func (x *UsageSlice_Procedures) GetParamTypes() []string {
	if x != nil {
		return x.ParamTypes
	}
	return nil
}

func (x *UsageSlice_Procedures) GetReturnType() string {
	if x != nil {
		return x.ReturnType
	}
	return ""
}

func (x *UsageSlice_Procedures) GetLineNumber() uint32 {
	if x != nil {
		return x.LineNumber
	}
	return 0
}

func (x *UsageSlice_Procedures) GetColumnNumber() uint32 {
	if x != nil {
		return x.ColumnNumber
	}
	return 0
}

// Describes custom types defined within the application.
type UsageSlice_UserDefinedTypes struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Name of the type
	Name       string                   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Fields     []*UsageSlice_Fields     `protobuf:"bytes,2,rep,name=fields,proto3" json:"fields,omitempty"`
	Procedures []*UsageSlice_Procedures `protobuf:"bytes,3,rep,name=procedures,proto3" json:"procedures,omitempty"`
	// File name
	FileName string `protobuf:"bytes,4,opt,name=fileName,proto3" json:"fileName,omitempty"`
	// Line number
	LineNumber uint32 `protobuf:"varint,5,opt,name=lineNumber,proto3" json:"lineNumber,omitempty"`
	// Column number
	ColumnNumber  uint32 `protobuf:"varint,6,opt,name=columnNumber,proto3" json:"columnNumber,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UsageSlice_UserDefinedTypes) Reset() {
	*x = UsageSlice_UserDefinedTypes{}
	mi := &file_atom_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UsageSlice_UserDefinedTypes) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UsageSlice_UserDefinedTypes) ProtoMessage() {}

func (x *UsageSlice_UserDefinedTypes) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UsageSlice_UserDefinedTypes.ProtoReflect.Descriptor instead.
func (*UsageSlice_UserDefinedTypes) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{13, 8}
}

func (x *UsageSlice_UserDefinedTypes) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *UsageSlice_UserDefinedTypes) GetFields() []*UsageSlice_Fields {
	if x != nil {
		return x.Fields
	}
	return nil
}

func (x *UsageSlice_UserDefinedTypes) GetProcedures() []*UsageSlice_Procedures {
	if x != nil {
		return x.Procedures
	}
	return nil
}

func (x *UsageSlice_UserDefinedTypes) GetFileName() string {
	if x != nil {
		return x.FileName
	}
	return ""
}

func (x *UsageSlice_UserDefinedTypes) GetLineNumber() uint32 {
	if x != nil {
		return x.LineNumber
	}
	return 0
}

func (x *UsageSlice_UserDefinedTypes) GetColumnNumber() uint32 {
	if x != nil {
		return x.ColumnNumber
	}
	return 0
}

type DataFlowSlice_Edges struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Source node id
	Src uint32 `protobuf:"varint,1,opt,name=src,proto3" json:"src,omitempty"`
	// Destination node id
	Dst uint32 `protobuf:"varint,2,opt,name=dst,proto3" json:"dst,omitempty"`
	// Edge type
	Label         CpgStruct_Edge_EdgeType `protobuf:"varint,3,opt,name=label,proto3,enum=atom.CpgStruct_Edge_EdgeType" json:"label,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DataFlowSlice_Edges) Reset() {
	*x = DataFlowSlice_Edges{}
	mi := &file_atom_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DataFlowSlice_Edges) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DataFlowSlice_Edges) ProtoMessage() {}

func (x *DataFlowSlice_Edges) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DataFlowSlice_Edges.ProtoReflect.Descriptor instead.
func (*DataFlowSlice_Edges) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{15, 0}
}

func (x *DataFlowSlice_Edges) GetSrc() uint32 {
	if x != nil {
		return x.Src
	}
	return 0
}

func (x *DataFlowSlice_Edges) GetDst() uint32 {
	if x != nil {
		return x.Dst
	}
	return 0
}

func (x *DataFlowSlice_Edges) GetLabel() CpgStruct_Edge_EdgeType {
	if x != nil {
		return x.Label
	}
	return CpgStruct_Edge_UNKNOWN_EDGE_TYPE
}

type DataFlowSlice_Flows struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Node id
	Id            []uint32 `protobuf:"varint,1,rep,packed,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DataFlowSlice_Flows) Reset() {
	*x = DataFlowSlice_Flows{}
	mi := &file_atom_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DataFlowSlice_Flows) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DataFlowSlice_Flows) ProtoMessage() {}

func (x *DataFlowSlice_Flows) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DataFlowSlice_Flows.ProtoReflect.Descriptor instead.
func (*DataFlowSlice_Flows) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{15, 1}
}

func (x *DataFlowSlice_Flows) GetId() []uint32 {
	if x != nil {
		return x.Id
	}
	return nil
}

type DataFlowSlice_Paths struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Flows from source to sink
	Flows         []*DataFlowSlice_Flows `protobuf:"bytes,1,rep,name=flows,proto3" json:"flows,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DataFlowSlice_Paths) Reset() {
	*x = DataFlowSlice_Paths{}
	mi := &file_atom_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DataFlowSlice_Paths) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DataFlowSlice_Paths) ProtoMessage() {}

func (x *DataFlowSlice_Paths) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DataFlowSlice_Paths.ProtoReflect.Descriptor instead.
func (*DataFlowSlice_Paths) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{15, 2}
}

func (x *DataFlowSlice_Paths) GetFlows() []*DataFlowSlice_Flows {
	if x != nil {
		return x.Flows
	}
	return nil
}

type DataFlowSlice_Graph struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Nodes         []*Nodes               `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes,omitempty"`
	Edges         []*DataFlowSlice_Edges `protobuf:"bytes,2,rep,name=edges,proto3" json:"edges,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DataFlowSlice_Graph) Reset() {
	*x = DataFlowSlice_Graph{}
	mi := &file_atom_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DataFlowSlice_Graph) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DataFlowSlice_Graph) ProtoMessage() {}

func (x *DataFlowSlice_Graph) ProtoReflect() protoreflect.Message {
	mi := &file_atom_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DataFlowSlice_Graph.ProtoReflect.Descriptor instead.
func (*DataFlowSlice_Graph) Descriptor() ([]byte, []int) {
	return file_atom_proto_rawDescGZIP(), []int{15, 3}
}

func (x *DataFlowSlice_Graph) GetNodes() []*Nodes {
	if x != nil {
		return x.Nodes
	}
	return nil
}

func (x *DataFlowSlice_Graph) GetEdges() []*DataFlowSlice_Edges {
	if x != nil {
		return x.Edges
	}
	return nil
}

var File_atom_proto protoreflect.FileDescriptor

const file_atom_proto_rawDesc = "" +
	"\n" +
	"\n" +
	"atom.proto\x12\x04atom\"\xca\x04\n" +
	"\rPropertyValue\x12#\n" +
	"\fstring_value\x18\x01 \x01(\tH\x00R\vstringValue\x12\x1f\n" +
	"\n" +
	"bool_value\x18\x02 \x01(\bH\x00R\tboolValue\x12\x1d\n" +
	"\tint_value\x18\x03 \x01(\x05H\x00R\bintValue\x12\x1f\n" +
	"\n" +
	"long_value\x18\x04 \x01(\x03H\x00R\tlongValue\x12!\n" +
	"\vfloat_value\x18\x05 \x01(\x02H\x00R\n" +
	"floatValue\x12#\n" +
	"\fdouble_value\x18\x06 \x01(\x01H\x00R\vdoubleValue\x123\n" +
	"\vstring_list\x18\a \x01(\v2\x10.atom.StringListH\x00R\n" +
	"stringList\x12-\n" +
	"\tbool_list\x18\b \x01(\v2\x0e.atom.BoolListH\x00R\bboolList\x12*\n" +
	"\bint_list\x18\t \x01(\v2\r.atom.IntListH\x00R\aintList\x12-\n" +
	"\tlong_list\x18\n" +
	" \x01(\v2\x0e.atom.LongListH\x00R\blongList\x120\n" +
	"\n" +
	"float_list\x18\v \x01(\v2\x0f.atom.FloatListH\x00R\tfloatList\x123\n" +
	"\vdouble_list\x18\f \x01(\v2\x10.atom.DoubleListH\x00R\n" +
	"doubleList\x12<\n" +
	"\x0econtained_refs\x18\r \x01(\v2\x13.atom.ContainedRefsH\x00R\rcontainedRefsB\a\n" +
	"\x05value\"B\n" +
	"\rContainedRefs\x12\x1d\n" +
	"\n" +
	"local_name\x18\x01 \x01(\tR\tlocalName\x12\x12\n" +
	"\x04refs\x18\x02 \x03(\x03R\x04refs\"$\n" +
	"\n" +
	"StringList\x12\x16\n" +
	"\x06values\x18\x01 \x03(\tR\x06values\"\"\n" +
	"\bBoolList\x12\x16\n" +
	"\x06values\x18\x01 \x03(\bR\x06values\"!\n" +
	"\aIntList\x12\x16\n" +
	"\x06values\x18\x01 \x03(\x05R\x06values\"\"\n" +
	"\bLongList\x12\x16\n" +
	"\x06values\x18\x01 \x03(\x03R\x06values\"#\n" +
	"\tFloatList\x12\x16\n" +
	"\x06values\x18\x01 \x03(\x02R\x06values\"$\n" +
	"\n" +
	"DoubleList\x12\x16\n" +
	"\x06values\x18\x01 \x03(\x01R\x06values\"\xcf\a\n" +
	"\tCpgStruct\x12(\n" +
	"\x04node\x18\x01 \x03(\v2\x14.atom.CpgStruct.NodeR\x04node\x12(\n" +
	"\x04edge\x18\x02 \x03(\v2\x14.atom.CpgStruct.EdgeR\x04edge\x1a\xda\x01\n" +
	"\x04Node\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x03R\x03key\x12\"\n" +
	"\x04type\x18\x02 \x01(\x0e2\x0e.atom.NodeTypeR\x04type\x129\n" +
	"\bproperty\x18\x03 \x03(\v2\x1d.atom.CpgStruct.Node.PropertyR\bproperty\x1aa\n" +
	"\bProperty\x12*\n" +
	"\x04name\x18\x01 \x01(\x0e2\x16.atom.NodePropertyNameR\x04name\x12)\n" +
	"\x05value\x18\x02 \x01(\v2\x13.atom.PropertyValueR\x05value\x1a\x90\x05\n" +
	"\x04Edge\x12\x10\n" +
	"\x03src\x18\x01 \x01(\x03R\x03src\x12\x10\n" +
	"\x03dst\x18\x02 \x01(\x03R\x03dst\x121\n" +
	"\x04type\x18\x03 \x01(\x0e2\x1d.atom.CpgStruct.Edge.EdgeTypeR\x04type\x129\n" +
	"\bproperty\x18\x04 \x03(\v2\x1d.atom.CpgStruct.Edge.PropertyR\bproperty\x1aa\n" +
	"\bProperty\x12*\n" +
	"\x04name\x18\x01 \x01(\x0e2\x16.atom.EdgePropertyNameR\x04name\x12)\n" +
	"\x05value\x18\x02 \x01(\v2\x13.atom.PropertyValueR\x05value\"\x87\x03\n" +
	"\bEdgeType\x12\x15\n" +
	"\x11UNKNOWN_EDGE_TYPE\x10\x00\x12\a\n" +
	"\x03AST\x10\x03\x12\b\n" +
	"\x04CALL\x10\x06\x12\a\n" +
	"\x03REF\x10\n" +
	"\x12\r\n" +
	"\tTAGGED_BY\x10\v\x12\x12\n" +
	"\x0ePARAMETER_LINK\x10\f\x12\a\n" +
	"\x03CFG\x10\x13\x12\r\n" +
	"\tEVAL_TYPE\x10\x15\x12\f\n" +
	"\bBINDS_TO\x10\x16\x12\x11\n" +
	"\rINHERITS_FROM\x10\x17\x12\f\n" +
	"\bCONTAINS\x10\x1c\x12\v\n" +
	"\aCAPTURE\x10(\x12\x0f\n" +
	"\vCAPTURED_BY\x10)\x12\f\n" +
	"\bRECEIVER\x107\x12\r\n" +
	"\tCONDITION\x108\x12\x11\n" +
	"\fREACHING_DEF\x10\x89\x01\x12\r\n" +
	"\bALIAS_OF\x10\x8a\x01\x12\n" +
	"\n" +
	"\x05BINDS\x10\x9b\x01\x12\r\n" +
	"\bARGUMENT\x10\x9c\x01\x12\x10\n" +
	"\vSOURCE_FILE\x10\x9d\x01\x12\r\n" +
	"\bDOMINATE\x10\xb5\x01\x12\x12\n" +
	"\rPOST_DOMINATE\x10\xb6\x01\x12\b\n" +
	"\x03CDG\x10\xb7\x01\x12\r\n" +
	"\aIMPORTS\x10\xef\xb8\x01\x12\x18\n" +
	"\x12IS_CALL_FOR_IMPORT\x10\xf0\xb8\x01J\x04\b\x05\x10\x06R\x03key\"l\n" +
	"\x16AdditionalNodeProperty\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\x03R\x06nodeId\x129\n" +
	"\bproperty\x18\x02 \x01(\v2\x1d.atom.CpgStruct.Node.PropertyR\bproperty\"\xea\x01\n" +
	"\x16AdditionalEdgeProperty\x12\x17\n" +
	"\aedge_id\x18\x01 \x01(\x03R\x06edgeId\x129\n" +
	"\bproperty\x18\x02 \x01(\v2\x1d.atom.CpgStruct.Edge.PropertyR\bproperty\x12 \n" +
	"\fout_node_key\x18\x03 \x01(\x03R\n" +
	"outNodeKey\x12\x1e\n" +
	"\vin_node_key\x18\x04 \x01(\x03R\tinNodeKey\x12:\n" +
	"\tedge_type\x18\x05 \x01(\x0e2\x1d.atom.CpgStruct.Edge.EdgeTypeR\bedgeType\"\xe6\x01\n" +
	"\n" +
	"CpgOverlay\x12(\n" +
	"\x04node\x18\x01 \x03(\v2\x14.atom.CpgStruct.NodeR\x04node\x12(\n" +
	"\x04edge\x18\x02 \x03(\v2\x14.atom.CpgStruct.EdgeR\x04edge\x12A\n" +
	"\rnode_property\x18\x03 \x03(\v2\x1c.atom.AdditionalNodePropertyR\fnodeProperty\x12A\n" +
	"\redge_property\x18\x04 \x03(\v2\x1c.atom.AdditionalEdgePropertyR\fedgeProperty\"\xa1\t\n" +
	"\tDiffGraph\x12/\n" +
	"\aentries\x18\x01 \x03(\v2\x15.atom.DiffGraph.EntryR\aentries\x1a\x1e\n" +
	"\n" +
	"RemoveNode\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x03R\x03key\x1aq\n" +
	"\x12RemoveNodeProperty\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x03R\x03key\x12*\n" +
	"\x04name\x18\x02 \x01(\x0e2\x16.atom.NodePropertyNameR\x04name\x12\x1d\n" +
	"\n" +
	"local_name\x18\x03 \x01(\tR\tlocalName\x1a\xb2\x01\n" +
	"\n" +
	"RemoveEdge\x12 \n" +
	"\fout_node_key\x18\x01 \x01(\x03R\n" +
	"outNodeKey\x12\x1e\n" +
	"\vin_node_key\x18\x02 \x01(\x03R\tinNodeKey\x12:\n" +
	"\tedge_type\x18\x03 \x01(\x0e2\x1d.atom.CpgStruct.Edge.EdgeTypeR\bedgeType\x12&\n" +
	"\x0epropertiesHash\x18\x04 \x01(\fR\x0epropertiesHash\x1a\xf7\x01\n" +
	"\x12RemoveEdgeProperty\x12 \n" +
	"\fout_node_key\x18\x01 \x01(\x03R\n" +
	"outNodeKey\x12\x1e\n" +
	"\vin_node_key\x18\x02 \x01(\x03R\tinNodeKey\x12:\n" +
	"\tedge_type\x18\x03 \x01(\x0e2\x1d.atom.CpgStruct.Edge.EdgeTypeR\bedgeType\x12&\n" +
	"\x0epropertiesHash\x18\x04 \x01(\fR\x0epropertiesHash\x12;\n" +
	"\rproperty_name\x18\x05 \x01(\x0e2\x16.atom.EdgePropertyNameR\fpropertyName\x1a\xa0\x04\n" +
	"\x05Entry\x12*\n" +
	"\x04node\x18\x01 \x01(\v2\x14.atom.CpgStruct.NodeH\x00R\x04node\x12*\n" +
	"\x04edge\x18\x02 \x01(\v2\x14.atom.CpgStruct.EdgeH\x00R\x04edge\x12C\n" +
	"\rnode_property\x18\x03 \x01(\v2\x1c.atom.AdditionalNodePropertyH\x00R\fnodeProperty\x12C\n" +
	"\redge_property\x18\x04 \x01(\v2\x1c.atom.AdditionalEdgePropertyH\x00R\fedgeProperty\x12=\n" +
	"\vremove_node\x18\x05 \x01(\v2\x1a.atom.DiffGraph.RemoveNodeH\x00R\n" +
	"removeNode\x12V\n" +
	"\x14remove_node_property\x18\x06 \x01(\v2\".atom.DiffGraph.RemoveNodePropertyH\x00R\x12removeNodeProperty\x12=\n" +
	"\vremove_edge\x18\a \x01(\v2\x1a.atom.DiffGraph.RemoveEdgeH\x00R\n" +
	"removeEdge\x12V\n" +
	"\x14remove_edge_property\x18\b \x01(\v2\".atom.DiffGraph.RemoveEdgePropertyH\x00R\x12removeEdgePropertyB\a\n" +
	"\x05value\"\x88\x13\n" +
	"\n" +
	"UsageSlice\x12E\n" +
	"\fobjectSlices\x18\x01 \x03(\v2!.atom.UsageSlice.MethodUsageSliceR\fobjectSlices\x12M\n" +
	"\x10userDefinedTypes\x18\x02 \x03(\v2!.atom.UsageSlice.UserDefinedTypesR\x10userDefinedTypes\x1a\xf5\x01\n" +
	"\tTargetObj\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\"\n" +
	"\ftypeFullName\x18\x02 \x01(\tR\ftypeFullName\x12\x1a\n" +
	"\bposition\x18\x03 \x01(\rR\bposition\x12\x1e\n" +
	"\n" +
	"isExternal\x18\x04 \x01(\bR\n" +
	"isExternal\x12\x1e\n" +
	"\n" +
	"lineNumber\x18\x05 \x01(\rR\n" +
	"lineNumber\x12\"\n" +
	"\fcolumnNumber\x18\x06 \x01(\rR\fcolumnNumber\x120\n" +
	"\x05label\x18\a \x01(\x0e2\x1a.atom.UsageSlice.LabelTypeR\x05label\x1a\x81\x02\n" +
	"\tDefinedBy\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\"\n" +
	"\ftypeFullName\x18\x02 \x01(\tR\ftypeFullName\x12&\n" +
	"\x0eresolvedMethod\x18\x03 \x01(\tR\x0eresolvedMethod\x12\x1a\n" +
	"\bposition\x18\x04 \x01(\rR\bposition\x12\x1e\n" +
	"\n" +
	"isExternal\x18\x05 \x01(\bR\n" +
	"isExternal\x12\x1e\n" +
	"\n" +
	"lineNumber\x18\x06 \x01(\rR\n" +
	"lineNumber\x12\"\n" +
	"\fcolumnNumber\x18\a \x01(\rR\fcolumnNumber\x12\x14\n" +
	"\x05label\x18\b \x01(\tR\x05label\x1a\xf6\x01\n" +
	"\fInvokedCalls\x12\x1a\n" +
	"\bcallName\x18\x01 \x01(\tR\bcallName\x12&\n" +
	"\x0eresolvedMethod\x18\x02 \x01(\tR\x0eresolvedMethod\x12\x1e\n" +
	"\n" +
	"paramTypes\x18\x03 \x03(\tR\n" +
	"paramTypes\x12\x1e\n" +
	"\n" +
	"returnType\x18\x04 \x01(\tR\n" +
	"returnType\x12\x1e\n" +
	"\n" +
	"isExternal\x18\x05 \x01(\bR\n" +
	"isExternal\x12\x1e\n" +
	"\n" +
	"lineNumber\x18\x06 \x01(\rR\n" +
	"lineNumber\x12\"\n" +
	"\fcolumnNumber\x18\a \x01(\rR\fcolumnNumber\x1a\x90\x02\n" +
	"\n" +
	"ArgToCalls\x12\x1a\n" +
	"\bcallName\x18\x01 \x01(\tR\bcallName\x12&\n" +
	"\x0eresolvedMethod\x18\x02 \x01(\tR\x0eresolvedMethod\x12\x1e\n" +
	"\n" +
	"paramTypes\x18\x03 \x03(\tR\n" +
	"paramTypes\x12\x1e\n" +
	"\n" +
	"returnType\x18\x04 \x01(\tR\n" +
	"returnType\x12\x1a\n" +
	"\bposition\x18\x05 \x01(\rR\bposition\x12\x1e\n" +
	"\n" +
	"isExternal\x18\x06 \x01(\bR\n" +
	"isExternal\x12\x1e\n" +
	"\n" +
	"lineNumber\x18\a \x01(\rR\n" +
	"lineNumber\x12\"\n" +
	"\fcolumnNumber\x18\b \x01(\rR\fcolumnNumber\x1a\x86\x02\n" +
	"\x10ObjectUsageSlice\x128\n" +
	"\ttargetObj\x18\x01 \x01(\v2\x1a.atom.UsageSlice.TargetObjR\ttargetObj\x128\n" +
	"\tdefinedBy\x18\x02 \x01(\v2\x1a.atom.UsageSlice.DefinedByR\tdefinedBy\x12A\n" +
	"\finvokedCalls\x18\x03 \x03(\v2\x1d.atom.UsageSlice.InvokedCallsR\finvokedCalls\x12;\n" +
	"\n" +
	"argToCalls\x18\x04 \x03(\v2\x1b.atom.UsageSlice.ArgToCallsR\n" +
	"argToCalls\x1a\xdd\x01\n" +
	"\x10MethodUsageSlice\x12\x12\n" +
	"\x04code\x18\x01 \x01(\tR\x04code\x12\x1a\n" +
	"\bfullName\x18\x02 \x01(\tR\bfullName\x12\x1a\n" +
	"\bfileName\x18\x03 \x01(\tR\bfileName\x12\x1e\n" +
	"\n" +
	"lineNumber\x18\x04 \x01(\rR\n" +
	"lineNumber\x12\"\n" +
	"\fcolumnNumber\x18\x05 \x01(\rR\fcolumnNumber\x129\n" +
	"\x06usages\x18\x06 \x03(\v2!.atom.UsageSlice.ObjectUsageSliceR\x06usages\x1a\xb6\x01\n" +
	"\x06Fields\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\"\n" +
	"\ftypeFullName\x18\x02 \x01(\tR\ftypeFullName\x12\x1e\n" +
	"\n" +
	"lineNumber\x18\x03 \x01(\rR\n" +
	"lineNumber\x12\"\n" +
	"\fcolumnNumber\x18\x04 \x01(\rR\fcolumnNumber\x120\n" +
	"\x05label\x18\x05 \x01(\x0e2\x1a.atom.UsageSlice.LabelTypeR\x05label\x1a\xd4\x01\n" +
	"\n" +
	"Procedures\x12\x1a\n" +
	"\bcallName\x18\x01 \x01(\tR\bcallName\x12&\n" +
	"\x0eresolvedMethod\x18\x02 \x01(\tR\x0eresolvedMethod\x12\x1e\n" +
	"\n" +
	"paramTypes\x18\x03 \x03(\tR\n" +
	"paramTypes\x12\x1e\n" +
	"\n" +
	"returnType\x18\x04 \x01(\tR\n" +
	"returnType\x12\x1e\n" +
	"\n" +
	"lineNumber\x18\x05 \x01(\rR\n" +
	"lineNumber\x12\"\n" +
	"\fcolumnNumber\x18\x06 \x01(\rR\fcolumnNumber\x1a\xf4\x01\n" +
	"\x10UserDefinedTypes\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12/\n" +
	"\x06fields\x18\x02 \x03(\v2\x17.atom.UsageSlice.FieldsR\x06fields\x12;\n" +
	"\n" +
	"procedures\x18\x03 \x03(\v2\x1b.atom.UsageSlice.ProceduresR\n" +
	"procedures\x12\x1a\n" +
	"\bfileName\x18\x04 \x01(\tR\bfileName\x12\x1e\n" +
	"\n" +
	"lineNumber\x18\x05 \x01(\rR\n" +
	"lineNumber\x12\"\n" +
	"\fcolumnNumber\x18\x06 \x01(\rR\fcolumnNumber\"l\n" +
	"\tLabelType\x12\a\n" +
	"\x03ANY\x10\x00\x12\t\n" +
	"\x05LOCAL\x10\x01\x12\v\n" +
	"\aLITERAL\x10\x02\x12\t\n" +
	"\x05PARAM\x10\x03\x12\b\n" +
	"\x04CALL\x10\x04\x12\x0e\n" +
	"\n" +
	"IDENTIFIER\x10\x05\x12\f\n" +
	"\bTYPE_REF\x10\x06\x12\v\n" +
	"\aUNKNOWN\x10\n" +
	"\"\x9d\x04\n" +
	"\x05Nodes\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\rR\x02id\x12$\n" +
	"\x05label\x18\x02 \x01(\x0e2\x0e.atom.NodeTypeR\x05label\x12\x12\n" +
	"\x04name\x18\x03 \x01(\tR\x04name\x12\x1a\n" +
	"\bfullName\x18\x04 \x01(\tR\bfullName\x12\x1c\n" +
	"\tsignature\x18\x05 \x01(\tR\tsignature\x12\x1e\n" +
	"\n" +
	"isExternal\x18\x06 \x01(\bR\n" +
	"isExternal\x12\x12\n" +
	"\x04code\x18\a \x01(\tR\x04code\x12\"\n" +
	"\ftypeFullName\x18\b \x01(\tR\ftypeFullName\x12*\n" +
	"\x10parentMethodName\x18\t \x01(\tR\x10parentMethodName\x124\n" +
	"\x15parentMethodSignature\x18\n" +
	" \x01(\tR\x15parentMethodSignature\x12&\n" +
	"\x0eparentFileName\x18\v \x01(\tR\x0eparentFileName\x12,\n" +
	"\x11parentPackageName\x18\f \x01(\tR\x11parentPackageName\x12(\n" +
	"\x0fparentClassName\x18\r \x01(\tR\x0fparentClassName\x12\x1e\n" +
	"\n" +
	"lineNumber\x18\x0e \x01(\rR\n" +
	"lineNumber\x12\"\n" +
	"\fcolumnNumber\x18\x0f \x01(\rR\fcolumnNumber\x12\x12\n" +
	"\x04tags\x18\x10 \x01(\tR\x04tags\"\x81\x03\n" +
	"\rDataFlowSlice\x12/\n" +
	"\x05graph\x18\x01 \x01(\v2\x19.atom.DataFlowSlice.GraphR\x05graph\x12-\n" +
	"\x04path\x18\x02 \x01(\v2\x19.atom.DataFlowSlice.PathsR\x04path\x1a`\n" +
	"\x05Edges\x12\x10\n" +
	"\x03src\x18\x01 \x01(\rR\x03src\x12\x10\n" +
	"\x03dst\x18\x02 \x01(\rR\x03dst\x123\n" +
	"\x05label\x18\x03 \x01(\x0e2\x1d.atom.CpgStruct.Edge.EdgeTypeR\x05label\x1a\x17\n" +
	"\x05Flows\x12\x0e\n" +
	"\x02id\x18\x01 \x03(\rR\x02id\x1a8\n" +
	"\x05Paths\x12/\n" +
	"\x05flows\x18\x01 \x03(\v2\x19.atom.DataFlowSlice.FlowsR\x05flows\x1a[\n" +
	"\x05Graph\x12!\n" +
	"\x05nodes\x18\x01 \x03(\v2\v.atom.NodesR\x05nodes\x12/\n" +
	"\x05edges\x18\x02 \x03(\v2\x19.atom.DataFlowSlice.EdgesR\x05edges\"I\n" +
	"\x0eReachableSlice\x12!\n" +
	"\x05flows\x18\x01 \x03(\v2\v.atom.NodesR\x05flows\x12\x14\n" +
	"\x05purls\x18\x02 \x03(\tR\x05purls\"B\n" +
	"\x12ReachableSliceList\x12,\n" +
	"\x06slices\x18\x01 \x03(\v2\x14.atom.ReachableSliceR\x06slices*\xa5\a\n" +
	"\x10NodePropertyName\x12\x19\n" +
	"\x15UNKNOWN_NODE_PROPERTY\x10\x00\x12\x0f\n" +
	"\vLINE_NUMBER\x10\x02\x12\x14\n" +
	"\x10PARSER_TYPE_NAME\x10\x03\x12\t\n" +
	"\x05ORDER\x10\x04\x12\b\n" +
	"\x04NAME\x10\x05\x12\r\n" +
	"\tFULL_NAME\x10\x06\x12\x0f\n" +
	"\vIS_EXTERNAL\x10\a\x12\t\n" +
	"\x05VALUE\x10\b\x12\x11\n" +
	"\rCOLUMN_NUMBER\x10\v\x12\x13\n" +
	"\x0fLINE_NUMBER_END\x10\f\x12\v\n" +
	"\aVERSION\x10\r\x12\x17\n" +
	"\x13EVALUATION_STRATEGY\x10\x0f\x12\x15\n" +
	"\x11COLUMN_NUMBER_END\x10\x10\x12\f\n" +
	"\bLANGUAGE\x10\x13\x12\v\n" +
	"\aCONTENT\x10\x14\x12\b\n" +
	"\x04CODE\x10\x15\x12\r\n" +
	"\tSIGNATURE\x10\x16\x12\x11\n" +
	"\rDISPATCH_TYPE\x10\x19\x12\x11\n" +
	"\rMODIFIER_TYPE\x10\x1a\x12\x1a\n" +
	"\x16CONTROL_STRUCTURE_TYPE\x10\x1b\x12\x12\n" +
	"\x0eARGUMENT_INDEX\x10(\x12\x16\n" +
	"\x12CLOSURE_BINDING_ID\x102\x12\x12\n" +
	"\x0eTYPE_FULL_NAME\x103\x12\x17\n" +
	"\x13TYPE_DECL_FULL_NAME\x104\x12 \n" +
	"\x1cINHERITS_FROM_TYPE_FULL_NAME\x105\x12\x14\n" +
	"\x10METHOD_FULL_NAME\x106\x12\x13\n" +
	"\x0fAST_PARENT_TYPE\x108\x12\x18\n" +
	"\x14AST_PARENT_FULL_NAME\x109\x12\x17\n" +
	"\x13DEPENDENCY_GROUP_ID\x10:\x12\n" +
	"\n" +
	"\x06SYMBOL\x10d\x12\x15\n" +
	"\x11METHOD_SHORT_NAME\x10f\x12\x10\n" +
	"\fPACKAGE_NAME\x10g\x12\x0e\n" +
	"\n" +
	"CLASS_NAME\x10h\x12\x0e\n" +
	"\n" +
	"NODE_LABEL\x10i\x12\f\n" +
	"\bFILENAME\x10j\x12\f\n" +
	"\bOVERLAYS\x10v\x12\b\n" +
	"\x04HASH\x10x\x12\x12\n" +
	"\rARGUMENT_NAME\x10\x82\x01\x12\b\n" +
	"\x03KEY\x10\x83\x01\x12\x15\n" +
	"\x10CLASS_SHORT_NAME\x10\x84\x01\x12\x19\n" +
	"\x14ALIAS_TYPE_FULL_NAME\x10\x9e\x01\x12\x1a\n" +
	"\x15CLOSURE_ORIGINAL_NAME\x10\x9f\x01\x12\x10\n" +
	"\vIS_VARIADIC\x10\xdd\x01\x12\t\n" +
	"\x04ROOT\x10\xaf\t\x12 \n" +
	"\x1bDYNAMIC_TYPE_HINT_FULL_NAME\x10\xb7\f\x12\n" +
	"\n" +
	"\x05INDEX\x10\xaf\x11\x12\x14\n" +
	"\x0eCANONICAL_NAME\x10z\x12\x13\n" +
	"\rCONTAINED_REF\x10\xf9\xc0z*;\n" +
	"\x10EdgePropertyName\x12\x19\n" +
	"\x15UNKNOWN_EDGE_PROPERTY\x10\x00\x12\f\n" +
	"\bVARIABLE\x10\v*\xbd\x01\n" +
	"\rModifierTypes\x12\x19\n" +
	"\x15UNKNOWN_MODIFIER_TYPE\x10\x00\x12\n" +
	"\n" +
	"\x06STATIC\x10\x01\x12\n" +
	"\n" +
	"\x06PUBLIC\x10\x02\x12\r\n" +
	"\tPROTECTED\x10\x03\x12\v\n" +
	"\aPRIVATE\x10\x04\x12\f\n" +
	"\bABSTRACT\x10\x05\x12\n" +
	"\n" +
	"\x06NATIVE\x10\x06\x12\x0f\n" +
	"\vCONSTRUCTOR\x10\a\x12\v\n" +
	"\aVIRTUAL\x10\b\x12\f\n" +
	"\bINTERNAL\x10\t\x12\t\n" +
	"\x05FINAL\x10\n" +
	"\x12\f\n" +
	"\bREADONLY\x10\v*\xf2\x01\n" +
	"\tLANGUAGES\x12\x14\n" +
	"\x10UNKNOWN_LANGUAGE\x10\x00\x12\b\n" +
	"\x04JAVA\x10\x01\x12\x0e\n" +
	"\n" +
	"JAVASCRIPT\x10\x02\x12\n" +
	"\n" +
	"\x06GOLANG\x10\x03\x12\n" +
	"\n" +
	"\x06CSHARP\x10\x04\x12\x05\n" +
	"\x01C\x10\x05\x12\n" +
	"\n" +
	"\x06PYTHON\x10\x06\x12\b\n" +
	"\x04LLVM\x10\a\x12\a\n" +
	"\x03PHP\x10\b\x12\x13\n" +
	"\x0fFUZZY_TEST_LANG\x10\t\x12\n" +
	"\n" +
	"\x06GHIDRA\x10\n" +
	"\x12\n" +
	"\n" +
	"\x06KOTLIN\x10\v\x12\b\n" +
	"\x04NEWC\x10\f\x12\v\n" +
	"\aJAVASRC\x10\r\x12\r\n" +
	"\tPYTHONSRC\x10\x0e\x12\t\n" +
	"\x05JSSRC\x10\x0f\x12\f\n" +
	"\bSOLIDITY\x10\x10\x12\v\n" +
	"\aRUBYSRC\x10\x11*g\n" +
	"\x14EvaluationStrategies\x12\x1f\n" +
	"\x1bUNKNOWN_EVALUATION_STRATEGY\x10\x00\x12\x10\n" +
	"\fBY_REFERENCE\x10\x01\x12\x0e\n" +
	"\n" +
	"BY_SHARING\x10\x02\x12\f\n" +
	"\bBY_VALUE\x10\x03*b\n" +
	"\rDispatchTypes\x12\x19\n" +
	"\x15UNKNOWN_DISPATCH_TYPE\x10\x00\x12\x13\n" +
	"\x0fSTATIC_DISPATCH\x10\x01\x12\x14\n" +
	"\x10DYNAMIC_DISPATCH\x10\x02\x12\v\n" +
	"\aINLINED\x10\x03*\xc4\x01\n" +
	"\x17CONTROL_STRUCTURE_TYPES\x12\"\n" +
	"\x1eUNKNOWN_CONTROL_STRUCTURE_TYPE\x10\x00\x12\t\n" +
	"\x05BREAK\x10\x01\x12\f\n" +
	"\bCONTINUE\x10\x02\x12\t\n" +
	"\x05WHILE\x10\x03\x12\x06\n" +
	"\x02DO\x10\x04\x12\a\n" +
	"\x03FOR\x10\x05\x12\b\n" +
	"\x04GOTO\x10\x06\x12\x06\n" +
	"\x02IF\x10\a\x12\b\n" +
	"\x04ELSE\x10\b\x12\n" +
	"\n" +
	"\x06SWITCH\x10\t\x12\a\n" +
	"\x03TRY\x10\n" +
	"\x12\t\n" +
	"\x05THROW\x10\v\x12\t\n" +
	"\x05MATCH\x10\f\x12\t\n" +
	"\x05YIELD\x10\r*\x82\x06\n" +
	"\bNodeType\x12\x15\n" +
	"\x11UNKNOWN_NODE_TYPE\x10\x00\x12\n" +
	"\n" +
	"\x06METHOD\x10\x01\x12\x11\n" +
	"\rMETHOD_RETURN\x10\x03\x12\x0e\n" +
	"\n" +
	"ANNOTATION\x10\x05\x12\x1f\n" +
	"\x1bANNOTATION_PARAMETER_ASSIGN\x10\x06\x12\x18\n" +
	"\x14ANNOTATION_PARAMETER\x10\a\x12\v\n" +
	"\aLITERAL\x10\b\x12\n" +
	"\n" +
	"\x06MEMBER\x10\t\x12\x15\n" +
	"\x11ARRAY_INITIALIZER\x10\x0e\x12\b\n" +
	"\x04CALL\x10\x0f\x12\t\n" +
	"\x05LOCAL\x10\x17\x12\a\n" +
	"\x03TAG\x10\x18\x12\f\n" +
	"\bLOCATION\x10\x19\x12\x0e\n" +
	"\n" +
	"IDENTIFIER\x10\x1b\x12\n" +
	"\n" +
	"\x06RETURN\x10\x1e\x12\t\n" +
	"\x05BLOCK\x10\x1f\x12\x18\n" +
	"\x14METHOD_PARAMETER_OUT\x10!\x12\x17\n" +
	"\x13METHOD_PARAMETER_IN\x10\"\x12\x0e\n" +
	"\n" +
	"DEPENDENCY\x10#\x12\b\n" +
	"\x04FILE\x10&\x12\r\n" +
	"\tMETA_DATA\x10'\x12\r\n" +
	"\tNAMESPACE\x10(\x12\x13\n" +
	"\x0fNAMESPACE_BLOCK\x10)\x12\v\n" +
	"\aUNKNOWN\x10,\x12\b\n" +
	"\x04TYPE\x10-\x12\r\n" +
	"\tTYPE_DECL\x10.\x12\x12\n" +
	"\x0eTYPE_PARAMETER\x10/\x12\x11\n" +
	"\rTYPE_ARGUMENT\x100\x12\x16\n" +
	"\x12ANNOTATION_LITERAL\x101\x12\x0f\n" +
	"\vCONFIG_FILE\x102\x12\f\n" +
	"\aBINDING\x10\x92\x01\x12\x12\n" +
	"\rTAG_NODE_PAIR\x10\xd0\x01\x12\f\n" +
	"\aFINDING\x10\xd6\x01\x12\x13\n" +
	"\x0eKEY_VALUE_PAIR\x10\xd9\x01\x12\r\n" +
	"\bMODIFIER\x10\xac\x02\x12\x0f\n" +
	"\n" +
	"METHOD_REF\x10\xcd\x02\x12\x14\n" +
	"\x0fCLOSURE_BINDING\x10\xce\x02\x12\r\n" +
	"\bTYPE_REF\x10\xcf\x02\x12\x16\n" +
	"\x11CONTROL_STRUCTURE\x10\xd3\x02\x12\x10\n" +
	"\vJUMP_TARGET\x10\xd4\x02\x12\x0f\n" +
	"\n" +
	"JUMP_LABEL\x10\xd5\x02\x12\x11\n" +
	"\fTEMPLATE_DOM\x10\xa1\x03\x12\f\n" +
	"\aCOMMENT\x10\xff\x03\x12\x16\n" +
	"\x10FIELD_IDENTIFIER\x10\xb9\x91zBH\n" +
	"\x11io.appthreat.atomB\x04AtomZ\x19github.com/AppThreat/atom\xaa\x02\x11io.appthreat.atomb\x06proto3"

var (
	file_atom_proto_rawDescOnce sync.Once
	file_atom_proto_rawDescData []byte
)

func file_atom_proto_rawDescGZIP() []byte {
	file_atom_proto_rawDescOnce.Do(func() {
		file_atom_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_atom_proto_rawDesc), len(file_atom_proto_rawDesc)))
	})
	return file_atom_proto_rawDescData
}

var file_atom_proto_enumTypes = make([]protoimpl.EnumInfo, 10)
var file_atom_proto_msgTypes = make([]protoimpl.MessageInfo, 40)
var file_atom_proto_goTypes = []any{
	(NodePropertyName)(0),                // 0: atom.NodePropertyName
	(EdgePropertyName)(0),                // 1: atom.EdgePropertyName
	(ModifierTypes)(0),                   // 2: atom.ModifierTypes
	(LANGUAGES)(0),                       // 3: atom.LANGUAGES
	(EvaluationStrategies)(0),            // 4: atom.EvaluationStrategies
	(DispatchTypes)(0),                   // 5: atom.DispatchTypes
	(CONTROL_STRUCTURE_TYPES)(0),         // 6: atom.CONTROL_STRUCTURE_TYPES
	(NodeType)(0),                        // 7: atom.NodeType
	(CpgStruct_Edge_EdgeType)(0),         // 8: atom.CpgStruct.Edge.EdgeType
	(UsageSlice_LabelType)(0),            // 9: atom.UsageSlice.LabelType
	(*PropertyValue)(nil),                // 10: atom.PropertyValue
	(*ContainedRefs)(nil),                // 11: atom.ContainedRefs
	(*StringList)(nil),                   // 12: atom.StringList
	(*BoolList)(nil),                     // 13: atom.BoolList
	(*IntList)(nil),                      // 14: atom.IntList
	(*LongList)(nil),                     // 15: atom.LongList
	(*FloatList)(nil),                    // 16: atom.FloatList
	(*DoubleList)(nil),                   // 17: atom.DoubleList
	(*CpgStruct)(nil),                    // 18: atom.CpgStruct
	(*AdditionalNodeProperty)(nil),       // 19: atom.AdditionalNodeProperty
	(*AdditionalEdgeProperty)(nil),       // 20: atom.AdditionalEdgeProperty
	(*CpgOverlay)(nil),                   // 21: atom.CpgOverlay
	(*DiffGraph)(nil),                    // 22: atom.DiffGraph
	(*UsageSlice)(nil),                   // 23: atom.UsageSlice
	(*Nodes)(nil),                        // 24: atom.Nodes
	(*DataFlowSlice)(nil),                // 25: atom.DataFlowSlice
	(*ReachableSlice)(nil),               // 26: atom.ReachableSlice
	(*ReachableSliceList)(nil),           // 27: atom.ReachableSliceList
	(*CpgStruct_Node)(nil),               // 28: atom.CpgStruct.Node
	(*CpgStruct_Edge)(nil),               // 29: atom.CpgStruct.Edge
	(*CpgStruct_Node_Property)(nil),      // 30: atom.CpgStruct.Node.Property
	(*CpgStruct_Edge_Property)(nil),      // 31: atom.CpgStruct.Edge.Property
	(*DiffGraph_RemoveNode)(nil),         // 32: atom.DiffGraph.RemoveNode
	(*DiffGraph_RemoveNodeProperty)(nil), // 33: atom.DiffGraph.RemoveNodeProperty
	(*DiffGraph_RemoveEdge)(nil),         // 34: atom.DiffGraph.RemoveEdge
	(*DiffGraph_RemoveEdgeProperty)(nil), // 35: atom.DiffGraph.RemoveEdgeProperty
	(*DiffGraph_Entry)(nil),              // 36: atom.DiffGraph.Entry
	(*UsageSlice_TargetObj)(nil),         // 37: atom.UsageSlice.TargetObj
	(*UsageSlice_DefinedBy)(nil),         // 38: atom.UsageSlice.DefinedBy
	(*UsageSlice_InvokedCalls)(nil),      // 39: atom.UsageSlice.InvokedCalls
	(*UsageSlice_ArgToCalls)(nil),        // 40: atom.UsageSlice.ArgToCalls
	(*UsageSlice_ObjectUsageSlice)(nil),  // 41: atom.UsageSlice.ObjectUsageSlice
	(*UsageSlice_MethodUsageSlice)(nil),  // 42: atom.UsageSlice.MethodUsageSlice
	(*UsageSlice_Fields)(nil),            // 43: atom.UsageSlice.Fields
	(*UsageSlice_Procedures)(nil),        // 44: atom.UsageSlice.Procedures
	(*UsageSlice_UserDefinedTypes)(nil),  // 45: atom.UsageSlice.UserDefinedTypes
	(*DataFlowSlice_Edges)(nil),          // 46: atom.DataFlowSlice.Edges
	(*DataFlowSlice_Flows)(nil),          // 47: atom.DataFlowSlice.Flows
	(*DataFlowSlice_Paths)(nil),          // 48: atom.DataFlowSlice.Paths
	(*DataFlowSlice_Graph)(nil),          // 49: atom.DataFlowSlice.Graph
}
var file_atom_proto_depIdxs = []int32{
	12, // 0: atom.PropertyValue.string_list:type_name -> atom.StringList
	13, // 1: atom.PropertyValue.bool_list:type_name -> atom.BoolList
	14, // 2: atom.PropertyValue.int_list:type_name -> atom.IntList
	15, // 3: atom.PropertyValue.long_list:type_name -> atom.LongList
	16, // 4: atom.PropertyValue.float_list:type_name -> atom.FloatList
	17, // 5: atom.PropertyValue.double_list:type_name -> atom.DoubleList
	11, // 6: atom.PropertyValue.contained_refs:type_name -> atom.ContainedRefs
	28, // 7: atom.CpgStruct.node:type_name -> atom.CpgStruct.Node
	29, // 8: atom.CpgStruct.edge:type_name -> atom.CpgStruct.Edge
	30, // 9: atom.AdditionalNodeProperty.property:type_name -> atom.CpgStruct.Node.Property
	31, // 10: atom.AdditionalEdgeProperty.property:type_name -> atom.CpgStruct.Edge.Property
	8,  // 11: atom.AdditionalEdgeProperty.edge_type:type_name -> atom.CpgStruct.Edge.EdgeType
	28, // 12: atom.CpgOverlay.node:type_name -> atom.CpgStruct.Node
	29, // 13: atom.CpgOverlay.edge:type_name -> atom.CpgStruct.Edge
	19, // 14: atom.CpgOverlay.node_property:type_name -> atom.AdditionalNodeProperty
	20, // 15: atom.CpgOverlay.edge_property:type_name -> atom.AdditionalEdgeProperty
	36, // 16: atom.DiffGraph.entries:type_name -> atom.DiffGraph.Entry
	42, // 17: atom.UsageSlice.objectSlices:type_name -> atom.UsageSlice.MethodUsageSlice
	45, // 18: atom.UsageSlice.userDefinedTypes:type_name -> atom.UsageSlice.UserDefinedTypes
	7,  // 19: atom.Nodes.label:type_name -> atom.NodeType
	49, // 20: atom.DataFlowSlice.graph:type_name -> atom.DataFlowSlice.Graph
	48, // 21: atom.DataFlowSlice.path:type_name -> atom.DataFlowSlice.Paths
	24, // 22: atom.ReachableSlice.flows:type_name -> atom.Nodes
	26, // 23: atom.ReachableSliceList.slices:type_name -> atom.ReachableSlice
	7,  // 24: atom.CpgStruct.Node.type:type_name -> atom.NodeType
	30, // 25: atom.CpgStruct.Node.property:type_name -> atom.CpgStruct.Node.Property
	8,  // 26: atom.CpgStruct.Edge.type:type_name -> atom.CpgStruct.Edge.EdgeType
	31, // 27: atom.CpgStruct.Edge.property:type_name -> atom.CpgStruct.Edge.Property
	0,  // 28: atom.CpgStruct.Node.Property.name:type_name -> atom.NodePropertyName
	10, // 29: atom.CpgStruct.Node.Property.value:type_name -> atom.PropertyValue
	1,  // 30: atom.CpgStruct.Edge.Property.name:type_name -> atom.EdgePropertyName
	10, // 31: atom.CpgStruct.Edge.Property.value:type_name -> atom.PropertyValue
	0,  // 32: atom.DiffGraph.RemoveNodeProperty.name:type_name -> atom.NodePropertyName
	8,  // 33: atom.DiffGraph.RemoveEdge.edge_type:type_name -> atom.CpgStruct.Edge.EdgeType
	8,  // 34: atom.DiffGraph.RemoveEdgeProperty.edge_type:type_name -> atom.CpgStruct.Edge.EdgeType
	1,  // 35: atom.DiffGraph.RemoveEdgeProperty.property_name:type_name -> atom.EdgePropertyName
	28, // 36: atom.DiffGraph.Entry.node:type_name -> atom.CpgStruct.Node
	29, // 37: atom.DiffGraph.Entry.edge:type_name -> atom.CpgStruct.Edge
	19, // 38: atom.DiffGraph.Entry.node_property:type_name -> atom.AdditionalNodeProperty
	20, // 39: atom.DiffGraph.Entry.edge_property:type_name -> atom.AdditionalEdgeProperty
	32, // 40: atom.DiffGraph.Entry.remove_node:type_name -> atom.DiffGraph.RemoveNode
	33, // 41: atom.DiffGraph.Entry.remove_node_property:type_name -> atom.DiffGraph.RemoveNodeProperty
	34, // 42: atom.DiffGraph.Entry.remove_edge:type_name -> atom.DiffGraph.RemoveEdge
	35, // 43: atom.DiffGraph.Entry.remove_edge_property:type_name -> atom.DiffGraph.RemoveEdgeProperty
	9,  // 44: atom.UsageSlice.TargetObj.label:type_name -> atom.UsageSlice.LabelType
	37, // 45: atom.UsageSlice.ObjectUsageSlice.targetObj:type_name -> atom.UsageSlice.TargetObj
	38, // 46: atom.UsageSlice.ObjectUsageSlice.definedBy:type_name -> atom.UsageSlice.DefinedBy
	39, // 47: atom.UsageSlice.ObjectUsageSlice.invokedCalls:type_name -> atom.UsageSlice.InvokedCalls
	40, // 48: atom.UsageSlice.ObjectUsageSlice.argToCalls:type_name -> atom.UsageSlice.ArgToCalls
	41, // 49: atom.UsageSlice.MethodUsageSlice.usages:type_name -> atom.UsageSlice.ObjectUsageSlice
	9,  // 50: atom.UsageSlice.Fields.label:type_name -> atom.UsageSlice.LabelType
	43, // 51: atom.UsageSlice.UserDefinedTypes.fields:type_name -> atom.UsageSlice.Fields
	44, // 52: atom.UsageSlice.UserDefinedTypes.procedures:type_name -> atom.UsageSlice.Procedures
	8,  // 53: atom.DataFlowSlice.Edges.label:type_name -> atom.CpgStruct.Edge.EdgeType
	47, // 54: atom.DataFlowSlice.Paths.flows:type_name -> atom.DataFlowSlice.Flows
	24, // 55: atom.DataFlowSlice.Graph.nodes:type_name -> atom.Nodes
	46, // 56: atom.DataFlowSlice.Graph.edges:type_name -> atom.DataFlowSlice.Edges
	57, // [57:57] is the sub-list for method output_type
	57, // [57:57] is the sub-list for method input_type
	57, // [57:57] is the sub-list for extension type_name
	57, // [57:57] is the sub-list for extension extendee
	0,  // [0:57] is the sub-list for field type_name
}

func init() { file_atom_proto_init() }
func file_atom_proto_init() {
	if File_atom_proto != nil {
		return
	}
	file_atom_proto_msgTypes[0].OneofWrappers = []any{
		(*PropertyValue_StringValue)(nil),
		(*PropertyValue_BoolValue)(nil),
		(*PropertyValue_IntValue)(nil),
		(*PropertyValue_LongValue)(nil),
		(*PropertyValue_FloatValue)(nil),
		(*PropertyValue_DoubleValue)(nil),
		(*PropertyValue_StringList)(nil),
		(*PropertyValue_BoolList)(nil),
		(*PropertyValue_IntList)(nil),
		(*PropertyValue_LongList)(nil),
		(*PropertyValue_FloatList)(nil),
		(*PropertyValue_DoubleList)(nil),
		(*PropertyValue_ContainedRefs)(nil),
	}
	file_atom_proto_msgTypes[26].OneofWrappers = []any{
		(*DiffGraph_Entry_Node)(nil),
		(*DiffGraph_Entry_Edge)(nil),
		(*DiffGraph_Entry_NodeProperty)(nil),
		(*DiffGraph_Entry_EdgeProperty)(nil),
		(*DiffGraph_Entry_RemoveNode)(nil),
		(*DiffGraph_Entry_RemoveNodeProperty)(nil),
		(*DiffGraph_Entry_RemoveEdge)(nil),
		(*DiffGraph_Entry_RemoveEdgeProperty)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_atom_proto_rawDesc), len(file_atom_proto_rawDesc)),
			NumEnums:      10,
			NumMessages:   40,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_atom_proto_goTypes,
		DependencyIndexes: file_atom_proto_depIdxs,
		EnumInfos:         file_atom_proto_enumTypes,
		MessageInfos:      file_atom_proto_msgTypes,
	}.Build()
	File_atom_proto = out.File
	file_atom_proto_goTypes = nil
	file_atom_proto_depIdxs = nil
}
