# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: atom.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import List

import betterproto


class NodePropertyName(betterproto.Enum):
    UNKNOWN_NODE_PROPERTY = 0
    # This optional field provides the line number of the program
    # constructrepresented by the node.
    LINE_NUMBER = 2
    # AST node type name emitted by parser.
    PARSER_TYPE_NAME = 3
    # This integer indicates the position of the node amongits siblings in the
    # AST. The left-most child has anorder of 0.
    ORDER = 4
    # Name of represented object, e.g., method name (e.g. "run")
    NAME = 5
    # This is the fully-qualified name of an entity, e.g., the fully-
    # qualifiedname of a method or type. The details of what constitutes a fully-
    # qualifiedname are language specific. This field SHOULD be human readable.
    FULL_NAME = 6
    # Indicates that the construct (METHOD or TYPE_DECL) is external, that is,it
    # is referenced but not defined in the code (applies both to insularparsing
    # and to library functions where we have header files only)
    IS_EXTERNAL = 7
    # This property denotes a string value as used in a key-value pair.
    VALUE = 8
    # This optional fields provides the column number of the program
    # constructrepresented by the node.
    COLUMN_NUMBER = 11
    # This optional fields provides the line number at which the program
    # constructrepresented by the node ends.
    LINE_NUMBER_END = 12
    # A version, given as a string. Used, for example, in the META_DATA node
    # toindicate which version of the CPG spec this CPG conforms to
    VERSION = 13
    # For formal method input parameters, output parameters, and return
    # parameters,this field holds the evaluation strategy, which is one of the
    # following:1) `BY_REFERENCE` indicates that the parameter is passed by
    # reference, 2)`BY_VALUE` indicates that it is passed by value, that is, a
    # copy is made,3) `BY_SHARING` the parameter is a pointer/reference and it is
    # shared withthe caller/callee. While a copy of the pointer is made, a copy
    # of the objectthat it points to is not made.
    EVALUATION_STRATEGY = 15
    # This optional fields provides the column number at which the program
    # constructrepresented by the node ends.
    COLUMN_NUMBER_END = 16
    # This field indicates which CPG language frontend generated the CPG.Frontend
    # developers may freely choose a value that describes their frontendso long
    # as it is not used by an existing frontend. Reserved values are to date:C,
    # LLVM, GHIDRA, PHP.
    LANGUAGE = 19
    # Certain files, e.g., configuration files, may be included in the CPG as-
    # is.For such files, the `CONTENT` field contains the files content.
    CONTENT = 20
    # This field holds the code snippet that the node represents.
    CODE = 21
    # The method signature encodes the types of parameters in a string.The string
    # SHOULD be human readable and suitable for differentiating methodswith
    # different parameter types sufficiently to allow for resolving offunction
    # overloading. The present specification does not enforce a strictformat for
    # the signature, that is, it can be chosen by the frontendimplementor to fit
    # the source language.
    SIGNATURE = 22
    # This field holds the dispatch type of a call, which is either
    # `STATIC_DISPATCH` or`DYNAMIC_DISPATCH`. For statically dispatched method
    # calls, the call target is knownat compile time while for dynamically
    # dispatched calls, it can only be determined atruntime as it may depend on
    # the type of an object (as is the case for virtual methodcalls) or
    # calculation of an offset.
    DISPATCH_TYPE = 25
    # The modifier type is a free-form string. The following are known modifier
    # types:`STATIC`, `PUBLIC`, `PROTECTED`, `PRIVATE`, `ABSTRACT`, `NATIVE`,
    # `CONSTRUCTOR`, `VIRTUAL`.
    MODIFIER_TYPE = 26
    # The `CONTROL_STRUCTURE_TYPE` field indicates which kind of control
    # structurea `CONTROL_STRUCTURE` node represents. The available types are the
    # following:BREAK, CONTINUE, DO, WHILE, FOR, GOTO, IF, ELSE, TRY, THROW and
    # SWITCH.
    CONTROL_STRUCTURE_TYPE = 27
    # AST-children of CALL nodes have an argument index, that is used to
    # matchcall-site arguments with callee parameters. Explicit parameters are
    # numberedfrom 1 to N, while index 0 is reserved for implicit self / this
    # parameter.CALLs without implicit parameter therefore have arguments
    # starting with index 1.AST-children of BLOCK nodes may have an argument
    # index as well; in this case,the last argument index determines the return
    # expression of a BLOCK expression.If the `PARAMETER_NAME` field is set, then
    # the `ARGUMENT_INDEX` field isignored. It is suggested to set it to -1.
    ARGUMENT_INDEX = 40
    # Identifier which uniquely describes a CLOSURE_BINDING. This property is
    # used to match captured LOCAL nodes with the corresponding CLOSURE_BINDING
    # nodes
    CLOSURE_BINDING_ID = 50
    # This field contains the fully-qualified static type name of the
    # programconstruct represented by a node. It is the name of an instantiated
    # type, e.g.,`java.util.List<Integer>`, rather than `java.util.List[T]`. If
    # the typecannot be determined, this field should be set to the empty string.
    TYPE_FULL_NAME = 51
    # The static type decl of a TYPE. This property is matched against the
    # FULL_NAMEof TYPE_DECL nodes. It is required to have exactly one TYPE_DECL
    # for eachdifferent TYPE_DECL_FULL_NAME
    TYPE_DECL_FULL_NAME = 52
    # The static types a TYPE_DECL inherits from. This property is matched
    # against theFULL_NAME of TYPE nodes and thus it is required to have at least
    # one TYPE nodefor each TYPE_FULL_NAME
    INHERITS_FROM_TYPE_FULL_NAME = 53
    # The FULL_NAME of a method. Used to link CALL and METHOD nodes. It is
    # requiredto have exactly one METHOD node for each METHOD_FULL_NAME
    METHOD_FULL_NAME = 54
    # The type of the AST parent. Since this is only used in some parts of the
    # graph,the list does not include all possible parents by intention.Possible
    # parents: METHOD, TYPE_DECL, NAMESPACE_BLOCK.
    AST_PARENT_TYPE = 56
    # This field holds the FULL_NAME of the AST parent of an entity.
    AST_PARENT_FULL_NAME = 57
    # The group ID for a dependency
    DEPENDENCY_GROUP_ID = 58
    SYMBOL = 100
    METHOD_SHORT_NAME = 102
    PACKAGE_NAME = 103
    CLASS_NAME = 104
    NODE_LABEL = 105
    # The path of the source file this node was generated from, relative to the
    # rootpath in the meta data node. This field must be set but may be set to
    # the value `<unknown>` toindicate that no source file can be associated with
    # the node, e.g., because the node representsan entity known to exist because
    # it is referenced, but for which the file that is is declared inis unknown.
    FILENAME = 106
    # The field contains the names of the overlays applied to this CPG, in order
    # of theirapplication. Names are free-form strings, that is, this
    # specification does notdictate them but rather requires tool producers and
    # consumers to communicate thembetween each other.
    OVERLAYS = 118
    # This property contains a hash value in the form of a string.Hashes can be
    # used to summarize data, e.g., to summarize thecontents of source files or
    # sub graphs. Such summaries are usefulto determine whether code has already
    # been analyzed in incrementalanalysis pipelines. This property is optional
    # to allow its calculationto be deferred or skipped if the hash is not
    # needed.
    HASH = 120
    # For calls involving named parameters, the `ARGUMENT_NAME` field holds
    # thename of the parameter initialized by the expression. For all other
    # calls,this field is unset.
    ARGUMENT_NAME = 130
    # This property denotes a key of a key-value pair.
    KEY = 131
    CLASS_SHORT_NAME = 132
    # This property holds the fully qualified name of the type that the node isa
    # type alias of.
    ALIAS_TYPE_FULL_NAME = 158
    # The original name of the (potentially mangled) captured variable
    CLOSURE_ORIGINAL_NAME = 159
    # Specifies whether a parameter is the variadic argument handling parameter
    # ofa variadic method. Only one parameter of a method is allowed to have
    # thisproperty set to true.
    IS_VARIADIC = 221
    # The path to the root directory of the source/binary this CPG is generated
    # from.
    ROOT = 1199
    # Type hint for the dynamic type
    DYNAMIC_TYPE_HINT_FULL_NAME = 1591
    # Specifies an index, e.g., for a parameter or argument.Explicit parameters
    # are numbered from 1 to N, while index 0 is reserved for implicitself / this
    # parameter.
    INDEX = 2223
    # This field holds the canonical name of a `FIELD_IDENTIFIER`. It is
    # typicallyidentical to the CODE field, but canonicalized according to source
    # languagesemantics. Human readable names are preferable. `FIELD_IDENTIFIER`
    # nodes mustshare identical `CANONICAL_NAME` if andonly if they alias, e.g.,
    # in C-style unions (if the aliasing relationship isunknown or there are
    # partial overlaps, then one must make a reasonable guess,and trade off
    # between false negatives and false positives).
    CANONICAL_NAME = 2001092
    # References to other nodes. This is not a real property; it exists here for
    # the sake of proto serialization only. valueType and cardinality are
    # meaningless.
    CONTAINED_REF = 2007161


class EdgePropertyName(betterproto.Enum):
    UNKNOWN_EDGE_PROPERTY = 0
    # This edge property represents the variable propagated by a reaching
    # definition edge.
    VARIABLE = 11


class ModifierTypes(betterproto.Enum):
    UNKNOWN_MODIFIER_TYPE = 0
    # The static modifier
    STATIC = 1
    # The public modifier
    PUBLIC = 2
    # The protected modifier
    PROTECTED = 3
    # The private modifier
    PRIVATE = 4
    # The abstract modifier
    ABSTRACT = 5
    # The native modifier
    NATIVE = 6
    # The constructor modifier
    CONSTRUCTOR = 7
    # The virtual modifier
    VIRTUAL = 8
    # The internal modifier
    INTERNAL = 9
    # The final modifier
    FINAL = 10
    # The readonly modifier
    READONLY = 11


class LANGUAGES(betterproto.Enum):
    UNKNOWN_LANGUAGE = 0
    JAVA = 1
    JAVASCRIPT = 2
    GOLANG = 3
    CSHARP = 4
    C = 5
    PYTHON = 6
    LLVM = 7
    PHP = 8
    FUZZY_TEST_LANG = 9
    # generic reverse engineering framework
    GHIDRA = 10
    KOTLIN = 11
    # Eclipse CDT based parser for C/C++
    NEWC = 12
    # Source-based front-end for Java
    JAVASRC = 13
    # Source-based front-end for Python
    PYTHONSRC = 14
    # Source-based JS frontend based on Babel
    JSSRC = 15
    # Solidity language frontend
    SOLIDITY = 16
    # Source-based frontend for Ruby
    RUBYSRC = 17


class EvaluationStrategies(betterproto.Enum):
    UNKNOWN_EVALUATION_STRATEGY = 0
    # A parameter or return of a function is passed by reference which means an
    # address is used behind the scenes
    BY_REFERENCE = 1
    # Only applicable to object parameter or return values. The pointer to the
    # object is passed by value but the object itself is not copied and changes
    # to it are thus propagated out of the method context
    BY_SHARING = 2
    # A parameter or return of a function passed by value which means a flat copy
    # is used
    BY_VALUE = 3


class DispatchTypes(betterproto.Enum):
    UNKNOWN_DISPATCH_TYPE = 0
    # For statically dispatched calls the call target is known before program
    # execution
    STATIC_DISPATCH = 1
    # For dynamically dispatched calls the target is determined during runtime
    DYNAMIC_DISPATCH = 2
    # For macro expansions, code is inlined.
    INLINED = 3


class CONTROL_STRUCTURE_TYPES(betterproto.Enum):
    UNKNOWN_CONTROL_STRUCTURE_TYPE = 0
    # Represents a break statement. Labeled breaks are expected to have a
    # JUMP_LABELnode AST child with ORDER 1
    BREAK = 1
    # Represents a continue statement. Labeled continues are expected to have a
    # JUMP_LABELnode AST child with ORDER 1
    CONTINUE = 2
    # Represents a while statement
    WHILE = 3
    # Represents a do statement
    DO = 4
    # Represents a for statement
    FOR = 5
    # Represents a goto statement
    GOTO = 6
    # Represents an if statement
    IF = 7
    # Represents an else statement
    ELSE = 8
    # Represents a switch statement
    SWITCH = 9
    # Represents a try statement
    TRY = 10
    # Represents a throw statement
    THROW = 11
    # Represents a match expression
    MATCH = 12
    # Represents a yield expression
    YIELD = 13


class CpgStructNodeNodeType(betterproto.Enum):
    UNKNOWN_NODE_TYPE = 0
    METHOD = 1
    METHOD_RETURN = 3
    ANNOTATION = 5
    ANNOTATION_PARAMETER_ASSIGN = 6
    ANNOTATION_PARAMETER = 7
    LITERAL = 8
    MEMBER = 9
    ARRAY_INITIALIZER = 14
    CALL = 15
    LOCAL = 23
    TAG = 24
    LOCATION = 25
    IDENTIFIER = 27
    RETURN = 30
    BLOCK = 31
    METHOD_PARAMETER_OUT = 33
    METHOD_PARAMETER_IN = 34
    DEPENDENCY = 35
    FILE = 38
    META_DATA = 39
    NAMESPACE = 40
    NAMESPACE_BLOCK = 41
    UNKNOWN = 44
    TYPE = 45
    TYPE_DECL = 46
    TYPE_PARAMETER = 47
    TYPE_ARGUMENT = 48
    ANNOTATION_LITERAL = 49
    CONFIG_FILE = 50
    BINDING = 146
    TAG_NODE_PAIR = 208
    FINDING = 214
    KEY_VALUE_PAIR = 217
    MODIFIER = 300
    METHOD_REF = 333
    CLOSURE_BINDING = 334
    TYPE_REF = 335
    CONTROL_STRUCTURE = 339
    JUMP_TARGET = 340
    JUMP_LABEL = 341
    TEMPLATE_DOM = 417
    COMMENT = 511
    FIELD_IDENTIFIER = 2001081


class CpgStructEdgeEdgeType(betterproto.Enum):
    UNKNOWN_EDGE_TYPE = 0
    AST = 3
    CALL = 6
    REF = 10
    TAGGED_BY = 11
    PARAMETER_LINK = 12
    CFG = 19
    EVAL_TYPE = 21
    BINDS_TO = 22
    INHERITS_FROM = 23
    CONTAINS = 28
    CAPTURE = 40
    CAPTURED_BY = 41
    RECEIVER = 55
    CONDITION = 56
    REACHING_DEF = 137
    ALIAS_OF = 138
    BINDS = 155
    ARGUMENT = 156
    SOURCE_FILE = 157
    DOMINATE = 181
    POST_DOMINATE = 182
    CDG = 183
    IMPORTS = 23663
    IS_CALL_FOR_IMPORT = 23664


@dataclass
class PropertyValue(betterproto.Message):
    string_value: str = betterproto.string_field(1, group="value")
    bool_value: bool = betterproto.bool_field(2, group="value")
    int_value: int = betterproto.int32_field(3, group="value")
    long_value: int = betterproto.int64_field(4, group="value")
    float_value: float = betterproto.float_field(5, group="value")
    double_value: float = betterproto.double_field(6, group="value")
    string_list: "StringList" = betterproto.message_field(7, group="value")
    bool_list: "BoolList" = betterproto.message_field(8, group="value")
    int_list: "IntList" = betterproto.message_field(9, group="value")
    long_list: "LongList" = betterproto.message_field(10, group="value")
    float_list: "FloatList" = betterproto.message_field(11, group="value")
    double_list: "DoubleList" = betterproto.message_field(12, group="value")
    contained_refs: "ContainedRefs" = betterproto.message_field(13, group="value")


@dataclass
class ContainedRefs(betterproto.Message):
    local_name: str = betterproto.string_field(1)
    refs: List[int] = betterproto.int64_field(2)


@dataclass
class StringList(betterproto.Message):
    values: List[str] = betterproto.string_field(1)


@dataclass
class BoolList(betterproto.Message):
    values: List[bool] = betterproto.bool_field(1)


@dataclass
class IntList(betterproto.Message):
    values: List[int] = betterproto.int32_field(1)


@dataclass
class LongList(betterproto.Message):
    values: List[int] = betterproto.int64_field(1)


@dataclass
class FloatList(betterproto.Message):
    values: List[float] = betterproto.float_field(1)


@dataclass
class DoubleList(betterproto.Message):
    values: List[float] = betterproto.double_field(1)


@dataclass
class CpgStruct(betterproto.Message):
    node: List["CpgStructNode"] = betterproto.message_field(1)
    edge: List["CpgStructEdge"] = betterproto.message_field(2)


@dataclass
class CpgStructNode(betterproto.Message):
    key: int = betterproto.int64_field(1)
    type: "CpgStructNodeNodeType" = betterproto.enum_field(2)
    property: List["CpgStructNodeProperty"] = betterproto.message_field(3)


@dataclass
class CpgStructNodeProperty(betterproto.Message):
    """Node properties."""

    name: "NodePropertyName" = betterproto.enum_field(1)
    value: "PropertyValue" = betterproto.message_field(2)


@dataclass
class CpgStructEdge(betterproto.Message):
    # Source node.
    src: int = betterproto.int64_field(1)
    # Destination node.
    dst: int = betterproto.int64_field(2)
    type: "CpgStructEdgeEdgeType" = betterproto.enum_field(3)
    property: List["CpgStructEdgeProperty"] = betterproto.message_field(4)


@dataclass
class CpgStructEdgeProperty(betterproto.Message):
    """Edge properties."""

    name: "EdgePropertyName" = betterproto.enum_field(1)
    value: "PropertyValue" = betterproto.message_field(2)


@dataclass
class AdditionalNodeProperty(betterproto.Message):
    node_id: int = betterproto.int64_field(1)
    property: "CpgStructNodeProperty" = betterproto.message_field(2)


@dataclass
class AdditionalEdgeProperty(betterproto.Message):
    edge_id: int = betterproto.int64_field(1)
    property: "CpgStructEdgeProperty" = betterproto.message_field(2)
    out_node_key: int = betterproto.int64_field(3)
    in_node_key: int = betterproto.int64_field(4)
    edge_type: "CpgStructEdgeEdgeType" = betterproto.enum_field(5)


@dataclass
class CpgOverlay(betterproto.Message):
    """
    Overlays can be stacked onto each other, therefor their node ids must be
    globally unique.
    """

    node: List["CpgStructNode"] = betterproto.message_field(1)
    edge: List["CpgStructEdge"] = betterproto.message_field(2)
    node_property: List["AdditionalNodeProperty"] = betterproto.message_field(3)
    edge_property: List["AdditionalEdgeProperty"] = betterproto.message_field(4)


@dataclass
class DiffGraph(betterproto.Message):
    """
    DiffGraphs can be created independently of each other and therefor when
    _adding_ nodes|edges, each DiffGraph has its own ID space. However, when
    removing nodes|edges, the nodeIds refer to the globally unique graph id
    space.
    """

    entries: List["DiffGraphEntry"] = betterproto.message_field(1)


@dataclass
class DiffGraphRemoveNode(betterproto.Message):
    key: int = betterproto.int64_field(1)


@dataclass
class DiffGraphRemoveNodeProperty(betterproto.Message):
    key: int = betterproto.int64_field(1)
    name: "NodePropertyName" = betterproto.enum_field(2)
    local_name: str = betterproto.string_field(3)


@dataclass
class DiffGraphRemoveEdge(betterproto.Message):
    out_node_key: int = betterproto.int64_field(1)
    in_node_key: int = betterproto.int64_field(2)
    edge_type: "CpgStructEdgeEdgeType" = betterproto.enum_field(3)
    properties_hash: bytes = betterproto.bytes_field(4)


@dataclass
class DiffGraphRemoveEdgeProperty(betterproto.Message):
    out_node_key: int = betterproto.int64_field(1)
    in_node_key: int = betterproto.int64_field(2)
    edge_type: "CpgStructEdgeEdgeType" = betterproto.enum_field(3)
    properties_hash: bytes = betterproto.bytes_field(4)
    property_name: "EdgePropertyName" = betterproto.enum_field(5)


@dataclass
class DiffGraphEntry(betterproto.Message):
    node: "CpgStructNode" = betterproto.message_field(1, group="value")
    edge: "CpgStructEdge" = betterproto.message_field(2, group="value")
    node_property: "AdditionalNodeProperty" = betterproto.message_field(
        3, group="value"
    )
    edge_property: "AdditionalEdgeProperty" = betterproto.message_field(
        4, group="value"
    )
    remove_node: "DiffGraphRemoveNode" = betterproto.message_field(5, group="value")
    remove_node_property: "DiffGraphRemoveNodeProperty" = betterproto.message_field(
        6, group="value"
    )
    remove_edge: "DiffGraphRemoveEdge" = betterproto.message_field(7, group="value")
    remove_edge_property: "DiffGraphRemoveEdgeProperty" = betterproto.message_field(
        8, group="value"
    )
