// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `atom.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

///  Message to store the property values such as string or int values
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:atom.PropertyValue)
pub struct PropertyValue {
    // message oneof groups
    pub value: ::std::option::Option<property_value::Value>,
    // special fields
    // @@protoc_insertion_point(special_field:atom.PropertyValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PropertyValue {
    fn default() -> &'a PropertyValue {
        <PropertyValue as ::protobuf::Message>::default_instance()
    }
}

impl PropertyValue {
    pub fn new() -> PropertyValue {
        ::std::default::Default::default()
    }

    // string string_value = 1;

    pub fn string_value(&self) -> &str {
        match self.value {
            ::std::option::Option::Some(property_value::Value::StringValue(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_string_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_string_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(property_value::Value::StringValue(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(property_value::Value::StringValue(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string_value(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(property_value::Value::StringValue(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(property_value::Value::StringValue(::std::string::String::new()));
        }
        match self.value {
            ::std::option::Option::Some(property_value::Value::StringValue(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string_value(&mut self) -> ::std::string::String {
        if self.has_string_value() {
            match self.value.take() {
                ::std::option::Option::Some(property_value::Value::StringValue(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // bool bool_value = 2;

    pub fn bool_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(property_value::Value::BoolValue(v)) => v,
            _ => false,
        }
    }

    pub fn clear_bool_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_bool_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(property_value::Value::BoolValue(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bool_value(&mut self, v: bool) {
        self.value = ::std::option::Option::Some(property_value::Value::BoolValue(v))
    }

    // int32 int_value = 3;

    pub fn int_value(&self) -> i32 {
        match self.value {
            ::std::option::Option::Some(property_value::Value::IntValue(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_int_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_int_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(property_value::Value::IntValue(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int_value(&mut self, v: i32) {
        self.value = ::std::option::Option::Some(property_value::Value::IntValue(v))
    }

    // int64 long_value = 4;

    pub fn long_value(&self) -> i64 {
        match self.value {
            ::std::option::Option::Some(property_value::Value::LongValue(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_long_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_long_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(property_value::Value::LongValue(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_long_value(&mut self, v: i64) {
        self.value = ::std::option::Option::Some(property_value::Value::LongValue(v))
    }

    // float float_value = 5;

    pub fn float_value(&self) -> f32 {
        match self.value {
            ::std::option::Option::Some(property_value::Value::FloatValue(v)) => v,
            _ => 0.,
        }
    }

    pub fn clear_float_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_float_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(property_value::Value::FloatValue(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_float_value(&mut self, v: f32) {
        self.value = ::std::option::Option::Some(property_value::Value::FloatValue(v))
    }

    // double double_value = 6;

    pub fn double_value(&self) -> f64 {
        match self.value {
            ::std::option::Option::Some(property_value::Value::DoubleValue(v)) => v,
            _ => 0.,
        }
    }

    pub fn clear_double_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_double_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(property_value::Value::DoubleValue(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_double_value(&mut self, v: f64) {
        self.value = ::std::option::Option::Some(property_value::Value::DoubleValue(v))
    }

    // .atom.StringList string_list = 7;

    pub fn string_list(&self) -> &StringList {
        match self.value {
            ::std::option::Option::Some(property_value::Value::StringList(ref v)) => v,
            _ => <StringList as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_string_list(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_string_list(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(property_value::Value::StringList(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string_list(&mut self, v: StringList) {
        self.value = ::std::option::Option::Some(property_value::Value::StringList(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string_list(&mut self) -> &mut StringList {
        if let ::std::option::Option::Some(property_value::Value::StringList(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(property_value::Value::StringList(StringList::new()));
        }
        match self.value {
            ::std::option::Option::Some(property_value::Value::StringList(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string_list(&mut self) -> StringList {
        if self.has_string_list() {
            match self.value.take() {
                ::std::option::Option::Some(property_value::Value::StringList(v)) => v,
                _ => panic!(),
            }
        } else {
            StringList::new()
        }
    }

    // .atom.BoolList bool_list = 8;

    pub fn bool_list(&self) -> &BoolList {
        match self.value {
            ::std::option::Option::Some(property_value::Value::BoolList(ref v)) => v,
            _ => <BoolList as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_bool_list(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_bool_list(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(property_value::Value::BoolList(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bool_list(&mut self, v: BoolList) {
        self.value = ::std::option::Option::Some(property_value::Value::BoolList(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bool_list(&mut self) -> &mut BoolList {
        if let ::std::option::Option::Some(property_value::Value::BoolList(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(property_value::Value::BoolList(BoolList::new()));
        }
        match self.value {
            ::std::option::Option::Some(property_value::Value::BoolList(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bool_list(&mut self) -> BoolList {
        if self.has_bool_list() {
            match self.value.take() {
                ::std::option::Option::Some(property_value::Value::BoolList(v)) => v,
                _ => panic!(),
            }
        } else {
            BoolList::new()
        }
    }

    // .atom.IntList int_list = 9;

    pub fn int_list(&self) -> &IntList {
        match self.value {
            ::std::option::Option::Some(property_value::Value::IntList(ref v)) => v,
            _ => <IntList as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_int_list(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_int_list(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(property_value::Value::IntList(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int_list(&mut self, v: IntList) {
        self.value = ::std::option::Option::Some(property_value::Value::IntList(v))
    }

    // Mutable pointer to the field.
    pub fn mut_int_list(&mut self) -> &mut IntList {
        if let ::std::option::Option::Some(property_value::Value::IntList(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(property_value::Value::IntList(IntList::new()));
        }
        match self.value {
            ::std::option::Option::Some(property_value::Value::IntList(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_int_list(&mut self) -> IntList {
        if self.has_int_list() {
            match self.value.take() {
                ::std::option::Option::Some(property_value::Value::IntList(v)) => v,
                _ => panic!(),
            }
        } else {
            IntList::new()
        }
    }

    // .atom.LongList long_list = 10;

    pub fn long_list(&self) -> &LongList {
        match self.value {
            ::std::option::Option::Some(property_value::Value::LongList(ref v)) => v,
            _ => <LongList as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_long_list(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_long_list(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(property_value::Value::LongList(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_long_list(&mut self, v: LongList) {
        self.value = ::std::option::Option::Some(property_value::Value::LongList(v))
    }

    // Mutable pointer to the field.
    pub fn mut_long_list(&mut self) -> &mut LongList {
        if let ::std::option::Option::Some(property_value::Value::LongList(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(property_value::Value::LongList(LongList::new()));
        }
        match self.value {
            ::std::option::Option::Some(property_value::Value::LongList(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_long_list(&mut self) -> LongList {
        if self.has_long_list() {
            match self.value.take() {
                ::std::option::Option::Some(property_value::Value::LongList(v)) => v,
                _ => panic!(),
            }
        } else {
            LongList::new()
        }
    }

    // .atom.FloatList float_list = 11;

    pub fn float_list(&self) -> &FloatList {
        match self.value {
            ::std::option::Option::Some(property_value::Value::FloatList(ref v)) => v,
            _ => <FloatList as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_float_list(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_float_list(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(property_value::Value::FloatList(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_float_list(&mut self, v: FloatList) {
        self.value = ::std::option::Option::Some(property_value::Value::FloatList(v))
    }

    // Mutable pointer to the field.
    pub fn mut_float_list(&mut self) -> &mut FloatList {
        if let ::std::option::Option::Some(property_value::Value::FloatList(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(property_value::Value::FloatList(FloatList::new()));
        }
        match self.value {
            ::std::option::Option::Some(property_value::Value::FloatList(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_float_list(&mut self) -> FloatList {
        if self.has_float_list() {
            match self.value.take() {
                ::std::option::Option::Some(property_value::Value::FloatList(v)) => v,
                _ => panic!(),
            }
        } else {
            FloatList::new()
        }
    }

    // .atom.DoubleList double_list = 12;

    pub fn double_list(&self) -> &DoubleList {
        match self.value {
            ::std::option::Option::Some(property_value::Value::DoubleList(ref v)) => v,
            _ => <DoubleList as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_double_list(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_double_list(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(property_value::Value::DoubleList(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_double_list(&mut self, v: DoubleList) {
        self.value = ::std::option::Option::Some(property_value::Value::DoubleList(v))
    }

    // Mutable pointer to the field.
    pub fn mut_double_list(&mut self) -> &mut DoubleList {
        if let ::std::option::Option::Some(property_value::Value::DoubleList(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(property_value::Value::DoubleList(DoubleList::new()));
        }
        match self.value {
            ::std::option::Option::Some(property_value::Value::DoubleList(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_double_list(&mut self) -> DoubleList {
        if self.has_double_list() {
            match self.value.take() {
                ::std::option::Option::Some(property_value::Value::DoubleList(v)) => v,
                _ => panic!(),
            }
        } else {
            DoubleList::new()
        }
    }

    // .atom.ContainedRefs contained_refs = 13;

    pub fn contained_refs(&self) -> &ContainedRefs {
        match self.value {
            ::std::option::Option::Some(property_value::Value::ContainedRefs(ref v)) => v,
            _ => <ContainedRefs as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_contained_refs(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_contained_refs(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(property_value::Value::ContainedRefs(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_contained_refs(&mut self, v: ContainedRefs) {
        self.value = ::std::option::Option::Some(property_value::Value::ContainedRefs(v))
    }

    // Mutable pointer to the field.
    pub fn mut_contained_refs(&mut self) -> &mut ContainedRefs {
        if let ::std::option::Option::Some(property_value::Value::ContainedRefs(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(property_value::Value::ContainedRefs(ContainedRefs::new()));
        }
        match self.value {
            ::std::option::Option::Some(property_value::Value::ContainedRefs(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_contained_refs(&mut self) -> ContainedRefs {
        if self.has_contained_refs() {
            match self.value.take() {
                ::std::option::Option::Some(property_value::Value::ContainedRefs(v)) => v,
                _ => panic!(),
            }
        } else {
            ContainedRefs::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "string_value",
            PropertyValue::has_string_value,
            PropertyValue::string_value,
            PropertyValue::set_string_value,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "bool_value",
            PropertyValue::has_bool_value,
            PropertyValue::bool_value,
            PropertyValue::set_bool_value,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "int_value",
            PropertyValue::has_int_value,
            PropertyValue::int_value,
            PropertyValue::set_int_value,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "long_value",
            PropertyValue::has_long_value,
            PropertyValue::long_value,
            PropertyValue::set_long_value,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "float_value",
            PropertyValue::has_float_value,
            PropertyValue::float_value,
            PropertyValue::set_float_value,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "double_value",
            PropertyValue::has_double_value,
            PropertyValue::double_value,
            PropertyValue::set_double_value,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, StringList>(
            "string_list",
            PropertyValue::has_string_list,
            PropertyValue::string_list,
            PropertyValue::mut_string_list,
            PropertyValue::set_string_list,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, BoolList>(
            "bool_list",
            PropertyValue::has_bool_list,
            PropertyValue::bool_list,
            PropertyValue::mut_bool_list,
            PropertyValue::set_bool_list,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, IntList>(
            "int_list",
            PropertyValue::has_int_list,
            PropertyValue::int_list,
            PropertyValue::mut_int_list,
            PropertyValue::set_int_list,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, LongList>(
            "long_list",
            PropertyValue::has_long_list,
            PropertyValue::long_list,
            PropertyValue::mut_long_list,
            PropertyValue::set_long_list,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FloatList>(
            "float_list",
            PropertyValue::has_float_list,
            PropertyValue::float_list,
            PropertyValue::mut_float_list,
            PropertyValue::set_float_list,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DoubleList>(
            "double_list",
            PropertyValue::has_double_list,
            PropertyValue::double_list,
            PropertyValue::mut_double_list,
            PropertyValue::set_double_list,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ContainedRefs>(
            "contained_refs",
            PropertyValue::has_contained_refs,
            PropertyValue::contained_refs,
            PropertyValue::mut_contained_refs,
            PropertyValue::set_contained_refs,
        ));
        oneofs.push(property_value::Value::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PropertyValue>(
            "PropertyValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PropertyValue {
    const NAME: &'static str = "PropertyValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.value = ::std::option::Option::Some(property_value::Value::StringValue(is.read_string()?));
                },
                16 => {
                    self.value = ::std::option::Option::Some(property_value::Value::BoolValue(is.read_bool()?));
                },
                24 => {
                    self.value = ::std::option::Option::Some(property_value::Value::IntValue(is.read_int32()?));
                },
                32 => {
                    self.value = ::std::option::Option::Some(property_value::Value::LongValue(is.read_int64()?));
                },
                45 => {
                    self.value = ::std::option::Option::Some(property_value::Value::FloatValue(is.read_float()?));
                },
                49 => {
                    self.value = ::std::option::Option::Some(property_value::Value::DoubleValue(is.read_double()?));
                },
                58 => {
                    self.value = ::std::option::Option::Some(property_value::Value::StringList(is.read_message()?));
                },
                66 => {
                    self.value = ::std::option::Option::Some(property_value::Value::BoolList(is.read_message()?));
                },
                74 => {
                    self.value = ::std::option::Option::Some(property_value::Value::IntList(is.read_message()?));
                },
                82 => {
                    self.value = ::std::option::Option::Some(property_value::Value::LongList(is.read_message()?));
                },
                90 => {
                    self.value = ::std::option::Option::Some(property_value::Value::FloatList(is.read_message()?));
                },
                98 => {
                    self.value = ::std::option::Option::Some(property_value::Value::DoubleList(is.read_message()?));
                },
                106 => {
                    self.value = ::std::option::Option::Some(property_value::Value::ContainedRefs(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &property_value::Value::StringValue(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &property_value::Value::BoolValue(v) => {
                    my_size += 1 + 1;
                },
                &property_value::Value::IntValue(v) => {
                    my_size += ::protobuf::rt::int32_size(3, v);
                },
                &property_value::Value::LongValue(v) => {
                    my_size += ::protobuf::rt::int64_size(4, v);
                },
                &property_value::Value::FloatValue(v) => {
                    my_size += 1 + 4;
                },
                &property_value::Value::DoubleValue(v) => {
                    my_size += 1 + 8;
                },
                &property_value::Value::StringList(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &property_value::Value::BoolList(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &property_value::Value::IntList(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &property_value::Value::LongList(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &property_value::Value::FloatList(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &property_value::Value::DoubleList(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &property_value::Value::ContainedRefs(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &property_value::Value::StringValue(ref v) => {
                    os.write_string(1, v)?;
                },
                &property_value::Value::BoolValue(v) => {
                    os.write_bool(2, v)?;
                },
                &property_value::Value::IntValue(v) => {
                    os.write_int32(3, v)?;
                },
                &property_value::Value::LongValue(v) => {
                    os.write_int64(4, v)?;
                },
                &property_value::Value::FloatValue(v) => {
                    os.write_float(5, v)?;
                },
                &property_value::Value::DoubleValue(v) => {
                    os.write_double(6, v)?;
                },
                &property_value::Value::StringList(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &property_value::Value::BoolList(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &property_value::Value::IntList(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &property_value::Value::LongList(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &property_value::Value::FloatList(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &property_value::Value::DoubleList(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &property_value::Value::ContainedRefs(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PropertyValue {
        PropertyValue::new()
    }

    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PropertyValue {
        static instance: PropertyValue = PropertyValue {
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PropertyValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PropertyValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PropertyValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PropertyValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PropertyValue`
pub mod property_value {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:atom.PropertyValue.value)
    pub enum Value {
        // @@protoc_insertion_point(oneof_field:atom.PropertyValue.string_value)
        StringValue(::std::string::String),
        // @@protoc_insertion_point(oneof_field:atom.PropertyValue.bool_value)
        BoolValue(bool),
        // @@protoc_insertion_point(oneof_field:atom.PropertyValue.int_value)
        IntValue(i32),
        // @@protoc_insertion_point(oneof_field:atom.PropertyValue.long_value)
        LongValue(i64),
        // @@protoc_insertion_point(oneof_field:atom.PropertyValue.float_value)
        FloatValue(f32),
        // @@protoc_insertion_point(oneof_field:atom.PropertyValue.double_value)
        DoubleValue(f64),
        // @@protoc_insertion_point(oneof_field:atom.PropertyValue.string_list)
        StringList(super::StringList),
        // @@protoc_insertion_point(oneof_field:atom.PropertyValue.bool_list)
        BoolList(super::BoolList),
        // @@protoc_insertion_point(oneof_field:atom.PropertyValue.int_list)
        IntList(super::IntList),
        // @@protoc_insertion_point(oneof_field:atom.PropertyValue.long_list)
        LongList(super::LongList),
        // @@protoc_insertion_point(oneof_field:atom.PropertyValue.float_list)
        FloatList(super::FloatList),
        // @@protoc_insertion_point(oneof_field:atom.PropertyValue.double_list)
        DoubleList(super::DoubleList),
        // @@protoc_insertion_point(oneof_field:atom.PropertyValue.contained_refs)
        ContainedRefs(super::ContainedRefs),
    }

    impl ::protobuf::Oneof for Value {
    }

    impl ::protobuf::OneofFull for Value {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::PropertyValue as ::protobuf::MessageFull>::descriptor().oneof_by_name("value").unwrap()).clone()
        }
    }

    impl Value {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Value>("value")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:atom.ContainedRefs)
pub struct ContainedRefs {
    // message fields
    // @@protoc_insertion_point(field:atom.ContainedRefs.local_name)
    pub local_name: ::std::string::String,
    // @@protoc_insertion_point(field:atom.ContainedRefs.refs)
    pub refs: ::std::vec::Vec<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:atom.ContainedRefs.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ContainedRefs {
    fn default() -> &'a ContainedRefs {
        <ContainedRefs as ::protobuf::Message>::default_instance()
    }
}

impl ContainedRefs {
    pub fn new() -> ContainedRefs {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "local_name",
            |m: &ContainedRefs| { &m.local_name },
            |m: &mut ContainedRefs| { &mut m.local_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "refs",
            |m: &ContainedRefs| { &m.refs },
            |m: &mut ContainedRefs| { &mut m.refs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContainedRefs>(
            "ContainedRefs",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ContainedRefs {
    const NAME: &'static str = "ContainedRefs";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.local_name = is.read_string()?;
                },
                18 => {
                    is.read_repeated_packed_int64_into(&mut self.refs)?;
                },
                16 => {
                    self.refs.push(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.local_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.local_name);
        }
        for value in &self.refs {
            my_size += ::protobuf::rt::int64_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.local_name.is_empty() {
            os.write_string(1, &self.local_name)?;
        }
        for v in &self.refs {
            os.write_int64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ContainedRefs {
        ContainedRefs::new()
    }

    fn clear(&mut self) {
        self.local_name.clear();
        self.refs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ContainedRefs {
        static instance: ContainedRefs = ContainedRefs {
            local_name: ::std::string::String::new(),
            refs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ContainedRefs {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ContainedRefs").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ContainedRefs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainedRefs {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:atom.StringList)
pub struct StringList {
    // message fields
    // @@protoc_insertion_point(field:atom.StringList.values)
    pub values: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:atom.StringList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StringList {
    fn default() -> &'a StringList {
        <StringList as ::protobuf::Message>::default_instance()
    }
}

impl StringList {
    pub fn new() -> StringList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "values",
            |m: &StringList| { &m.values },
            |m: &mut StringList| { &mut m.values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StringList>(
            "StringList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StringList {
    const NAME: &'static str = "StringList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.values.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.values {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.values {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StringList {
        StringList::new()
    }

    fn clear(&mut self) {
        self.values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StringList {
        static instance: StringList = StringList {
            values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StringList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StringList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StringList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:atom.BoolList)
pub struct BoolList {
    // message fields
    // @@protoc_insertion_point(field:atom.BoolList.values)
    pub values: ::std::vec::Vec<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:atom.BoolList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BoolList {
    fn default() -> &'a BoolList {
        <BoolList as ::protobuf::Message>::default_instance()
    }
}

impl BoolList {
    pub fn new() -> BoolList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "values",
            |m: &BoolList| { &m.values },
            |m: &mut BoolList| { &mut m.values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BoolList>(
            "BoolList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BoolList {
    const NAME: &'static str = "BoolList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_bool_into(&mut self.values)?;
                },
                8 => {
                    self.values.push(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 2 * self.values.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.values {
            os.write_bool(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BoolList {
        BoolList::new()
    }

    fn clear(&mut self) {
        self.values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BoolList {
        static instance: BoolList = BoolList {
            values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BoolList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BoolList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BoolList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BoolList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:atom.IntList)
pub struct IntList {
    // message fields
    // @@protoc_insertion_point(field:atom.IntList.values)
    pub values: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:atom.IntList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IntList {
    fn default() -> &'a IntList {
        <IntList as ::protobuf::Message>::default_instance()
    }
}

impl IntList {
    pub fn new() -> IntList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "values",
            |m: &IntList| { &m.values },
            |m: &mut IntList| { &mut m.values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IntList>(
            "IntList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IntList {
    const NAME: &'static str = "IntList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int32_into(&mut self.values)?;
                },
                8 => {
                    self.values.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.values {
            my_size += ::protobuf::rt::int32_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.values {
            os.write_int32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IntList {
        IntList::new()
    }

    fn clear(&mut self) {
        self.values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IntList {
        static instance: IntList = IntList {
            values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IntList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IntList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IntList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IntList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:atom.LongList)
pub struct LongList {
    // message fields
    // @@protoc_insertion_point(field:atom.LongList.values)
    pub values: ::std::vec::Vec<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:atom.LongList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LongList {
    fn default() -> &'a LongList {
        <LongList as ::protobuf::Message>::default_instance()
    }
}

impl LongList {
    pub fn new() -> LongList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "values",
            |m: &LongList| { &m.values },
            |m: &mut LongList| { &mut m.values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LongList>(
            "LongList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LongList {
    const NAME: &'static str = "LongList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int64_into(&mut self.values)?;
                },
                8 => {
                    self.values.push(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.values {
            my_size += ::protobuf::rt::int64_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.values {
            os.write_int64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LongList {
        LongList::new()
    }

    fn clear(&mut self) {
        self.values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LongList {
        static instance: LongList = LongList {
            values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LongList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LongList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LongList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LongList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:atom.FloatList)
pub struct FloatList {
    // message fields
    // @@protoc_insertion_point(field:atom.FloatList.values)
    pub values: ::std::vec::Vec<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:atom.FloatList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FloatList {
    fn default() -> &'a FloatList {
        <FloatList as ::protobuf::Message>::default_instance()
    }
}

impl FloatList {
    pub fn new() -> FloatList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "values",
            |m: &FloatList| { &m.values },
            |m: &mut FloatList| { &mut m.values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FloatList>(
            "FloatList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FloatList {
    const NAME: &'static str = "FloatList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_float_into(&mut self.values)?;
                },
                13 => {
                    self.values.push(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 5 * self.values.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.values {
            os.write_float(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FloatList {
        FloatList::new()
    }

    fn clear(&mut self) {
        self.values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FloatList {
        static instance: FloatList = FloatList {
            values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FloatList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FloatList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FloatList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FloatList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:atom.DoubleList)
pub struct DoubleList {
    // message fields
    // @@protoc_insertion_point(field:atom.DoubleList.values)
    pub values: ::std::vec::Vec<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:atom.DoubleList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DoubleList {
    fn default() -> &'a DoubleList {
        <DoubleList as ::protobuf::Message>::default_instance()
    }
}

impl DoubleList {
    pub fn new() -> DoubleList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "values",
            |m: &DoubleList| { &m.values },
            |m: &mut DoubleList| { &mut m.values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DoubleList>(
            "DoubleList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DoubleList {
    const NAME: &'static str = "DoubleList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_double_into(&mut self.values)?;
                },
                9 => {
                    self.values.push(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 9 * self.values.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.values {
            os.write_double(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DoubleList {
        DoubleList::new()
    }

    fn clear(&mut self) {
        self.values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DoubleList {
        static instance: DoubleList = DoubleList {
            values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DoubleList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DoubleList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DoubleList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DoubleList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:atom.CpgStruct)
pub struct CpgStruct {
    // message fields
    // @@protoc_insertion_point(field:atom.CpgStruct.node)
    pub node: ::std::vec::Vec<cpg_struct::Node>,
    // @@protoc_insertion_point(field:atom.CpgStruct.edge)
    pub edge: ::std::vec::Vec<cpg_struct::Edge>,
    // special fields
    // @@protoc_insertion_point(special_field:atom.CpgStruct.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CpgStruct {
    fn default() -> &'a CpgStruct {
        <CpgStruct as ::protobuf::Message>::default_instance()
    }
}

impl CpgStruct {
    pub fn new() -> CpgStruct {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "node",
            |m: &CpgStruct| { &m.node },
            |m: &mut CpgStruct| { &mut m.node },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "edge",
            |m: &CpgStruct| { &m.edge },
            |m: &mut CpgStruct| { &mut m.edge },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CpgStruct>(
            "CpgStruct",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CpgStruct {
    const NAME: &'static str = "CpgStruct";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.node.push(is.read_message()?);
                },
                18 => {
                    self.edge.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.node {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.edge {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.node {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.edge {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CpgStruct {
        CpgStruct::new()
    }

    fn clear(&mut self) {
        self.node.clear();
        self.edge.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CpgStruct {
        static instance: CpgStruct = CpgStruct {
            node: ::std::vec::Vec::new(),
            edge: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CpgStruct {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CpgStruct").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CpgStruct {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CpgStruct {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CpgStruct`
pub mod cpg_struct {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:atom.CpgStruct.Node)
    pub struct Node {
        // message fields
        // @@protoc_insertion_point(field:atom.CpgStruct.Node.key)
        pub key: i64,
        // @@protoc_insertion_point(field:atom.CpgStruct.Node.type)
        pub type_: ::protobuf::EnumOrUnknown<super::NodeType>,
        // @@protoc_insertion_point(field:atom.CpgStruct.Node.property)
        pub property: ::std::vec::Vec<node::Property>,
        // special fields
        // @@protoc_insertion_point(special_field:atom.CpgStruct.Node.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Node {
        fn default() -> &'a Node {
            <Node as ::protobuf::Message>::default_instance()
        }
    }

    impl Node {
        pub fn new() -> Node {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "key",
                |m: &Node| { &m.key },
                |m: &mut Node| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "type",
                |m: &Node| { &m.type_ },
                |m: &mut Node| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "property",
                |m: &Node| { &m.property },
                |m: &mut Node| { &mut m.property },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Node>(
                "CpgStruct.Node",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Node {
        const NAME: &'static str = "Node";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.key = is.read_int64()?;
                    },
                    16 => {
                        self.type_ = is.read_enum_or_unknown()?;
                    },
                    26 => {
                        self.property.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.key != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.key);
            }
            if self.type_ != ::protobuf::EnumOrUnknown::new(super::NodeType::UNKNOWN_NODE_TYPE) {
                my_size += ::protobuf::rt::int32_size(2, self.type_.value());
            }
            for value in &self.property {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.key != 0 {
                os.write_int64(1, self.key)?;
            }
            if self.type_ != ::protobuf::EnumOrUnknown::new(super::NodeType::UNKNOWN_NODE_TYPE) {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.type_))?;
            }
            for v in &self.property {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Node {
            Node::new()
        }

        fn clear(&mut self) {
            self.key = 0;
            self.type_ = ::protobuf::EnumOrUnknown::new(super::NodeType::UNKNOWN_NODE_TYPE);
            self.property.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Node {
            static instance: Node = Node {
                key: 0,
                type_: ::protobuf::EnumOrUnknown::from_i32(0),
                property: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Node {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CpgStruct.Node").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Node {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Node {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Node`
    pub mod node {
        ///  Node properties.
        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:atom.CpgStruct.Node.Property)
        pub struct Property {
            // message fields
            // @@protoc_insertion_point(field:atom.CpgStruct.Node.Property.name)
            pub name: ::protobuf::EnumOrUnknown<super::super::NodePropertyName>,
            // @@protoc_insertion_point(field:atom.CpgStruct.Node.Property.value)
            pub value: ::protobuf::MessageField<super::super::PropertyValue>,
            // special fields
            // @@protoc_insertion_point(special_field:atom.CpgStruct.Node.Property.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Property {
            fn default() -> &'a Property {
                <Property as ::protobuf::Message>::default_instance()
            }
        }

        impl Property {
            pub fn new() -> Property {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "name",
                    |m: &Property| { &m.name },
                    |m: &mut Property| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::PropertyValue>(
                    "value",
                    |m: &Property| { &m.value },
                    |m: &mut Property| { &mut m.value },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Property>(
                    "CpgStruct.Node.Property",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Property {
            const NAME: &'static str = "Property";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.name = is.read_enum_or_unknown()?;
                        },
                        18 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.value)?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.name != ::protobuf::EnumOrUnknown::new(super::super::NodePropertyName::UNKNOWN_NODE_PROPERTY) {
                    my_size += ::protobuf::rt::int32_size(1, self.name.value());
                }
                if let Some(v) = self.value.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.name != ::protobuf::EnumOrUnknown::new(super::super::NodePropertyName::UNKNOWN_NODE_PROPERTY) {
                    os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.name))?;
                }
                if let Some(v) = self.value.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Property {
                Property::new()
            }

            fn clear(&mut self) {
                self.name = ::protobuf::EnumOrUnknown::new(super::super::NodePropertyName::UNKNOWN_NODE_PROPERTY);
                self.value.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Property {
                static instance: Property = Property {
                    name: ::protobuf::EnumOrUnknown::from_i32(0),
                    value: ::protobuf::MessageField::none(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Property {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CpgStruct.Node.Property").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Property {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Property {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    ///  Represents a directed edge of a graph
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:atom.CpgStruct.Edge)
    pub struct Edge {
        // message fields
        ///  Source node.
        // @@protoc_insertion_point(field:atom.CpgStruct.Edge.src)
        pub src: i64,
        ///  Destination node.
        // @@protoc_insertion_point(field:atom.CpgStruct.Edge.dst)
        pub dst: i64,
        // @@protoc_insertion_point(field:atom.CpgStruct.Edge.type)
        pub type_: ::protobuf::EnumOrUnknown<edge::EdgeType>,
        // @@protoc_insertion_point(field:atom.CpgStruct.Edge.property)
        pub property: ::std::vec::Vec<edge::Property>,
        // special fields
        // @@protoc_insertion_point(special_field:atom.CpgStruct.Edge.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Edge {
        fn default() -> &'a Edge {
            <Edge as ::protobuf::Message>::default_instance()
        }
    }

    impl Edge {
        pub fn new() -> Edge {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "src",
                |m: &Edge| { &m.src },
                |m: &mut Edge| { &mut m.src },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "dst",
                |m: &Edge| { &m.dst },
                |m: &mut Edge| { &mut m.dst },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "type",
                |m: &Edge| { &m.type_ },
                |m: &mut Edge| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "property",
                |m: &Edge| { &m.property },
                |m: &mut Edge| { &mut m.property },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Edge>(
                "CpgStruct.Edge",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Edge {
        const NAME: &'static str = "Edge";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.src = is.read_int64()?;
                    },
                    16 => {
                        self.dst = is.read_int64()?;
                    },
                    24 => {
                        self.type_ = is.read_enum_or_unknown()?;
                    },
                    34 => {
                        self.property.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.src != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.src);
            }
            if self.dst != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.dst);
            }
            if self.type_ != ::protobuf::EnumOrUnknown::new(edge::EdgeType::UNKNOWN_EDGE_TYPE) {
                my_size += ::protobuf::rt::int32_size(3, self.type_.value());
            }
            for value in &self.property {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.src != 0 {
                os.write_int64(1, self.src)?;
            }
            if self.dst != 0 {
                os.write_int64(2, self.dst)?;
            }
            if self.type_ != ::protobuf::EnumOrUnknown::new(edge::EdgeType::UNKNOWN_EDGE_TYPE) {
                os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.type_))?;
            }
            for v in &self.property {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Edge {
            Edge::new()
        }

        fn clear(&mut self) {
            self.src = 0;
            self.dst = 0;
            self.type_ = ::protobuf::EnumOrUnknown::new(edge::EdgeType::UNKNOWN_EDGE_TYPE);
            self.property.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Edge {
            static instance: Edge = Edge {
                src: 0,
                dst: 0,
                type_: ::protobuf::EnumOrUnknown::from_i32(0),
                property: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Edge {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CpgStruct.Edge").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Edge {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Edge {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Edge`
    pub mod edge {
        ///  Edge properties.
        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:atom.CpgStruct.Edge.Property)
        pub struct Property {
            // message fields
            // @@protoc_insertion_point(field:atom.CpgStruct.Edge.Property.name)
            pub name: ::protobuf::EnumOrUnknown<super::super::EdgePropertyName>,
            // @@protoc_insertion_point(field:atom.CpgStruct.Edge.Property.value)
            pub value: ::protobuf::MessageField<super::super::PropertyValue>,
            // special fields
            // @@protoc_insertion_point(special_field:atom.CpgStruct.Edge.Property.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Property {
            fn default() -> &'a Property {
                <Property as ::protobuf::Message>::default_instance()
            }
        }

        impl Property {
            pub fn new() -> Property {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "name",
                    |m: &Property| { &m.name },
                    |m: &mut Property| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::PropertyValue>(
                    "value",
                    |m: &Property| { &m.value },
                    |m: &mut Property| { &mut m.value },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Property>(
                    "CpgStruct.Edge.Property",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Property {
            const NAME: &'static str = "Property";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.name = is.read_enum_or_unknown()?;
                        },
                        18 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.value)?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.name != ::protobuf::EnumOrUnknown::new(super::super::EdgePropertyName::UNKNOWN_EDGE_PROPERTY) {
                    my_size += ::protobuf::rt::int32_size(1, self.name.value());
                }
                if let Some(v) = self.value.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.name != ::protobuf::EnumOrUnknown::new(super::super::EdgePropertyName::UNKNOWN_EDGE_PROPERTY) {
                    os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.name))?;
                }
                if let Some(v) = self.value.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Property {
                Property::new()
            }

            fn clear(&mut self) {
                self.name = ::protobuf::EnumOrUnknown::new(super::super::EdgePropertyName::UNKNOWN_EDGE_PROPERTY);
                self.value.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Property {
                static instance: Property = Property {
                    name: ::protobuf::EnumOrUnknown::from_i32(0),
                    value: ::protobuf::MessageField::none(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Property {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CpgStruct.Edge.Property").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Property {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Property {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        ///  Edge type.
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:atom.CpgStruct.Edge.EdgeType)
        pub enum EdgeType {
            // @@protoc_insertion_point(enum_value:atom.CpgStruct.Edge.EdgeType.UNKNOWN_EDGE_TYPE)
            UNKNOWN_EDGE_TYPE = 0,
            // @@protoc_insertion_point(enum_value:atom.CpgStruct.Edge.EdgeType.AST)
            AST = 3,
            // @@protoc_insertion_point(enum_value:atom.CpgStruct.Edge.EdgeType.CALL)
            CALL = 6,
            // @@protoc_insertion_point(enum_value:atom.CpgStruct.Edge.EdgeType.REF)
            REF = 10,
            // @@protoc_insertion_point(enum_value:atom.CpgStruct.Edge.EdgeType.TAGGED_BY)
            TAGGED_BY = 11,
            // @@protoc_insertion_point(enum_value:atom.CpgStruct.Edge.EdgeType.PARAMETER_LINK)
            PARAMETER_LINK = 12,
            // @@protoc_insertion_point(enum_value:atom.CpgStruct.Edge.EdgeType.CFG)
            CFG = 19,
            // @@protoc_insertion_point(enum_value:atom.CpgStruct.Edge.EdgeType.EVAL_TYPE)
            EVAL_TYPE = 21,
            // @@protoc_insertion_point(enum_value:atom.CpgStruct.Edge.EdgeType.BINDS_TO)
            BINDS_TO = 22,
            // @@protoc_insertion_point(enum_value:atom.CpgStruct.Edge.EdgeType.INHERITS_FROM)
            INHERITS_FROM = 23,
            // @@protoc_insertion_point(enum_value:atom.CpgStruct.Edge.EdgeType.CONTAINS)
            CONTAINS = 28,
            // @@protoc_insertion_point(enum_value:atom.CpgStruct.Edge.EdgeType.CAPTURE)
            CAPTURE = 40,
            // @@protoc_insertion_point(enum_value:atom.CpgStruct.Edge.EdgeType.CAPTURED_BY)
            CAPTURED_BY = 41,
            // @@protoc_insertion_point(enum_value:atom.CpgStruct.Edge.EdgeType.RECEIVER)
            RECEIVER = 55,
            // @@protoc_insertion_point(enum_value:atom.CpgStruct.Edge.EdgeType.CONDITION)
            CONDITION = 56,
            // @@protoc_insertion_point(enum_value:atom.CpgStruct.Edge.EdgeType.REACHING_DEF)
            REACHING_DEF = 137,
            // @@protoc_insertion_point(enum_value:atom.CpgStruct.Edge.EdgeType.ALIAS_OF)
            ALIAS_OF = 138,
            // @@protoc_insertion_point(enum_value:atom.CpgStruct.Edge.EdgeType.BINDS)
            BINDS = 155,
            // @@protoc_insertion_point(enum_value:atom.CpgStruct.Edge.EdgeType.ARGUMENT)
            ARGUMENT = 156,
            // @@protoc_insertion_point(enum_value:atom.CpgStruct.Edge.EdgeType.SOURCE_FILE)
            SOURCE_FILE = 157,
            // @@protoc_insertion_point(enum_value:atom.CpgStruct.Edge.EdgeType.DOMINATE)
            DOMINATE = 181,
            // @@protoc_insertion_point(enum_value:atom.CpgStruct.Edge.EdgeType.POST_DOMINATE)
            POST_DOMINATE = 182,
            // @@protoc_insertion_point(enum_value:atom.CpgStruct.Edge.EdgeType.CDG)
            CDG = 183,
            // @@protoc_insertion_point(enum_value:atom.CpgStruct.Edge.EdgeType.IMPORTS)
            IMPORTS = 23663,
            // @@protoc_insertion_point(enum_value:atom.CpgStruct.Edge.EdgeType.IS_CALL_FOR_IMPORT)
            IS_CALL_FOR_IMPORT = 23664,
        }

        impl ::protobuf::Enum for EdgeType {
            const NAME: &'static str = "EdgeType";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<EdgeType> {
                match value {
                    0 => ::std::option::Option::Some(EdgeType::UNKNOWN_EDGE_TYPE),
                    3 => ::std::option::Option::Some(EdgeType::AST),
                    6 => ::std::option::Option::Some(EdgeType::CALL),
                    10 => ::std::option::Option::Some(EdgeType::REF),
                    11 => ::std::option::Option::Some(EdgeType::TAGGED_BY),
                    12 => ::std::option::Option::Some(EdgeType::PARAMETER_LINK),
                    19 => ::std::option::Option::Some(EdgeType::CFG),
                    21 => ::std::option::Option::Some(EdgeType::EVAL_TYPE),
                    22 => ::std::option::Option::Some(EdgeType::BINDS_TO),
                    23 => ::std::option::Option::Some(EdgeType::INHERITS_FROM),
                    28 => ::std::option::Option::Some(EdgeType::CONTAINS),
                    40 => ::std::option::Option::Some(EdgeType::CAPTURE),
                    41 => ::std::option::Option::Some(EdgeType::CAPTURED_BY),
                    55 => ::std::option::Option::Some(EdgeType::RECEIVER),
                    56 => ::std::option::Option::Some(EdgeType::CONDITION),
                    137 => ::std::option::Option::Some(EdgeType::REACHING_DEF),
                    138 => ::std::option::Option::Some(EdgeType::ALIAS_OF),
                    155 => ::std::option::Option::Some(EdgeType::BINDS),
                    156 => ::std::option::Option::Some(EdgeType::ARGUMENT),
                    157 => ::std::option::Option::Some(EdgeType::SOURCE_FILE),
                    181 => ::std::option::Option::Some(EdgeType::DOMINATE),
                    182 => ::std::option::Option::Some(EdgeType::POST_DOMINATE),
                    183 => ::std::option::Option::Some(EdgeType::CDG),
                    23663 => ::std::option::Option::Some(EdgeType::IMPORTS),
                    23664 => ::std::option::Option::Some(EdgeType::IS_CALL_FOR_IMPORT),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [EdgeType] = &[
                EdgeType::UNKNOWN_EDGE_TYPE,
                EdgeType::AST,
                EdgeType::CALL,
                EdgeType::REF,
                EdgeType::TAGGED_BY,
                EdgeType::PARAMETER_LINK,
                EdgeType::CFG,
                EdgeType::EVAL_TYPE,
                EdgeType::BINDS_TO,
                EdgeType::INHERITS_FROM,
                EdgeType::CONTAINS,
                EdgeType::CAPTURE,
                EdgeType::CAPTURED_BY,
                EdgeType::RECEIVER,
                EdgeType::CONDITION,
                EdgeType::REACHING_DEF,
                EdgeType::ALIAS_OF,
                EdgeType::BINDS,
                EdgeType::ARGUMENT,
                EdgeType::SOURCE_FILE,
                EdgeType::DOMINATE,
                EdgeType::POST_DOMINATE,
                EdgeType::CDG,
                EdgeType::IMPORTS,
                EdgeType::IS_CALL_FOR_IMPORT,
            ];
        }

        impl ::protobuf::EnumFull for EdgeType {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("CpgStruct.Edge.EdgeType").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = match self {
                    EdgeType::UNKNOWN_EDGE_TYPE => 0,
                    EdgeType::AST => 1,
                    EdgeType::CALL => 2,
                    EdgeType::REF => 3,
                    EdgeType::TAGGED_BY => 4,
                    EdgeType::PARAMETER_LINK => 5,
                    EdgeType::CFG => 6,
                    EdgeType::EVAL_TYPE => 7,
                    EdgeType::BINDS_TO => 8,
                    EdgeType::INHERITS_FROM => 9,
                    EdgeType::CONTAINS => 10,
                    EdgeType::CAPTURE => 11,
                    EdgeType::CAPTURED_BY => 12,
                    EdgeType::RECEIVER => 13,
                    EdgeType::CONDITION => 14,
                    EdgeType::REACHING_DEF => 15,
                    EdgeType::ALIAS_OF => 16,
                    EdgeType::BINDS => 17,
                    EdgeType::ARGUMENT => 18,
                    EdgeType::SOURCE_FILE => 19,
                    EdgeType::DOMINATE => 20,
                    EdgeType::POST_DOMINATE => 21,
                    EdgeType::CDG => 22,
                    EdgeType::IMPORTS => 23,
                    EdgeType::IS_CALL_FOR_IMPORT => 24,
                };
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for EdgeType {
            fn default() -> Self {
                EdgeType::UNKNOWN_EDGE_TYPE
            }
        }

        impl EdgeType {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EdgeType>("CpgStruct.Edge.EdgeType")
            }
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:atom.AdditionalNodeProperty)
pub struct AdditionalNodeProperty {
    // message fields
    // @@protoc_insertion_point(field:atom.AdditionalNodeProperty.node_id)
    pub node_id: i64,
    // @@protoc_insertion_point(field:atom.AdditionalNodeProperty.property)
    pub property: ::protobuf::MessageField<cpg_struct::node::Property>,
    // special fields
    // @@protoc_insertion_point(special_field:atom.AdditionalNodeProperty.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AdditionalNodeProperty {
    fn default() -> &'a AdditionalNodeProperty {
        <AdditionalNodeProperty as ::protobuf::Message>::default_instance()
    }
}

impl AdditionalNodeProperty {
    pub fn new() -> AdditionalNodeProperty {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "node_id",
            |m: &AdditionalNodeProperty| { &m.node_id },
            |m: &mut AdditionalNodeProperty| { &mut m.node_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cpg_struct::node::Property>(
            "property",
            |m: &AdditionalNodeProperty| { &m.property },
            |m: &mut AdditionalNodeProperty| { &mut m.property },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AdditionalNodeProperty>(
            "AdditionalNodeProperty",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AdditionalNodeProperty {
    const NAME: &'static str = "AdditionalNodeProperty";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.node_id = is.read_int64()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.property)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.node_id != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.node_id);
        }
        if let Some(v) = self.property.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.node_id != 0 {
            os.write_int64(1, self.node_id)?;
        }
        if let Some(v) = self.property.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AdditionalNodeProperty {
        AdditionalNodeProperty::new()
    }

    fn clear(&mut self) {
        self.node_id = 0;
        self.property.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AdditionalNodeProperty {
        static instance: AdditionalNodeProperty = AdditionalNodeProperty {
            node_id: 0,
            property: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AdditionalNodeProperty {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AdditionalNodeProperty").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AdditionalNodeProperty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AdditionalNodeProperty {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:atom.AdditionalEdgeProperty)
pub struct AdditionalEdgeProperty {
    // message fields
    // @@protoc_insertion_point(field:atom.AdditionalEdgeProperty.edge_id)
    pub edge_id: i64,
    // @@protoc_insertion_point(field:atom.AdditionalEdgeProperty.property)
    pub property: ::protobuf::MessageField<cpg_struct::edge::Property>,
    // @@protoc_insertion_point(field:atom.AdditionalEdgeProperty.out_node_key)
    pub out_node_key: i64,
    // @@protoc_insertion_point(field:atom.AdditionalEdgeProperty.in_node_key)
    pub in_node_key: i64,
    // @@protoc_insertion_point(field:atom.AdditionalEdgeProperty.edge_type)
    pub edge_type: ::protobuf::EnumOrUnknown<cpg_struct::edge::EdgeType>,
    // special fields
    // @@protoc_insertion_point(special_field:atom.AdditionalEdgeProperty.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AdditionalEdgeProperty {
    fn default() -> &'a AdditionalEdgeProperty {
        <AdditionalEdgeProperty as ::protobuf::Message>::default_instance()
    }
}

impl AdditionalEdgeProperty {
    pub fn new() -> AdditionalEdgeProperty {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "edge_id",
            |m: &AdditionalEdgeProperty| { &m.edge_id },
            |m: &mut AdditionalEdgeProperty| { &mut m.edge_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cpg_struct::edge::Property>(
            "property",
            |m: &AdditionalEdgeProperty| { &m.property },
            |m: &mut AdditionalEdgeProperty| { &mut m.property },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "out_node_key",
            |m: &AdditionalEdgeProperty| { &m.out_node_key },
            |m: &mut AdditionalEdgeProperty| { &mut m.out_node_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "in_node_key",
            |m: &AdditionalEdgeProperty| { &m.in_node_key },
            |m: &mut AdditionalEdgeProperty| { &mut m.in_node_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "edge_type",
            |m: &AdditionalEdgeProperty| { &m.edge_type },
            |m: &mut AdditionalEdgeProperty| { &mut m.edge_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AdditionalEdgeProperty>(
            "AdditionalEdgeProperty",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AdditionalEdgeProperty {
    const NAME: &'static str = "AdditionalEdgeProperty";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.edge_id = is.read_int64()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.property)?;
                },
                24 => {
                    self.out_node_key = is.read_int64()?;
                },
                32 => {
                    self.in_node_key = is.read_int64()?;
                },
                40 => {
                    self.edge_type = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.edge_id != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.edge_id);
        }
        if let Some(v) = self.property.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.out_node_key != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.out_node_key);
        }
        if self.in_node_key != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.in_node_key);
        }
        if self.edge_type != ::protobuf::EnumOrUnknown::new(cpg_struct::edge::EdgeType::UNKNOWN_EDGE_TYPE) {
            my_size += ::protobuf::rt::int32_size(5, self.edge_type.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.edge_id != 0 {
            os.write_int64(1, self.edge_id)?;
        }
        if let Some(v) = self.property.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.out_node_key != 0 {
            os.write_int64(3, self.out_node_key)?;
        }
        if self.in_node_key != 0 {
            os.write_int64(4, self.in_node_key)?;
        }
        if self.edge_type != ::protobuf::EnumOrUnknown::new(cpg_struct::edge::EdgeType::UNKNOWN_EDGE_TYPE) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.edge_type))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AdditionalEdgeProperty {
        AdditionalEdgeProperty::new()
    }

    fn clear(&mut self) {
        self.edge_id = 0;
        self.property.clear();
        self.out_node_key = 0;
        self.in_node_key = 0;
        self.edge_type = ::protobuf::EnumOrUnknown::new(cpg_struct::edge::EdgeType::UNKNOWN_EDGE_TYPE);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AdditionalEdgeProperty {
        static instance: AdditionalEdgeProperty = AdditionalEdgeProperty {
            edge_id: 0,
            property: ::protobuf::MessageField::none(),
            out_node_key: 0,
            in_node_key: 0,
            edge_type: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AdditionalEdgeProperty {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AdditionalEdgeProperty").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AdditionalEdgeProperty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AdditionalEdgeProperty {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Overlays can be stacked onto each other, therefor their node ids must be globally unique.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:atom.CpgOverlay)
pub struct CpgOverlay {
    // message fields
    // @@protoc_insertion_point(field:atom.CpgOverlay.node)
    pub node: ::std::vec::Vec<cpg_struct::Node>,
    // @@protoc_insertion_point(field:atom.CpgOverlay.edge)
    pub edge: ::std::vec::Vec<cpg_struct::Edge>,
    // @@protoc_insertion_point(field:atom.CpgOverlay.node_property)
    pub node_property: ::std::vec::Vec<AdditionalNodeProperty>,
    // @@protoc_insertion_point(field:atom.CpgOverlay.edge_property)
    pub edge_property: ::std::vec::Vec<AdditionalEdgeProperty>,
    // special fields
    // @@protoc_insertion_point(special_field:atom.CpgOverlay.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CpgOverlay {
    fn default() -> &'a CpgOverlay {
        <CpgOverlay as ::protobuf::Message>::default_instance()
    }
}

impl CpgOverlay {
    pub fn new() -> CpgOverlay {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "node",
            |m: &CpgOverlay| { &m.node },
            |m: &mut CpgOverlay| { &mut m.node },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "edge",
            |m: &CpgOverlay| { &m.edge },
            |m: &mut CpgOverlay| { &mut m.edge },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "node_property",
            |m: &CpgOverlay| { &m.node_property },
            |m: &mut CpgOverlay| { &mut m.node_property },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "edge_property",
            |m: &CpgOverlay| { &m.edge_property },
            |m: &mut CpgOverlay| { &mut m.edge_property },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CpgOverlay>(
            "CpgOverlay",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CpgOverlay {
    const NAME: &'static str = "CpgOverlay";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.node.push(is.read_message()?);
                },
                18 => {
                    self.edge.push(is.read_message()?);
                },
                26 => {
                    self.node_property.push(is.read_message()?);
                },
                34 => {
                    self.edge_property.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.node {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.edge {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.node_property {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.edge_property {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.node {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.edge {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.node_property {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.edge_property {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CpgOverlay {
        CpgOverlay::new()
    }

    fn clear(&mut self) {
        self.node.clear();
        self.edge.clear();
        self.node_property.clear();
        self.edge_property.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CpgOverlay {
        static instance: CpgOverlay = CpgOverlay {
            node: ::std::vec::Vec::new(),
            edge: ::std::vec::Vec::new(),
            node_property: ::std::vec::Vec::new(),
            edge_property: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CpgOverlay {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CpgOverlay").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CpgOverlay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CpgOverlay {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  DiffGraphs can be created independently of each other and therefor when _adding_ nodes|edges,
///  each DiffGraph has its own ID space. However, when removing nodes|edges, the nodeIds refer to the
///  globally unique graph id space.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:atom.DiffGraph)
pub struct DiffGraph {
    // message fields
    // @@protoc_insertion_point(field:atom.DiffGraph.entries)
    pub entries: ::std::vec::Vec<diff_graph::Entry>,
    // special fields
    // @@protoc_insertion_point(special_field:atom.DiffGraph.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DiffGraph {
    fn default() -> &'a DiffGraph {
        <DiffGraph as ::protobuf::Message>::default_instance()
    }
}

impl DiffGraph {
    pub fn new() -> DiffGraph {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entries",
            |m: &DiffGraph| { &m.entries },
            |m: &mut DiffGraph| { &mut m.entries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DiffGraph>(
            "DiffGraph",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DiffGraph {
    const NAME: &'static str = "DiffGraph";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entries.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.entries {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DiffGraph {
        DiffGraph::new()
    }

    fn clear(&mut self) {
        self.entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DiffGraph {
        static instance: DiffGraph = DiffGraph {
            entries: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DiffGraph {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DiffGraph").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DiffGraph {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DiffGraph {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `DiffGraph`
pub mod diff_graph {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:atom.DiffGraph.RemoveNode)
    pub struct RemoveNode {
        // message fields
        // @@protoc_insertion_point(field:atom.DiffGraph.RemoveNode.key)
        pub key: i64,
        // special fields
        // @@protoc_insertion_point(special_field:atom.DiffGraph.RemoveNode.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RemoveNode {
        fn default() -> &'a RemoveNode {
            <RemoveNode as ::protobuf::Message>::default_instance()
        }
    }

    impl RemoveNode {
        pub fn new() -> RemoveNode {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "key",
                |m: &RemoveNode| { &m.key },
                |m: &mut RemoveNode| { &mut m.key },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RemoveNode>(
                "DiffGraph.RemoveNode",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RemoveNode {
        const NAME: &'static str = "RemoveNode";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.key = is.read_int64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.key != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.key);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.key != 0 {
                os.write_int64(1, self.key)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RemoveNode {
            RemoveNode::new()
        }

        fn clear(&mut self) {
            self.key = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RemoveNode {
            static instance: RemoveNode = RemoveNode {
                key: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RemoveNode {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("DiffGraph.RemoveNode").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RemoveNode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RemoveNode {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:atom.DiffGraph.RemoveNodeProperty)
    pub struct RemoveNodeProperty {
        // message fields
        // @@protoc_insertion_point(field:atom.DiffGraph.RemoveNodeProperty.key)
        pub key: i64,
        // @@protoc_insertion_point(field:atom.DiffGraph.RemoveNodeProperty.name)
        pub name: ::protobuf::EnumOrUnknown<super::NodePropertyName>,
        // @@protoc_insertion_point(field:atom.DiffGraph.RemoveNodeProperty.local_name)
        pub local_name: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:atom.DiffGraph.RemoveNodeProperty.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RemoveNodeProperty {
        fn default() -> &'a RemoveNodeProperty {
            <RemoveNodeProperty as ::protobuf::Message>::default_instance()
        }
    }

    impl RemoveNodeProperty {
        pub fn new() -> RemoveNodeProperty {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "key",
                |m: &RemoveNodeProperty| { &m.key },
                |m: &mut RemoveNodeProperty| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "name",
                |m: &RemoveNodeProperty| { &m.name },
                |m: &mut RemoveNodeProperty| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "local_name",
                |m: &RemoveNodeProperty| { &m.local_name },
                |m: &mut RemoveNodeProperty| { &mut m.local_name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RemoveNodeProperty>(
                "DiffGraph.RemoveNodeProperty",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RemoveNodeProperty {
        const NAME: &'static str = "RemoveNodeProperty";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.key = is.read_int64()?;
                    },
                    16 => {
                        self.name = is.read_enum_or_unknown()?;
                    },
                    26 => {
                        self.local_name = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.key != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.key);
            }
            if self.name != ::protobuf::EnumOrUnknown::new(super::NodePropertyName::UNKNOWN_NODE_PROPERTY) {
                my_size += ::protobuf::rt::int32_size(2, self.name.value());
            }
            if !self.local_name.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.local_name);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.key != 0 {
                os.write_int64(1, self.key)?;
            }
            if self.name != ::protobuf::EnumOrUnknown::new(super::NodePropertyName::UNKNOWN_NODE_PROPERTY) {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.name))?;
            }
            if !self.local_name.is_empty() {
                os.write_string(3, &self.local_name)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RemoveNodeProperty {
            RemoveNodeProperty::new()
        }

        fn clear(&mut self) {
            self.key = 0;
            self.name = ::protobuf::EnumOrUnknown::new(super::NodePropertyName::UNKNOWN_NODE_PROPERTY);
            self.local_name.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RemoveNodeProperty {
            static instance: RemoveNodeProperty = RemoveNodeProperty {
                key: 0,
                name: ::protobuf::EnumOrUnknown::from_i32(0),
                local_name: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RemoveNodeProperty {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("DiffGraph.RemoveNodeProperty").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RemoveNodeProperty {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RemoveNodeProperty {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:atom.DiffGraph.RemoveEdge)
    pub struct RemoveEdge {
        // message fields
        // @@protoc_insertion_point(field:atom.DiffGraph.RemoveEdge.out_node_key)
        pub out_node_key: i64,
        // @@protoc_insertion_point(field:atom.DiffGraph.RemoveEdge.in_node_key)
        pub in_node_key: i64,
        // @@protoc_insertion_point(field:atom.DiffGraph.RemoveEdge.edge_type)
        pub edge_type: ::protobuf::EnumOrUnknown<super::cpg_struct::edge::EdgeType>,
        // @@protoc_insertion_point(field:atom.DiffGraph.RemoveEdge.propertiesHash)
        pub propertiesHash: ::std::vec::Vec<u8>,
        // special fields
        // @@protoc_insertion_point(special_field:atom.DiffGraph.RemoveEdge.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RemoveEdge {
        fn default() -> &'a RemoveEdge {
            <RemoveEdge as ::protobuf::Message>::default_instance()
        }
    }

    impl RemoveEdge {
        pub fn new() -> RemoveEdge {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "out_node_key",
                |m: &RemoveEdge| { &m.out_node_key },
                |m: &mut RemoveEdge| { &mut m.out_node_key },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "in_node_key",
                |m: &RemoveEdge| { &m.in_node_key },
                |m: &mut RemoveEdge| { &mut m.in_node_key },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "edge_type",
                |m: &RemoveEdge| { &m.edge_type },
                |m: &mut RemoveEdge| { &mut m.edge_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "propertiesHash",
                |m: &RemoveEdge| { &m.propertiesHash },
                |m: &mut RemoveEdge| { &mut m.propertiesHash },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RemoveEdge>(
                "DiffGraph.RemoveEdge",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RemoveEdge {
        const NAME: &'static str = "RemoveEdge";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.out_node_key = is.read_int64()?;
                    },
                    16 => {
                        self.in_node_key = is.read_int64()?;
                    },
                    24 => {
                        self.edge_type = is.read_enum_or_unknown()?;
                    },
                    34 => {
                        self.propertiesHash = is.read_bytes()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.out_node_key != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.out_node_key);
            }
            if self.in_node_key != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.in_node_key);
            }
            if self.edge_type != ::protobuf::EnumOrUnknown::new(super::cpg_struct::edge::EdgeType::UNKNOWN_EDGE_TYPE) {
                my_size += ::protobuf::rt::int32_size(3, self.edge_type.value());
            }
            if !self.propertiesHash.is_empty() {
                my_size += ::protobuf::rt::bytes_size(4, &self.propertiesHash);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.out_node_key != 0 {
                os.write_int64(1, self.out_node_key)?;
            }
            if self.in_node_key != 0 {
                os.write_int64(2, self.in_node_key)?;
            }
            if self.edge_type != ::protobuf::EnumOrUnknown::new(super::cpg_struct::edge::EdgeType::UNKNOWN_EDGE_TYPE) {
                os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.edge_type))?;
            }
            if !self.propertiesHash.is_empty() {
                os.write_bytes(4, &self.propertiesHash)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RemoveEdge {
            RemoveEdge::new()
        }

        fn clear(&mut self) {
            self.out_node_key = 0;
            self.in_node_key = 0;
            self.edge_type = ::protobuf::EnumOrUnknown::new(super::cpg_struct::edge::EdgeType::UNKNOWN_EDGE_TYPE);
            self.propertiesHash.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RemoveEdge {
            static instance: RemoveEdge = RemoveEdge {
                out_node_key: 0,
                in_node_key: 0,
                edge_type: ::protobuf::EnumOrUnknown::from_i32(0),
                propertiesHash: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RemoveEdge {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("DiffGraph.RemoveEdge").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RemoveEdge {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RemoveEdge {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:atom.DiffGraph.RemoveEdgeProperty)
    pub struct RemoveEdgeProperty {
        // message fields
        // @@protoc_insertion_point(field:atom.DiffGraph.RemoveEdgeProperty.out_node_key)
        pub out_node_key: i64,
        // @@protoc_insertion_point(field:atom.DiffGraph.RemoveEdgeProperty.in_node_key)
        pub in_node_key: i64,
        // @@protoc_insertion_point(field:atom.DiffGraph.RemoveEdgeProperty.edge_type)
        pub edge_type: ::protobuf::EnumOrUnknown<super::cpg_struct::edge::EdgeType>,
        // @@protoc_insertion_point(field:atom.DiffGraph.RemoveEdgeProperty.propertiesHash)
        pub propertiesHash: ::std::vec::Vec<u8>,
        // @@protoc_insertion_point(field:atom.DiffGraph.RemoveEdgeProperty.property_name)
        pub property_name: ::protobuf::EnumOrUnknown<super::EdgePropertyName>,
        // special fields
        // @@protoc_insertion_point(special_field:atom.DiffGraph.RemoveEdgeProperty.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RemoveEdgeProperty {
        fn default() -> &'a RemoveEdgeProperty {
            <RemoveEdgeProperty as ::protobuf::Message>::default_instance()
        }
    }

    impl RemoveEdgeProperty {
        pub fn new() -> RemoveEdgeProperty {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "out_node_key",
                |m: &RemoveEdgeProperty| { &m.out_node_key },
                |m: &mut RemoveEdgeProperty| { &mut m.out_node_key },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "in_node_key",
                |m: &RemoveEdgeProperty| { &m.in_node_key },
                |m: &mut RemoveEdgeProperty| { &mut m.in_node_key },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "edge_type",
                |m: &RemoveEdgeProperty| { &m.edge_type },
                |m: &mut RemoveEdgeProperty| { &mut m.edge_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "propertiesHash",
                |m: &RemoveEdgeProperty| { &m.propertiesHash },
                |m: &mut RemoveEdgeProperty| { &mut m.propertiesHash },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "property_name",
                |m: &RemoveEdgeProperty| { &m.property_name },
                |m: &mut RemoveEdgeProperty| { &mut m.property_name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RemoveEdgeProperty>(
                "DiffGraph.RemoveEdgeProperty",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RemoveEdgeProperty {
        const NAME: &'static str = "RemoveEdgeProperty";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.out_node_key = is.read_int64()?;
                    },
                    16 => {
                        self.in_node_key = is.read_int64()?;
                    },
                    24 => {
                        self.edge_type = is.read_enum_or_unknown()?;
                    },
                    34 => {
                        self.propertiesHash = is.read_bytes()?;
                    },
                    40 => {
                        self.property_name = is.read_enum_or_unknown()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.out_node_key != 0 {
                my_size += ::protobuf::rt::int64_size(1, self.out_node_key);
            }
            if self.in_node_key != 0 {
                my_size += ::protobuf::rt::int64_size(2, self.in_node_key);
            }
            if self.edge_type != ::protobuf::EnumOrUnknown::new(super::cpg_struct::edge::EdgeType::UNKNOWN_EDGE_TYPE) {
                my_size += ::protobuf::rt::int32_size(3, self.edge_type.value());
            }
            if !self.propertiesHash.is_empty() {
                my_size += ::protobuf::rt::bytes_size(4, &self.propertiesHash);
            }
            if self.property_name != ::protobuf::EnumOrUnknown::new(super::EdgePropertyName::UNKNOWN_EDGE_PROPERTY) {
                my_size += ::protobuf::rt::int32_size(5, self.property_name.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.out_node_key != 0 {
                os.write_int64(1, self.out_node_key)?;
            }
            if self.in_node_key != 0 {
                os.write_int64(2, self.in_node_key)?;
            }
            if self.edge_type != ::protobuf::EnumOrUnknown::new(super::cpg_struct::edge::EdgeType::UNKNOWN_EDGE_TYPE) {
                os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.edge_type))?;
            }
            if !self.propertiesHash.is_empty() {
                os.write_bytes(4, &self.propertiesHash)?;
            }
            if self.property_name != ::protobuf::EnumOrUnknown::new(super::EdgePropertyName::UNKNOWN_EDGE_PROPERTY) {
                os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.property_name))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RemoveEdgeProperty {
            RemoveEdgeProperty::new()
        }

        fn clear(&mut self) {
            self.out_node_key = 0;
            self.in_node_key = 0;
            self.edge_type = ::protobuf::EnumOrUnknown::new(super::cpg_struct::edge::EdgeType::UNKNOWN_EDGE_TYPE);
            self.propertiesHash.clear();
            self.property_name = ::protobuf::EnumOrUnknown::new(super::EdgePropertyName::UNKNOWN_EDGE_PROPERTY);
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RemoveEdgeProperty {
            static instance: RemoveEdgeProperty = RemoveEdgeProperty {
                out_node_key: 0,
                in_node_key: 0,
                edge_type: ::protobuf::EnumOrUnknown::from_i32(0),
                propertiesHash: ::std::vec::Vec::new(),
                property_name: ::protobuf::EnumOrUnknown::from_i32(0),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RemoveEdgeProperty {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("DiffGraph.RemoveEdgeProperty").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RemoveEdgeProperty {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RemoveEdgeProperty {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:atom.DiffGraph.Entry)
    pub struct Entry {
        // message oneof groups
        pub value: ::std::option::Option<entry::Value>,
        // special fields
        // @@protoc_insertion_point(special_field:atom.DiffGraph.Entry.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Entry {
        fn default() -> &'a Entry {
            <Entry as ::protobuf::Message>::default_instance()
        }
    }

    impl Entry {
        pub fn new() -> Entry {
            ::std::default::Default::default()
        }

        // .atom.CpgStruct.Node node = 1;

        pub fn node(&self) -> &super::cpg_struct::Node {
            match self.value {
                ::std::option::Option::Some(entry::Value::Node(ref v)) => v,
                _ => <super::cpg_struct::Node as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_node(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_node(&self) -> bool {
            match self.value {
                ::std::option::Option::Some(entry::Value::Node(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_node(&mut self, v: super::cpg_struct::Node) {
            self.value = ::std::option::Option::Some(entry::Value::Node(v))
        }

        // Mutable pointer to the field.
        pub fn mut_node(&mut self) -> &mut super::cpg_struct::Node {
            if let ::std::option::Option::Some(entry::Value::Node(_)) = self.value {
            } else {
                self.value = ::std::option::Option::Some(entry::Value::Node(super::cpg_struct::Node::new()));
            }
            match self.value {
                ::std::option::Option::Some(entry::Value::Node(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_node(&mut self) -> super::cpg_struct::Node {
            if self.has_node() {
                match self.value.take() {
                    ::std::option::Option::Some(entry::Value::Node(v)) => v,
                    _ => panic!(),
                }
            } else {
                super::cpg_struct::Node::new()
            }
        }

        // .atom.CpgStruct.Edge edge = 2;

        pub fn edge(&self) -> &super::cpg_struct::Edge {
            match self.value {
                ::std::option::Option::Some(entry::Value::Edge(ref v)) => v,
                _ => <super::cpg_struct::Edge as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_edge(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_edge(&self) -> bool {
            match self.value {
                ::std::option::Option::Some(entry::Value::Edge(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_edge(&mut self, v: super::cpg_struct::Edge) {
            self.value = ::std::option::Option::Some(entry::Value::Edge(v))
        }

        // Mutable pointer to the field.
        pub fn mut_edge(&mut self) -> &mut super::cpg_struct::Edge {
            if let ::std::option::Option::Some(entry::Value::Edge(_)) = self.value {
            } else {
                self.value = ::std::option::Option::Some(entry::Value::Edge(super::cpg_struct::Edge::new()));
            }
            match self.value {
                ::std::option::Option::Some(entry::Value::Edge(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_edge(&mut self) -> super::cpg_struct::Edge {
            if self.has_edge() {
                match self.value.take() {
                    ::std::option::Option::Some(entry::Value::Edge(v)) => v,
                    _ => panic!(),
                }
            } else {
                super::cpg_struct::Edge::new()
            }
        }

        // .atom.AdditionalNodeProperty node_property = 3;

        pub fn node_property(&self) -> &super::AdditionalNodeProperty {
            match self.value {
                ::std::option::Option::Some(entry::Value::NodeProperty(ref v)) => v,
                _ => <super::AdditionalNodeProperty as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_node_property(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_node_property(&self) -> bool {
            match self.value {
                ::std::option::Option::Some(entry::Value::NodeProperty(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_node_property(&mut self, v: super::AdditionalNodeProperty) {
            self.value = ::std::option::Option::Some(entry::Value::NodeProperty(v))
        }

        // Mutable pointer to the field.
        pub fn mut_node_property(&mut self) -> &mut super::AdditionalNodeProperty {
            if let ::std::option::Option::Some(entry::Value::NodeProperty(_)) = self.value {
            } else {
                self.value = ::std::option::Option::Some(entry::Value::NodeProperty(super::AdditionalNodeProperty::new()));
            }
            match self.value {
                ::std::option::Option::Some(entry::Value::NodeProperty(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_node_property(&mut self) -> super::AdditionalNodeProperty {
            if self.has_node_property() {
                match self.value.take() {
                    ::std::option::Option::Some(entry::Value::NodeProperty(v)) => v,
                    _ => panic!(),
                }
            } else {
                super::AdditionalNodeProperty::new()
            }
        }

        // .atom.AdditionalEdgeProperty edge_property = 4;

        pub fn edge_property(&self) -> &super::AdditionalEdgeProperty {
            match self.value {
                ::std::option::Option::Some(entry::Value::EdgeProperty(ref v)) => v,
                _ => <super::AdditionalEdgeProperty as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_edge_property(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_edge_property(&self) -> bool {
            match self.value {
                ::std::option::Option::Some(entry::Value::EdgeProperty(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_edge_property(&mut self, v: super::AdditionalEdgeProperty) {
            self.value = ::std::option::Option::Some(entry::Value::EdgeProperty(v))
        }

        // Mutable pointer to the field.
        pub fn mut_edge_property(&mut self) -> &mut super::AdditionalEdgeProperty {
            if let ::std::option::Option::Some(entry::Value::EdgeProperty(_)) = self.value {
            } else {
                self.value = ::std::option::Option::Some(entry::Value::EdgeProperty(super::AdditionalEdgeProperty::new()));
            }
            match self.value {
                ::std::option::Option::Some(entry::Value::EdgeProperty(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_edge_property(&mut self) -> super::AdditionalEdgeProperty {
            if self.has_edge_property() {
                match self.value.take() {
                    ::std::option::Option::Some(entry::Value::EdgeProperty(v)) => v,
                    _ => panic!(),
                }
            } else {
                super::AdditionalEdgeProperty::new()
            }
        }

        // .atom.DiffGraph.RemoveNode remove_node = 5;

        pub fn remove_node(&self) -> &RemoveNode {
            match self.value {
                ::std::option::Option::Some(entry::Value::RemoveNode(ref v)) => v,
                _ => <RemoveNode as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_remove_node(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_remove_node(&self) -> bool {
            match self.value {
                ::std::option::Option::Some(entry::Value::RemoveNode(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_remove_node(&mut self, v: RemoveNode) {
            self.value = ::std::option::Option::Some(entry::Value::RemoveNode(v))
        }

        // Mutable pointer to the field.
        pub fn mut_remove_node(&mut self) -> &mut RemoveNode {
            if let ::std::option::Option::Some(entry::Value::RemoveNode(_)) = self.value {
            } else {
                self.value = ::std::option::Option::Some(entry::Value::RemoveNode(RemoveNode::new()));
            }
            match self.value {
                ::std::option::Option::Some(entry::Value::RemoveNode(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_remove_node(&mut self) -> RemoveNode {
            if self.has_remove_node() {
                match self.value.take() {
                    ::std::option::Option::Some(entry::Value::RemoveNode(v)) => v,
                    _ => panic!(),
                }
            } else {
                RemoveNode::new()
            }
        }

        // .atom.DiffGraph.RemoveNodeProperty remove_node_property = 6;

        pub fn remove_node_property(&self) -> &RemoveNodeProperty {
            match self.value {
                ::std::option::Option::Some(entry::Value::RemoveNodeProperty(ref v)) => v,
                _ => <RemoveNodeProperty as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_remove_node_property(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_remove_node_property(&self) -> bool {
            match self.value {
                ::std::option::Option::Some(entry::Value::RemoveNodeProperty(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_remove_node_property(&mut self, v: RemoveNodeProperty) {
            self.value = ::std::option::Option::Some(entry::Value::RemoveNodeProperty(v))
        }

        // Mutable pointer to the field.
        pub fn mut_remove_node_property(&mut self) -> &mut RemoveNodeProperty {
            if let ::std::option::Option::Some(entry::Value::RemoveNodeProperty(_)) = self.value {
            } else {
                self.value = ::std::option::Option::Some(entry::Value::RemoveNodeProperty(RemoveNodeProperty::new()));
            }
            match self.value {
                ::std::option::Option::Some(entry::Value::RemoveNodeProperty(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_remove_node_property(&mut self) -> RemoveNodeProperty {
            if self.has_remove_node_property() {
                match self.value.take() {
                    ::std::option::Option::Some(entry::Value::RemoveNodeProperty(v)) => v,
                    _ => panic!(),
                }
            } else {
                RemoveNodeProperty::new()
            }
        }

        // .atom.DiffGraph.RemoveEdge remove_edge = 7;

        pub fn remove_edge(&self) -> &RemoveEdge {
            match self.value {
                ::std::option::Option::Some(entry::Value::RemoveEdge(ref v)) => v,
                _ => <RemoveEdge as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_remove_edge(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_remove_edge(&self) -> bool {
            match self.value {
                ::std::option::Option::Some(entry::Value::RemoveEdge(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_remove_edge(&mut self, v: RemoveEdge) {
            self.value = ::std::option::Option::Some(entry::Value::RemoveEdge(v))
        }

        // Mutable pointer to the field.
        pub fn mut_remove_edge(&mut self) -> &mut RemoveEdge {
            if let ::std::option::Option::Some(entry::Value::RemoveEdge(_)) = self.value {
            } else {
                self.value = ::std::option::Option::Some(entry::Value::RemoveEdge(RemoveEdge::new()));
            }
            match self.value {
                ::std::option::Option::Some(entry::Value::RemoveEdge(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_remove_edge(&mut self) -> RemoveEdge {
            if self.has_remove_edge() {
                match self.value.take() {
                    ::std::option::Option::Some(entry::Value::RemoveEdge(v)) => v,
                    _ => panic!(),
                }
            } else {
                RemoveEdge::new()
            }
        }

        // .atom.DiffGraph.RemoveEdgeProperty remove_edge_property = 8;

        pub fn remove_edge_property(&self) -> &RemoveEdgeProperty {
            match self.value {
                ::std::option::Option::Some(entry::Value::RemoveEdgeProperty(ref v)) => v,
                _ => <RemoveEdgeProperty as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_remove_edge_property(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_remove_edge_property(&self) -> bool {
            match self.value {
                ::std::option::Option::Some(entry::Value::RemoveEdgeProperty(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_remove_edge_property(&mut self, v: RemoveEdgeProperty) {
            self.value = ::std::option::Option::Some(entry::Value::RemoveEdgeProperty(v))
        }

        // Mutable pointer to the field.
        pub fn mut_remove_edge_property(&mut self) -> &mut RemoveEdgeProperty {
            if let ::std::option::Option::Some(entry::Value::RemoveEdgeProperty(_)) = self.value {
            } else {
                self.value = ::std::option::Option::Some(entry::Value::RemoveEdgeProperty(RemoveEdgeProperty::new()));
            }
            match self.value {
                ::std::option::Option::Some(entry::Value::RemoveEdgeProperty(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_remove_edge_property(&mut self) -> RemoveEdgeProperty {
            if self.has_remove_edge_property() {
                match self.value.take() {
                    ::std::option::Option::Some(entry::Value::RemoveEdgeProperty(v)) => v,
                    _ => panic!(),
                }
            } else {
                RemoveEdgeProperty::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::cpg_struct::Node>(
                "node",
                Entry::has_node,
                Entry::node,
                Entry::mut_node,
                Entry::set_node,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::cpg_struct::Edge>(
                "edge",
                Entry::has_edge,
                Entry::edge,
                Entry::mut_edge,
                Entry::set_edge,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::AdditionalNodeProperty>(
                "node_property",
                Entry::has_node_property,
                Entry::node_property,
                Entry::mut_node_property,
                Entry::set_node_property,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::AdditionalEdgeProperty>(
                "edge_property",
                Entry::has_edge_property,
                Entry::edge_property,
                Entry::mut_edge_property,
                Entry::set_edge_property,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RemoveNode>(
                "remove_node",
                Entry::has_remove_node,
                Entry::remove_node,
                Entry::mut_remove_node,
                Entry::set_remove_node,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RemoveNodeProperty>(
                "remove_node_property",
                Entry::has_remove_node_property,
                Entry::remove_node_property,
                Entry::mut_remove_node_property,
                Entry::set_remove_node_property,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RemoveEdge>(
                "remove_edge",
                Entry::has_remove_edge,
                Entry::remove_edge,
                Entry::mut_remove_edge,
                Entry::set_remove_edge,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RemoveEdgeProperty>(
                "remove_edge_property",
                Entry::has_remove_edge_property,
                Entry::remove_edge_property,
                Entry::mut_remove_edge_property,
                Entry::set_remove_edge_property,
            ));
            oneofs.push(entry::Value::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Entry>(
                "DiffGraph.Entry",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Entry {
        const NAME: &'static str = "Entry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.value = ::std::option::Option::Some(entry::Value::Node(is.read_message()?));
                    },
                    18 => {
                        self.value = ::std::option::Option::Some(entry::Value::Edge(is.read_message()?));
                    },
                    26 => {
                        self.value = ::std::option::Option::Some(entry::Value::NodeProperty(is.read_message()?));
                    },
                    34 => {
                        self.value = ::std::option::Option::Some(entry::Value::EdgeProperty(is.read_message()?));
                    },
                    42 => {
                        self.value = ::std::option::Option::Some(entry::Value::RemoveNode(is.read_message()?));
                    },
                    50 => {
                        self.value = ::std::option::Option::Some(entry::Value::RemoveNodeProperty(is.read_message()?));
                    },
                    58 => {
                        self.value = ::std::option::Option::Some(entry::Value::RemoveEdge(is.read_message()?));
                    },
                    66 => {
                        self.value = ::std::option::Option::Some(entry::Value::RemoveEdgeProperty(is.read_message()?));
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let ::std::option::Option::Some(ref v) = self.value {
                match v {
                    &entry::Value::Node(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &entry::Value::Edge(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &entry::Value::NodeProperty(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &entry::Value::EdgeProperty(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &entry::Value::RemoveNode(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &entry::Value::RemoveNodeProperty(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &entry::Value::RemoveEdge(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &entry::Value::RemoveEdgeProperty(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let ::std::option::Option::Some(ref v) = self.value {
                match v {
                    &entry::Value::Node(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                    },
                    &entry::Value::Edge(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    },
                    &entry::Value::NodeProperty(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                    },
                    &entry::Value::EdgeProperty(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                    },
                    &entry::Value::RemoveNode(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                    },
                    &entry::Value::RemoveNodeProperty(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                    },
                    &entry::Value::RemoveEdge(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                    },
                    &entry::Value::RemoveEdgeProperty(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Entry {
            Entry::new()
        }

        fn clear(&mut self) {
            self.value = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Entry {
            static instance: Entry = Entry {
                value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Entry {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("DiffGraph.Entry").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Entry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Entry {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Entry`
    pub mod entry {

        #[derive(Clone,PartialEq,Debug)]
        #[non_exhaustive]
        // @@protoc_insertion_point(oneof:atom.DiffGraph.Entry.value)
        pub enum Value {
            // @@protoc_insertion_point(oneof_field:atom.DiffGraph.Entry.node)
            Node(super::super::cpg_struct::Node),
            // @@protoc_insertion_point(oneof_field:atom.DiffGraph.Entry.edge)
            Edge(super::super::cpg_struct::Edge),
            // @@protoc_insertion_point(oneof_field:atom.DiffGraph.Entry.node_property)
            NodeProperty(super::super::AdditionalNodeProperty),
            // @@protoc_insertion_point(oneof_field:atom.DiffGraph.Entry.edge_property)
            EdgeProperty(super::super::AdditionalEdgeProperty),
            // @@protoc_insertion_point(oneof_field:atom.DiffGraph.Entry.remove_node)
            RemoveNode(super::RemoveNode),
            // @@protoc_insertion_point(oneof_field:atom.DiffGraph.Entry.remove_node_property)
            RemoveNodeProperty(super::RemoveNodeProperty),
            // @@protoc_insertion_point(oneof_field:atom.DiffGraph.Entry.remove_edge)
            RemoveEdge(super::RemoveEdge),
            // @@protoc_insertion_point(oneof_field:atom.DiffGraph.Entry.remove_edge_property)
            RemoveEdgeProperty(super::RemoveEdgeProperty),
        }

        impl ::protobuf::Oneof for Value {
        }

        impl ::protobuf::OneofFull for Value {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::Entry as ::protobuf::MessageFull>::descriptor().oneof_by_name("value").unwrap()).clone()
            }
        }

        impl Value {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Value>("value")
            }
        }
    }
}

/// *
///  The usages slice describes how a variable interacts within its procedure. This is perhaps a more "descriptive" slice in some ways. The variables are locals and parameters and the referencing identifiers are tracked to find what the variable calls and what calls it forms an argument of.
///  There are two lists. There is a list of MethodUsageSlice with key "objectSlices" and a list of UserDefinedTypes with key "userDefinedTypes"
///
///  ![Usage slices overview](./docs/Library%20Usages.png)
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:atom.UsageSlice)
pub struct UsageSlice {
    // message fields
    // @@protoc_insertion_point(field:atom.UsageSlice.objectSlices)
    pub objectSlices: ::std::vec::Vec<usage_slice::MethodUsageSlice>,
    // @@protoc_insertion_point(field:atom.UsageSlice.userDefinedTypes)
    pub userDefinedTypes: ::std::vec::Vec<usage_slice::UserDefinedTypes>,
    // special fields
    // @@protoc_insertion_point(special_field:atom.UsageSlice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UsageSlice {
    fn default() -> &'a UsageSlice {
        <UsageSlice as ::protobuf::Message>::default_instance()
    }
}

impl UsageSlice {
    pub fn new() -> UsageSlice {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "objectSlices",
            |m: &UsageSlice| { &m.objectSlices },
            |m: &mut UsageSlice| { &mut m.objectSlices },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "userDefinedTypes",
            |m: &UsageSlice| { &m.userDefinedTypes },
            |m: &mut UsageSlice| { &mut m.userDefinedTypes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UsageSlice>(
            "UsageSlice",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UsageSlice {
    const NAME: &'static str = "UsageSlice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.objectSlices.push(is.read_message()?);
                },
                18 => {
                    self.userDefinedTypes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.objectSlices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.userDefinedTypes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.objectSlices {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.userDefinedTypes {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UsageSlice {
        UsageSlice::new()
    }

    fn clear(&mut self) {
        self.objectSlices.clear();
        self.userDefinedTypes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UsageSlice {
        static instance: UsageSlice = UsageSlice {
            objectSlices: ::std::vec::Vec::new(),
            userDefinedTypes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UsageSlice {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UsageSlice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UsageSlice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UsageSlice {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `UsageSlice`
pub mod usage_slice {
    ///  Represents a source of data-generation, i.e., where data is defined and can be assigned to some variable or used in an argument.
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:atom.UsageSlice.TargetObj)
    pub struct TargetObj {
        // message fields
        ///  variable or parameter name
        // @@protoc_insertion_point(field:atom.UsageSlice.TargetObj.name)
        pub name: ::std::string::String,
        ///  Fullname of the data type
        // @@protoc_insertion_point(field:atom.UsageSlice.TargetObj.typeFullName)
        pub typeFullName: ::std::string::String,
        ///  Position of the parameter or argument
        // @@protoc_insertion_point(field:atom.UsageSlice.TargetObj.position)
        pub position: u32,
        ///  Boolean to indicate if the call belongs to an external method. label=CALL
        // @@protoc_insertion_point(field:atom.UsageSlice.TargetObj.isExternal)
        pub isExternal: bool,
        ///  Line number in the file
        // @@protoc_insertion_point(field:atom.UsageSlice.TargetObj.lineNumber)
        pub lineNumber: u32,
        ///  Column number
        // @@protoc_insertion_point(field:atom.UsageSlice.TargetObj.columnNumber)
        pub columnNumber: u32,
        // @@protoc_insertion_point(field:atom.UsageSlice.TargetObj.label)
        pub label: ::protobuf::EnumOrUnknown<LabelType>,
        // special fields
        // @@protoc_insertion_point(special_field:atom.UsageSlice.TargetObj.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TargetObj {
        fn default() -> &'a TargetObj {
            <TargetObj as ::protobuf::Message>::default_instance()
        }
    }

    impl TargetObj {
        pub fn new() -> TargetObj {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "name",
                |m: &TargetObj| { &m.name },
                |m: &mut TargetObj| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "typeFullName",
                |m: &TargetObj| { &m.typeFullName },
                |m: &mut TargetObj| { &mut m.typeFullName },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "position",
                |m: &TargetObj| { &m.position },
                |m: &mut TargetObj| { &mut m.position },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "isExternal",
                |m: &TargetObj| { &m.isExternal },
                |m: &mut TargetObj| { &mut m.isExternal },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "lineNumber",
                |m: &TargetObj| { &m.lineNumber },
                |m: &mut TargetObj| { &mut m.lineNumber },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "columnNumber",
                |m: &TargetObj| { &m.columnNumber },
                |m: &mut TargetObj| { &mut m.columnNumber },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "label",
                |m: &TargetObj| { &m.label },
                |m: &mut TargetObj| { &mut m.label },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TargetObj>(
                "UsageSlice.TargetObj",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TargetObj {
        const NAME: &'static str = "TargetObj";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = is.read_string()?;
                    },
                    18 => {
                        self.typeFullName = is.read_string()?;
                    },
                    24 => {
                        self.position = is.read_uint32()?;
                    },
                    32 => {
                        self.isExternal = is.read_bool()?;
                    },
                    40 => {
                        self.lineNumber = is.read_uint32()?;
                    },
                    48 => {
                        self.columnNumber = is.read_uint32()?;
                    },
                    56 => {
                        self.label = is.read_enum_or_unknown()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.name.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.name);
            }
            if !self.typeFullName.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.typeFullName);
            }
            if self.position != 0 {
                my_size += ::protobuf::rt::uint32_size(3, self.position);
            }
            if self.isExternal != false {
                my_size += 1 + 1;
            }
            if self.lineNumber != 0 {
                my_size += ::protobuf::rt::uint32_size(5, self.lineNumber);
            }
            if self.columnNumber != 0 {
                my_size += ::protobuf::rt::uint32_size(6, self.columnNumber);
            }
            if self.label != ::protobuf::EnumOrUnknown::new(LabelType::ANY) {
                my_size += ::protobuf::rt::int32_size(7, self.label.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.name.is_empty() {
                os.write_string(1, &self.name)?;
            }
            if !self.typeFullName.is_empty() {
                os.write_string(2, &self.typeFullName)?;
            }
            if self.position != 0 {
                os.write_uint32(3, self.position)?;
            }
            if self.isExternal != false {
                os.write_bool(4, self.isExternal)?;
            }
            if self.lineNumber != 0 {
                os.write_uint32(5, self.lineNumber)?;
            }
            if self.columnNumber != 0 {
                os.write_uint32(6, self.columnNumber)?;
            }
            if self.label != ::protobuf::EnumOrUnknown::new(LabelType::ANY) {
                os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.label))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TargetObj {
            TargetObj::new()
        }

        fn clear(&mut self) {
            self.name.clear();
            self.typeFullName.clear();
            self.position = 0;
            self.isExternal = false;
            self.lineNumber = 0;
            self.columnNumber = 0;
            self.label = ::protobuf::EnumOrUnknown::new(LabelType::ANY);
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TargetObj {
            static instance: TargetObj = TargetObj {
                name: ::std::string::String::new(),
                typeFullName: ::std::string::String::new(),
                position: 0,
                isExternal: false,
                lineNumber: 0,
                columnNumber: 0,
                label: ::protobuf::EnumOrUnknown::from_i32(0),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TargetObj {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("UsageSlice.TargetObj").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TargetObj {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TargetObj {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Places where the given symbol is defined
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:atom.UsageSlice.DefinedBy)
    pub struct DefinedBy {
        // message fields
        ///  variable or parameter name
        // @@protoc_insertion_point(field:atom.UsageSlice.DefinedBy.name)
        pub name: ::std::string::String,
        ///  Fullname of the data type
        // @@protoc_insertion_point(field:atom.UsageSlice.DefinedBy.typeFullName)
        pub typeFullName: ::std::string::String,
        ///  Method name
        // @@protoc_insertion_point(field:atom.UsageSlice.DefinedBy.resolvedMethod)
        pub resolvedMethod: ::std::string::String,
        ///  Position
        // @@protoc_insertion_point(field:atom.UsageSlice.DefinedBy.position)
        pub position: u32,
        ///  Boolean to indicate if the call belongs to an external method. label=CALL
        // @@protoc_insertion_point(field:atom.UsageSlice.DefinedBy.isExternal)
        pub isExternal: bool,
        ///  Line number
        // @@protoc_insertion_point(field:atom.UsageSlice.DefinedBy.lineNumber)
        pub lineNumber: u32,
        ///  Column number
        // @@protoc_insertion_point(field:atom.UsageSlice.DefinedBy.columnNumber)
        pub columnNumber: u32,
        ///  Label describing the resolved method or position
        // @@protoc_insertion_point(field:atom.UsageSlice.DefinedBy.label)
        pub label: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:atom.UsageSlice.DefinedBy.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DefinedBy {
        fn default() -> &'a DefinedBy {
            <DefinedBy as ::protobuf::Message>::default_instance()
        }
    }

    impl DefinedBy {
        pub fn new() -> DefinedBy {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "name",
                |m: &DefinedBy| { &m.name },
                |m: &mut DefinedBy| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "typeFullName",
                |m: &DefinedBy| { &m.typeFullName },
                |m: &mut DefinedBy| { &mut m.typeFullName },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "resolvedMethod",
                |m: &DefinedBy| { &m.resolvedMethod },
                |m: &mut DefinedBy| { &mut m.resolvedMethod },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "position",
                |m: &DefinedBy| { &m.position },
                |m: &mut DefinedBy| { &mut m.position },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "isExternal",
                |m: &DefinedBy| { &m.isExternal },
                |m: &mut DefinedBy| { &mut m.isExternal },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "lineNumber",
                |m: &DefinedBy| { &m.lineNumber },
                |m: &mut DefinedBy| { &mut m.lineNumber },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "columnNumber",
                |m: &DefinedBy| { &m.columnNumber },
                |m: &mut DefinedBy| { &mut m.columnNumber },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "label",
                |m: &DefinedBy| { &m.label },
                |m: &mut DefinedBy| { &mut m.label },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DefinedBy>(
                "UsageSlice.DefinedBy",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for DefinedBy {
        const NAME: &'static str = "DefinedBy";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = is.read_string()?;
                    },
                    18 => {
                        self.typeFullName = is.read_string()?;
                    },
                    26 => {
                        self.resolvedMethod = is.read_string()?;
                    },
                    32 => {
                        self.position = is.read_uint32()?;
                    },
                    40 => {
                        self.isExternal = is.read_bool()?;
                    },
                    48 => {
                        self.lineNumber = is.read_uint32()?;
                    },
                    56 => {
                        self.columnNumber = is.read_uint32()?;
                    },
                    66 => {
                        self.label = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.name.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.name);
            }
            if !self.typeFullName.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.typeFullName);
            }
            if !self.resolvedMethod.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.resolvedMethod);
            }
            if self.position != 0 {
                my_size += ::protobuf::rt::uint32_size(4, self.position);
            }
            if self.isExternal != false {
                my_size += 1 + 1;
            }
            if self.lineNumber != 0 {
                my_size += ::protobuf::rt::uint32_size(6, self.lineNumber);
            }
            if self.columnNumber != 0 {
                my_size += ::protobuf::rt::uint32_size(7, self.columnNumber);
            }
            if !self.label.is_empty() {
                my_size += ::protobuf::rt::string_size(8, &self.label);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.name.is_empty() {
                os.write_string(1, &self.name)?;
            }
            if !self.typeFullName.is_empty() {
                os.write_string(2, &self.typeFullName)?;
            }
            if !self.resolvedMethod.is_empty() {
                os.write_string(3, &self.resolvedMethod)?;
            }
            if self.position != 0 {
                os.write_uint32(4, self.position)?;
            }
            if self.isExternal != false {
                os.write_bool(5, self.isExternal)?;
            }
            if self.lineNumber != 0 {
                os.write_uint32(6, self.lineNumber)?;
            }
            if self.columnNumber != 0 {
                os.write_uint32(7, self.columnNumber)?;
            }
            if !self.label.is_empty() {
                os.write_string(8, &self.label)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DefinedBy {
            DefinedBy::new()
        }

        fn clear(&mut self) {
            self.name.clear();
            self.typeFullName.clear();
            self.resolvedMethod.clear();
            self.position = 0;
            self.isExternal = false;
            self.lineNumber = 0;
            self.columnNumber = 0;
            self.label.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DefinedBy {
            static instance: DefinedBy = DefinedBy {
                name: ::std::string::String::new(),
                typeFullName: ::std::string::String::new(),
                resolvedMethod: ::std::string::String::new(),
                position: 0,
                isExternal: false,
                lineNumber: 0,
                columnNumber: 0,
                label: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for DefinedBy {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("UsageSlice.DefinedBy").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DefinedBy {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DefinedBy {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  The calls this object is observed to call.
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:atom.UsageSlice.InvokedCalls)
    pub struct InvokedCalls {
        // message fields
        ///  Call method name
        // @@protoc_insertion_point(field:atom.UsageSlice.InvokedCalls.callName)
        pub callName: ::std::string::String,
        ///  Full name of the resolved method
        // @@protoc_insertion_point(field:atom.UsageSlice.InvokedCalls.resolvedMethod)
        pub resolvedMethod: ::std::string::String,
        ///  Types of the parameters
        // @@protoc_insertion_point(field:atom.UsageSlice.InvokedCalls.paramTypes)
        pub paramTypes: ::std::vec::Vec<::std::string::String>,
        ///  Return type
        // @@protoc_insertion_point(field:atom.UsageSlice.InvokedCalls.returnType)
        pub returnType: ::std::string::String,
        ///  Boolean to indicate if the call belongs to an external method
        // @@protoc_insertion_point(field:atom.UsageSlice.InvokedCalls.isExternal)
        pub isExternal: bool,
        ///  Line number
        // @@protoc_insertion_point(field:atom.UsageSlice.InvokedCalls.lineNumber)
        pub lineNumber: u32,
        ///  Column number
        // @@protoc_insertion_point(field:atom.UsageSlice.InvokedCalls.columnNumber)
        pub columnNumber: u32,
        // special fields
        // @@protoc_insertion_point(special_field:atom.UsageSlice.InvokedCalls.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a InvokedCalls {
        fn default() -> &'a InvokedCalls {
            <InvokedCalls as ::protobuf::Message>::default_instance()
        }
    }

    impl InvokedCalls {
        pub fn new() -> InvokedCalls {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "callName",
                |m: &InvokedCalls| { &m.callName },
                |m: &mut InvokedCalls| { &mut m.callName },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "resolvedMethod",
                |m: &InvokedCalls| { &m.resolvedMethod },
                |m: &mut InvokedCalls| { &mut m.resolvedMethod },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "paramTypes",
                |m: &InvokedCalls| { &m.paramTypes },
                |m: &mut InvokedCalls| { &mut m.paramTypes },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "returnType",
                |m: &InvokedCalls| { &m.returnType },
                |m: &mut InvokedCalls| { &mut m.returnType },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "isExternal",
                |m: &InvokedCalls| { &m.isExternal },
                |m: &mut InvokedCalls| { &mut m.isExternal },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "lineNumber",
                |m: &InvokedCalls| { &m.lineNumber },
                |m: &mut InvokedCalls| { &mut m.lineNumber },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "columnNumber",
                |m: &InvokedCalls| { &m.columnNumber },
                |m: &mut InvokedCalls| { &mut m.columnNumber },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InvokedCalls>(
                "UsageSlice.InvokedCalls",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for InvokedCalls {
        const NAME: &'static str = "InvokedCalls";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.callName = is.read_string()?;
                    },
                    18 => {
                        self.resolvedMethod = is.read_string()?;
                    },
                    26 => {
                        self.paramTypes.push(is.read_string()?);
                    },
                    34 => {
                        self.returnType = is.read_string()?;
                    },
                    40 => {
                        self.isExternal = is.read_bool()?;
                    },
                    48 => {
                        self.lineNumber = is.read_uint32()?;
                    },
                    56 => {
                        self.columnNumber = is.read_uint32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.callName.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.callName);
            }
            if !self.resolvedMethod.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.resolvedMethod);
            }
            for value in &self.paramTypes {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            if !self.returnType.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.returnType);
            }
            if self.isExternal != false {
                my_size += 1 + 1;
            }
            if self.lineNumber != 0 {
                my_size += ::protobuf::rt::uint32_size(6, self.lineNumber);
            }
            if self.columnNumber != 0 {
                my_size += ::protobuf::rt::uint32_size(7, self.columnNumber);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.callName.is_empty() {
                os.write_string(1, &self.callName)?;
            }
            if !self.resolvedMethod.is_empty() {
                os.write_string(2, &self.resolvedMethod)?;
            }
            for v in &self.paramTypes {
                os.write_string(3, &v)?;
            };
            if !self.returnType.is_empty() {
                os.write_string(4, &self.returnType)?;
            }
            if self.isExternal != false {
                os.write_bool(5, self.isExternal)?;
            }
            if self.lineNumber != 0 {
                os.write_uint32(6, self.lineNumber)?;
            }
            if self.columnNumber != 0 {
                os.write_uint32(7, self.columnNumber)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> InvokedCalls {
            InvokedCalls::new()
        }

        fn clear(&mut self) {
            self.callName.clear();
            self.resolvedMethod.clear();
            self.paramTypes.clear();
            self.returnType.clear();
            self.isExternal = false;
            self.lineNumber = 0;
            self.columnNumber = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static InvokedCalls {
            static instance: InvokedCalls = InvokedCalls {
                callName: ::std::string::String::new(),
                resolvedMethod: ::std::string::String::new(),
                paramTypes: ::std::vec::Vec::new(),
                returnType: ::std::string::String::new(),
                isExternal: false,
                lineNumber: 0,
                columnNumber: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for InvokedCalls {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("UsageSlice.InvokedCalls").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for InvokedCalls {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for InvokedCalls {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  The calls this object is observed to be an argument of.
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:atom.UsageSlice.ArgToCalls)
    pub struct ArgToCalls {
        // message fields
        ///  Call method name
        // @@protoc_insertion_point(field:atom.UsageSlice.ArgToCalls.callName)
        pub callName: ::std::string::String,
        ///  Full name of the resolved method
        // @@protoc_insertion_point(field:atom.UsageSlice.ArgToCalls.resolvedMethod)
        pub resolvedMethod: ::std::string::String,
        ///  Types of the parameters
        // @@protoc_insertion_point(field:atom.UsageSlice.ArgToCalls.paramTypes)
        pub paramTypes: ::std::vec::Vec<::std::string::String>,
        ///  Return type
        // @@protoc_insertion_point(field:atom.UsageSlice.ArgToCalls.returnType)
        pub returnType: ::std::string::String,
        ///  Argument position
        // @@protoc_insertion_point(field:atom.UsageSlice.ArgToCalls.position)
        pub position: u32,
        ///  Boolean to indicate if the call belongs to an external method
        // @@protoc_insertion_point(field:atom.UsageSlice.ArgToCalls.isExternal)
        pub isExternal: bool,
        ///  Line number
        // @@protoc_insertion_point(field:atom.UsageSlice.ArgToCalls.lineNumber)
        pub lineNumber: u32,
        ///  Column number
        // @@protoc_insertion_point(field:atom.UsageSlice.ArgToCalls.columnNumber)
        pub columnNumber: u32,
        // special fields
        // @@protoc_insertion_point(special_field:atom.UsageSlice.ArgToCalls.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ArgToCalls {
        fn default() -> &'a ArgToCalls {
            <ArgToCalls as ::protobuf::Message>::default_instance()
        }
    }

    impl ArgToCalls {
        pub fn new() -> ArgToCalls {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "callName",
                |m: &ArgToCalls| { &m.callName },
                |m: &mut ArgToCalls| { &mut m.callName },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "resolvedMethod",
                |m: &ArgToCalls| { &m.resolvedMethod },
                |m: &mut ArgToCalls| { &mut m.resolvedMethod },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "paramTypes",
                |m: &ArgToCalls| { &m.paramTypes },
                |m: &mut ArgToCalls| { &mut m.paramTypes },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "returnType",
                |m: &ArgToCalls| { &m.returnType },
                |m: &mut ArgToCalls| { &mut m.returnType },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "position",
                |m: &ArgToCalls| { &m.position },
                |m: &mut ArgToCalls| { &mut m.position },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "isExternal",
                |m: &ArgToCalls| { &m.isExternal },
                |m: &mut ArgToCalls| { &mut m.isExternal },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "lineNumber",
                |m: &ArgToCalls| { &m.lineNumber },
                |m: &mut ArgToCalls| { &mut m.lineNumber },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "columnNumber",
                |m: &ArgToCalls| { &m.columnNumber },
                |m: &mut ArgToCalls| { &mut m.columnNumber },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ArgToCalls>(
                "UsageSlice.ArgToCalls",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ArgToCalls {
        const NAME: &'static str = "ArgToCalls";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.callName = is.read_string()?;
                    },
                    18 => {
                        self.resolvedMethod = is.read_string()?;
                    },
                    26 => {
                        self.paramTypes.push(is.read_string()?);
                    },
                    34 => {
                        self.returnType = is.read_string()?;
                    },
                    40 => {
                        self.position = is.read_uint32()?;
                    },
                    48 => {
                        self.isExternal = is.read_bool()?;
                    },
                    56 => {
                        self.lineNumber = is.read_uint32()?;
                    },
                    64 => {
                        self.columnNumber = is.read_uint32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.callName.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.callName);
            }
            if !self.resolvedMethod.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.resolvedMethod);
            }
            for value in &self.paramTypes {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            if !self.returnType.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.returnType);
            }
            if self.position != 0 {
                my_size += ::protobuf::rt::uint32_size(5, self.position);
            }
            if self.isExternal != false {
                my_size += 1 + 1;
            }
            if self.lineNumber != 0 {
                my_size += ::protobuf::rt::uint32_size(7, self.lineNumber);
            }
            if self.columnNumber != 0 {
                my_size += ::protobuf::rt::uint32_size(8, self.columnNumber);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.callName.is_empty() {
                os.write_string(1, &self.callName)?;
            }
            if !self.resolvedMethod.is_empty() {
                os.write_string(2, &self.resolvedMethod)?;
            }
            for v in &self.paramTypes {
                os.write_string(3, &v)?;
            };
            if !self.returnType.is_empty() {
                os.write_string(4, &self.returnType)?;
            }
            if self.position != 0 {
                os.write_uint32(5, self.position)?;
            }
            if self.isExternal != false {
                os.write_bool(6, self.isExternal)?;
            }
            if self.lineNumber != 0 {
                os.write_uint32(7, self.lineNumber)?;
            }
            if self.columnNumber != 0 {
                os.write_uint32(8, self.columnNumber)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ArgToCalls {
            ArgToCalls::new()
        }

        fn clear(&mut self) {
            self.callName.clear();
            self.resolvedMethod.clear();
            self.paramTypes.clear();
            self.returnType.clear();
            self.position = 0;
            self.isExternal = false;
            self.lineNumber = 0;
            self.columnNumber = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ArgToCalls {
            static instance: ArgToCalls = ArgToCalls {
                callName: ::std::string::String::new(),
                resolvedMethod: ::std::string::String::new(),
                paramTypes: ::std::vec::Vec::new(),
                returnType: ::std::string::String::new(),
                position: 0,
                isExternal: false,
                lineNumber: 0,
                columnNumber: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ArgToCalls {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("UsageSlice.ArgToCalls").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ArgToCalls {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ArgToCalls {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Describes where and how the given external object/type is used
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:atom.UsageSlice.ObjectUsageSlice)
    pub struct ObjectUsageSlice {
        // message fields
        // @@protoc_insertion_point(field:atom.UsageSlice.ObjectUsageSlice.targetObj)
        pub targetObj: ::protobuf::MessageField<TargetObj>,
        // @@protoc_insertion_point(field:atom.UsageSlice.ObjectUsageSlice.definedBy)
        pub definedBy: ::protobuf::MessageField<DefinedBy>,
        // @@protoc_insertion_point(field:atom.UsageSlice.ObjectUsageSlice.invokedCalls)
        pub invokedCalls: ::std::vec::Vec<InvokedCalls>,
        // @@protoc_insertion_point(field:atom.UsageSlice.ObjectUsageSlice.argToCalls)
        pub argToCalls: ::std::vec::Vec<ArgToCalls>,
        // special fields
        // @@protoc_insertion_point(special_field:atom.UsageSlice.ObjectUsageSlice.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ObjectUsageSlice {
        fn default() -> &'a ObjectUsageSlice {
            <ObjectUsageSlice as ::protobuf::Message>::default_instance()
        }
    }

    impl ObjectUsageSlice {
        pub fn new() -> ObjectUsageSlice {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TargetObj>(
                "targetObj",
                |m: &ObjectUsageSlice| { &m.targetObj },
                |m: &mut ObjectUsageSlice| { &mut m.targetObj },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DefinedBy>(
                "definedBy",
                |m: &ObjectUsageSlice| { &m.definedBy },
                |m: &mut ObjectUsageSlice| { &mut m.definedBy },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "invokedCalls",
                |m: &ObjectUsageSlice| { &m.invokedCalls },
                |m: &mut ObjectUsageSlice| { &mut m.invokedCalls },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "argToCalls",
                |m: &ObjectUsageSlice| { &m.argToCalls },
                |m: &mut ObjectUsageSlice| { &mut m.argToCalls },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ObjectUsageSlice>(
                "UsageSlice.ObjectUsageSlice",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ObjectUsageSlice {
        const NAME: &'static str = "ObjectUsageSlice";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.targetObj)?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.definedBy)?;
                    },
                    26 => {
                        self.invokedCalls.push(is.read_message()?);
                    },
                    34 => {
                        self.argToCalls.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.targetObj.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.definedBy.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.invokedCalls {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.argToCalls {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.targetObj.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.definedBy.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            for v in &self.invokedCalls {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            for v in &self.argToCalls {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ObjectUsageSlice {
            ObjectUsageSlice::new()
        }

        fn clear(&mut self) {
            self.targetObj.clear();
            self.definedBy.clear();
            self.invokedCalls.clear();
            self.argToCalls.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ObjectUsageSlice {
            static instance: ObjectUsageSlice = ObjectUsageSlice {
                targetObj: ::protobuf::MessageField::none(),
                definedBy: ::protobuf::MessageField::none(),
                invokedCalls: ::std::vec::Vec::new(),
                argToCalls: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ObjectUsageSlice {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("UsageSlice.ObjectUsageSlice").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ObjectUsageSlice {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ObjectUsageSlice {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Packages the object usage slices along with location and an optional method source code.
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:atom.UsageSlice.MethodUsageSlice)
    pub struct MethodUsageSlice {
        // message fields
        ///  Raw source code of the method
        // @@protoc_insertion_point(field:atom.UsageSlice.MethodUsageSlice.code)
        pub code: ::std::string::String,
        ///  Method full name
        // @@protoc_insertion_point(field:atom.UsageSlice.MethodUsageSlice.fullName)
        pub fullName: ::std::string::String,
        ///  File name
        // @@protoc_insertion_point(field:atom.UsageSlice.MethodUsageSlice.fileName)
        pub fileName: ::std::string::String,
        ///  Line number
        // @@protoc_insertion_point(field:atom.UsageSlice.MethodUsageSlice.lineNumber)
        pub lineNumber: u32,
        ///  Column number
        // @@protoc_insertion_point(field:atom.UsageSlice.MethodUsageSlice.columnNumber)
        pub columnNumber: u32,
        // @@protoc_insertion_point(field:atom.UsageSlice.MethodUsageSlice.usages)
        pub usages: ::std::vec::Vec<ObjectUsageSlice>,
        // special fields
        // @@protoc_insertion_point(special_field:atom.UsageSlice.MethodUsageSlice.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MethodUsageSlice {
        fn default() -> &'a MethodUsageSlice {
            <MethodUsageSlice as ::protobuf::Message>::default_instance()
        }
    }

    impl MethodUsageSlice {
        pub fn new() -> MethodUsageSlice {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "code",
                |m: &MethodUsageSlice| { &m.code },
                |m: &mut MethodUsageSlice| { &mut m.code },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "fullName",
                |m: &MethodUsageSlice| { &m.fullName },
                |m: &mut MethodUsageSlice| { &mut m.fullName },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "fileName",
                |m: &MethodUsageSlice| { &m.fileName },
                |m: &mut MethodUsageSlice| { &mut m.fileName },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "lineNumber",
                |m: &MethodUsageSlice| { &m.lineNumber },
                |m: &mut MethodUsageSlice| { &mut m.lineNumber },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "columnNumber",
                |m: &MethodUsageSlice| { &m.columnNumber },
                |m: &mut MethodUsageSlice| { &mut m.columnNumber },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "usages",
                |m: &MethodUsageSlice| { &m.usages },
                |m: &mut MethodUsageSlice| { &mut m.usages },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MethodUsageSlice>(
                "UsageSlice.MethodUsageSlice",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MethodUsageSlice {
        const NAME: &'static str = "MethodUsageSlice";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.code = is.read_string()?;
                    },
                    18 => {
                        self.fullName = is.read_string()?;
                    },
                    26 => {
                        self.fileName = is.read_string()?;
                    },
                    32 => {
                        self.lineNumber = is.read_uint32()?;
                    },
                    40 => {
                        self.columnNumber = is.read_uint32()?;
                    },
                    50 => {
                        self.usages.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.code.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.code);
            }
            if !self.fullName.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.fullName);
            }
            if !self.fileName.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.fileName);
            }
            if self.lineNumber != 0 {
                my_size += ::protobuf::rt::uint32_size(4, self.lineNumber);
            }
            if self.columnNumber != 0 {
                my_size += ::protobuf::rt::uint32_size(5, self.columnNumber);
            }
            for value in &self.usages {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.code.is_empty() {
                os.write_string(1, &self.code)?;
            }
            if !self.fullName.is_empty() {
                os.write_string(2, &self.fullName)?;
            }
            if !self.fileName.is_empty() {
                os.write_string(3, &self.fileName)?;
            }
            if self.lineNumber != 0 {
                os.write_uint32(4, self.lineNumber)?;
            }
            if self.columnNumber != 0 {
                os.write_uint32(5, self.columnNumber)?;
            }
            for v in &self.usages {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MethodUsageSlice {
            MethodUsageSlice::new()
        }

        fn clear(&mut self) {
            self.code.clear();
            self.fullName.clear();
            self.fileName.clear();
            self.lineNumber = 0;
            self.columnNumber = 0;
            self.usages.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MethodUsageSlice {
            static instance: MethodUsageSlice = MethodUsageSlice {
                code: ::std::string::String::new(),
                fullName: ::std::string::String::new(),
                fileName: ::std::string::String::new(),
                lineNumber: 0,
                columnNumber: 0,
                usages: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MethodUsageSlice {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("UsageSlice.MethodUsageSlice").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MethodUsageSlice {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MethodUsageSlice {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Represents a local transfer of data via aliasing. The data defined is via some alias.
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:atom.UsageSlice.Fields)
    pub struct Fields {
        // message fields
        ///  Name of the local variable
        // @@protoc_insertion_point(field:atom.UsageSlice.Fields.name)
        pub name: ::std::string::String,
        ///  Full name of the type
        // @@protoc_insertion_point(field:atom.UsageSlice.Fields.typeFullName)
        pub typeFullName: ::std::string::String,
        ///  Line number
        // @@protoc_insertion_point(field:atom.UsageSlice.Fields.lineNumber)
        pub lineNumber: u32,
        ///  Column number
        // @@protoc_insertion_point(field:atom.UsageSlice.Fields.columnNumber)
        pub columnNumber: u32,
        ///  Type of the definition. Usually LOCAL
        // @@protoc_insertion_point(field:atom.UsageSlice.Fields.label)
        pub label: ::protobuf::EnumOrUnknown<LabelType>,
        // special fields
        // @@protoc_insertion_point(special_field:atom.UsageSlice.Fields.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Fields {
        fn default() -> &'a Fields {
            <Fields as ::protobuf::Message>::default_instance()
        }
    }

    impl Fields {
        pub fn new() -> Fields {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "name",
                |m: &Fields| { &m.name },
                |m: &mut Fields| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "typeFullName",
                |m: &Fields| { &m.typeFullName },
                |m: &mut Fields| { &mut m.typeFullName },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "lineNumber",
                |m: &Fields| { &m.lineNumber },
                |m: &mut Fields| { &mut m.lineNumber },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "columnNumber",
                |m: &Fields| { &m.columnNumber },
                |m: &mut Fields| { &mut m.columnNumber },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "label",
                |m: &Fields| { &m.label },
                |m: &mut Fields| { &mut m.label },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Fields>(
                "UsageSlice.Fields",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Fields {
        const NAME: &'static str = "Fields";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = is.read_string()?;
                    },
                    18 => {
                        self.typeFullName = is.read_string()?;
                    },
                    24 => {
                        self.lineNumber = is.read_uint32()?;
                    },
                    32 => {
                        self.columnNumber = is.read_uint32()?;
                    },
                    40 => {
                        self.label = is.read_enum_or_unknown()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.name.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.name);
            }
            if !self.typeFullName.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.typeFullName);
            }
            if self.lineNumber != 0 {
                my_size += ::protobuf::rt::uint32_size(3, self.lineNumber);
            }
            if self.columnNumber != 0 {
                my_size += ::protobuf::rt::uint32_size(4, self.columnNumber);
            }
            if self.label != ::protobuf::EnumOrUnknown::new(LabelType::ANY) {
                my_size += ::protobuf::rt::int32_size(5, self.label.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.name.is_empty() {
                os.write_string(1, &self.name)?;
            }
            if !self.typeFullName.is_empty() {
                os.write_string(2, &self.typeFullName)?;
            }
            if self.lineNumber != 0 {
                os.write_uint32(3, self.lineNumber)?;
            }
            if self.columnNumber != 0 {
                os.write_uint32(4, self.columnNumber)?;
            }
            if self.label != ::protobuf::EnumOrUnknown::new(LabelType::ANY) {
                os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.label))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Fields {
            Fields::new()
        }

        fn clear(&mut self) {
            self.name.clear();
            self.typeFullName.clear();
            self.lineNumber = 0;
            self.columnNumber = 0;
            self.label = ::protobuf::EnumOrUnknown::new(LabelType::ANY);
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Fields {
            static instance: Fields = Fields {
                name: ::std::string::String::new(),
                typeFullName: ::std::string::String::new(),
                lineNumber: 0,
                columnNumber: 0,
                label: ::protobuf::EnumOrUnknown::from_i32(0),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Fields {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("UsageSlice.Fields").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Fields {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Fields {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Details related to an observed call.
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:atom.UsageSlice.Procedures)
    pub struct Procedures {
        // message fields
        ///  Name of the method or call
        // @@protoc_insertion_point(field:atom.UsageSlice.Procedures.callName)
        pub callName: ::std::string::String,
        ///  Full name of the resolved method
        // @@protoc_insertion_point(field:atom.UsageSlice.Procedures.resolvedMethod)
        pub resolvedMethod: ::std::string::String,
        ///  Types of the parameters
        // @@protoc_insertion_point(field:atom.UsageSlice.Procedures.paramTypes)
        pub paramTypes: ::std::vec::Vec<::std::string::String>,
        ///  Type of the return value
        // @@protoc_insertion_point(field:atom.UsageSlice.Procedures.returnType)
        pub returnType: ::std::string::String,
        ///  Line number
        // @@protoc_insertion_point(field:atom.UsageSlice.Procedures.lineNumber)
        pub lineNumber: u32,
        ///  Column number
        // @@protoc_insertion_point(field:atom.UsageSlice.Procedures.columnNumber)
        pub columnNumber: u32,
        // special fields
        // @@protoc_insertion_point(special_field:atom.UsageSlice.Procedures.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Procedures {
        fn default() -> &'a Procedures {
            <Procedures as ::protobuf::Message>::default_instance()
        }
    }

    impl Procedures {
        pub fn new() -> Procedures {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "callName",
                |m: &Procedures| { &m.callName },
                |m: &mut Procedures| { &mut m.callName },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "resolvedMethod",
                |m: &Procedures| { &m.resolvedMethod },
                |m: &mut Procedures| { &mut m.resolvedMethod },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "paramTypes",
                |m: &Procedures| { &m.paramTypes },
                |m: &mut Procedures| { &mut m.paramTypes },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "returnType",
                |m: &Procedures| { &m.returnType },
                |m: &mut Procedures| { &mut m.returnType },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "lineNumber",
                |m: &Procedures| { &m.lineNumber },
                |m: &mut Procedures| { &mut m.lineNumber },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "columnNumber",
                |m: &Procedures| { &m.columnNumber },
                |m: &mut Procedures| { &mut m.columnNumber },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Procedures>(
                "UsageSlice.Procedures",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Procedures {
        const NAME: &'static str = "Procedures";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.callName = is.read_string()?;
                    },
                    18 => {
                        self.resolvedMethod = is.read_string()?;
                    },
                    26 => {
                        self.paramTypes.push(is.read_string()?);
                    },
                    34 => {
                        self.returnType = is.read_string()?;
                    },
                    40 => {
                        self.lineNumber = is.read_uint32()?;
                    },
                    48 => {
                        self.columnNumber = is.read_uint32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.callName.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.callName);
            }
            if !self.resolvedMethod.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.resolvedMethod);
            }
            for value in &self.paramTypes {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            if !self.returnType.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.returnType);
            }
            if self.lineNumber != 0 {
                my_size += ::protobuf::rt::uint32_size(5, self.lineNumber);
            }
            if self.columnNumber != 0 {
                my_size += ::protobuf::rt::uint32_size(6, self.columnNumber);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.callName.is_empty() {
                os.write_string(1, &self.callName)?;
            }
            if !self.resolvedMethod.is_empty() {
                os.write_string(2, &self.resolvedMethod)?;
            }
            for v in &self.paramTypes {
                os.write_string(3, &v)?;
            };
            if !self.returnType.is_empty() {
                os.write_string(4, &self.returnType)?;
            }
            if self.lineNumber != 0 {
                os.write_uint32(5, self.lineNumber)?;
            }
            if self.columnNumber != 0 {
                os.write_uint32(6, self.columnNumber)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Procedures {
            Procedures::new()
        }

        fn clear(&mut self) {
            self.callName.clear();
            self.resolvedMethod.clear();
            self.paramTypes.clear();
            self.returnType.clear();
            self.lineNumber = 0;
            self.columnNumber = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Procedures {
            static instance: Procedures = Procedures {
                callName: ::std::string::String::new(),
                resolvedMethod: ::std::string::String::new(),
                paramTypes: ::std::vec::Vec::new(),
                returnType: ::std::string::String::new(),
                lineNumber: 0,
                columnNumber: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Procedures {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("UsageSlice.Procedures").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Procedures {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Procedures {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Describes custom types defined within the application.
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:atom.UsageSlice.UserDefinedTypes)
    pub struct UserDefinedTypes {
        // message fields
        ///  Name of the type
        // @@protoc_insertion_point(field:atom.UsageSlice.UserDefinedTypes.name)
        pub name: ::std::string::String,
        // @@protoc_insertion_point(field:atom.UsageSlice.UserDefinedTypes.fields)
        pub fields: ::std::vec::Vec<Fields>,
        // @@protoc_insertion_point(field:atom.UsageSlice.UserDefinedTypes.procedures)
        pub procedures: ::std::vec::Vec<Procedures>,
        ///  File name
        // @@protoc_insertion_point(field:atom.UsageSlice.UserDefinedTypes.fileName)
        pub fileName: ::std::string::String,
        ///  Line number
        // @@protoc_insertion_point(field:atom.UsageSlice.UserDefinedTypes.lineNumber)
        pub lineNumber: u32,
        ///  Column number
        // @@protoc_insertion_point(field:atom.UsageSlice.UserDefinedTypes.columnNumber)
        pub columnNumber: u32,
        // special fields
        // @@protoc_insertion_point(special_field:atom.UsageSlice.UserDefinedTypes.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UserDefinedTypes {
        fn default() -> &'a UserDefinedTypes {
            <UserDefinedTypes as ::protobuf::Message>::default_instance()
        }
    }

    impl UserDefinedTypes {
        pub fn new() -> UserDefinedTypes {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "name",
                |m: &UserDefinedTypes| { &m.name },
                |m: &mut UserDefinedTypes| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "fields",
                |m: &UserDefinedTypes| { &m.fields },
                |m: &mut UserDefinedTypes| { &mut m.fields },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "procedures",
                |m: &UserDefinedTypes| { &m.procedures },
                |m: &mut UserDefinedTypes| { &mut m.procedures },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "fileName",
                |m: &UserDefinedTypes| { &m.fileName },
                |m: &mut UserDefinedTypes| { &mut m.fileName },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "lineNumber",
                |m: &UserDefinedTypes| { &m.lineNumber },
                |m: &mut UserDefinedTypes| { &mut m.lineNumber },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "columnNumber",
                |m: &UserDefinedTypes| { &m.columnNumber },
                |m: &mut UserDefinedTypes| { &mut m.columnNumber },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserDefinedTypes>(
                "UsageSlice.UserDefinedTypes",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for UserDefinedTypes {
        const NAME: &'static str = "UserDefinedTypes";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = is.read_string()?;
                    },
                    18 => {
                        self.fields.push(is.read_message()?);
                    },
                    26 => {
                        self.procedures.push(is.read_message()?);
                    },
                    34 => {
                        self.fileName = is.read_string()?;
                    },
                    40 => {
                        self.lineNumber = is.read_uint32()?;
                    },
                    48 => {
                        self.columnNumber = is.read_uint32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.name.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.name);
            }
            for value in &self.fields {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.procedures {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if !self.fileName.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.fileName);
            }
            if self.lineNumber != 0 {
                my_size += ::protobuf::rt::uint32_size(5, self.lineNumber);
            }
            if self.columnNumber != 0 {
                my_size += ::protobuf::rt::uint32_size(6, self.columnNumber);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.name.is_empty() {
                os.write_string(1, &self.name)?;
            }
            for v in &self.fields {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            for v in &self.procedures {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            if !self.fileName.is_empty() {
                os.write_string(4, &self.fileName)?;
            }
            if self.lineNumber != 0 {
                os.write_uint32(5, self.lineNumber)?;
            }
            if self.columnNumber != 0 {
                os.write_uint32(6, self.columnNumber)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UserDefinedTypes {
            UserDefinedTypes::new()
        }

        fn clear(&mut self) {
            self.name.clear();
            self.fields.clear();
            self.procedures.clear();
            self.fileName.clear();
            self.lineNumber = 0;
            self.columnNumber = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UserDefinedTypes {
            static instance: UserDefinedTypes = UserDefinedTypes {
                name: ::std::string::String::new(),
                fields: ::std::vec::Vec::new(),
                procedures: ::std::vec::Vec::new(),
                fileName: ::std::string::String::new(),
                lineNumber: 0,
                columnNumber: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for UserDefinedTypes {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("UsageSlice.UserDefinedTypes").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for UserDefinedTypes {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for UserDefinedTypes {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Label type.
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:atom.UsageSlice.LabelType)
    pub enum LabelType {
        // @@protoc_insertion_point(enum_value:atom.UsageSlice.LabelType.ANY)
        ANY = 0,
        // @@protoc_insertion_point(enum_value:atom.UsageSlice.LabelType.LOCAL)
        LOCAL = 1,
        // @@protoc_insertion_point(enum_value:atom.UsageSlice.LabelType.LITERAL)
        LITERAL = 2,
        // @@protoc_insertion_point(enum_value:atom.UsageSlice.LabelType.PARAM)
        PARAM = 3,
        // @@protoc_insertion_point(enum_value:atom.UsageSlice.LabelType.CALL)
        CALL = 4,
        // @@protoc_insertion_point(enum_value:atom.UsageSlice.LabelType.IDENTIFIER)
        IDENTIFIER = 5,
        // @@protoc_insertion_point(enum_value:atom.UsageSlice.LabelType.TYPE_REF)
        TYPE_REF = 6,
        // @@protoc_insertion_point(enum_value:atom.UsageSlice.LabelType.UNKNOWN)
        UNKNOWN = 10,
    }

    impl ::protobuf::Enum for LabelType {
        const NAME: &'static str = "LabelType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<LabelType> {
            match value {
                0 => ::std::option::Option::Some(LabelType::ANY),
                1 => ::std::option::Option::Some(LabelType::LOCAL),
                2 => ::std::option::Option::Some(LabelType::LITERAL),
                3 => ::std::option::Option::Some(LabelType::PARAM),
                4 => ::std::option::Option::Some(LabelType::CALL),
                5 => ::std::option::Option::Some(LabelType::IDENTIFIER),
                6 => ::std::option::Option::Some(LabelType::TYPE_REF),
                10 => ::std::option::Option::Some(LabelType::UNKNOWN),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [LabelType] = &[
            LabelType::ANY,
            LabelType::LOCAL,
            LabelType::LITERAL,
            LabelType::PARAM,
            LabelType::CALL,
            LabelType::IDENTIFIER,
            LabelType::TYPE_REF,
            LabelType::UNKNOWN,
        ];
    }

    impl ::protobuf::EnumFull for LabelType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("UsageSlice.LabelType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                LabelType::ANY => 0,
                LabelType::LOCAL => 1,
                LabelType::LITERAL => 2,
                LabelType::PARAM => 3,
                LabelType::CALL => 4,
                LabelType::IDENTIFIER => 5,
                LabelType::TYPE_REF => 6,
                LabelType::UNKNOWN => 7,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for LabelType {
        fn default() -> Self {
            LabelType::ANY
        }
    }

    impl LabelType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<LabelType>("UsageSlice.LabelType")
        }
    }
}

/// *
///  DataFlow slices offers a list of nodes and edges exported from data dependency graph
///
///  ![Data Flow slices overview](./docs/Data%20Flows.png)
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:atom.DataFlowSlice)
pub struct DataFlowSlice {
    // message fields
    // @@protoc_insertion_point(field:atom.DataFlowSlice.graph)
    pub graph: ::protobuf::MessageField<data_flow_slice::Graph>,
    // @@protoc_insertion_point(field:atom.DataFlowSlice.path)
    pub path: ::protobuf::MessageField<data_flow_slice::Paths>,
    // special fields
    // @@protoc_insertion_point(special_field:atom.DataFlowSlice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DataFlowSlice {
    fn default() -> &'a DataFlowSlice {
        <DataFlowSlice as ::protobuf::Message>::default_instance()
    }
}

impl DataFlowSlice {
    pub fn new() -> DataFlowSlice {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, data_flow_slice::Graph>(
            "graph",
            |m: &DataFlowSlice| { &m.graph },
            |m: &mut DataFlowSlice| { &mut m.graph },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, data_flow_slice::Paths>(
            "path",
            |m: &DataFlowSlice| { &m.path },
            |m: &mut DataFlowSlice| { &mut m.path },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DataFlowSlice>(
            "DataFlowSlice",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DataFlowSlice {
    const NAME: &'static str = "DataFlowSlice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.graph)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.path)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.graph.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.path.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.graph.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.path.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DataFlowSlice {
        DataFlowSlice::new()
    }

    fn clear(&mut self) {
        self.graph.clear();
        self.path.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DataFlowSlice {
        static instance: DataFlowSlice = DataFlowSlice {
            graph: ::protobuf::MessageField::none(),
            path: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DataFlowSlice {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DataFlowSlice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DataFlowSlice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataFlowSlice {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `DataFlowSlice`
pub mod data_flow_slice {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:atom.DataFlowSlice.Nodes)
    pub struct Nodes {
        // message fields
        ///  Id of the node
        // @@protoc_insertion_point(field:atom.DataFlowSlice.Nodes.id)
        pub id: u32,
        ///  Label
        // @@protoc_insertion_point(field:atom.DataFlowSlice.Nodes.label)
        pub label: ::protobuf::EnumOrUnknown<super::NodeType>,
        ///  Name of the call or identifier or parameter
        // @@protoc_insertion_point(field:atom.DataFlowSlice.Nodes.name)
        pub name: ::std::string::String,
        ///  Full name of the call
        // @@protoc_insertion_point(field:atom.DataFlowSlice.Nodes.fullName)
        pub fullName: ::std::string::String,
        ///  Method signature of the call
        // @@protoc_insertion_point(field:atom.DataFlowSlice.Nodes.signature)
        pub signature: ::std::string::String,
        ///  Boolean to indicate if this call belongs to an external method
        // @@protoc_insertion_point(field:atom.DataFlowSlice.Nodes.isExternal)
        pub isExternal: bool,
        ///  Source code
        // @@protoc_insertion_point(field:atom.DataFlowSlice.Nodes.code)
        pub code: ::std::string::String,
        ///  Type full name
        // @@protoc_insertion_point(field:atom.DataFlowSlice.Nodes.typeFullName)
        pub typeFullName: ::std::string::String,
        ///  Parent method name
        // @@protoc_insertion_point(field:atom.DataFlowSlice.Nodes.parentMethodName)
        pub parentMethodName: ::std::string::String,
        ///  Parent filename
        // @@protoc_insertion_point(field:atom.DataFlowSlice.Nodes.parentFileName)
        pub parentFileName: ::std::string::String,
        ///  Parent package name
        // @@protoc_insertion_point(field:atom.DataFlowSlice.Nodes.parentPackageName)
        pub parentPackageName: ::std::string::String,
        ///  Parent class name
        // @@protoc_insertion_point(field:atom.DataFlowSlice.Nodes.parentClassName)
        pub parentClassName: ::std::string::String,
        ///  Line number
        // @@protoc_insertion_point(field:atom.DataFlowSlice.Nodes.lineNumber)
        pub lineNumber: u32,
        ///  Column number
        // @@protoc_insertion_point(field:atom.DataFlowSlice.Nodes.columnNumber)
        pub columnNumber: u32,
        // special fields
        // @@protoc_insertion_point(special_field:atom.DataFlowSlice.Nodes.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Nodes {
        fn default() -> &'a Nodes {
            <Nodes as ::protobuf::Message>::default_instance()
        }
    }

    impl Nodes {
        pub fn new() -> Nodes {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(14);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "id",
                |m: &Nodes| { &m.id },
                |m: &mut Nodes| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "label",
                |m: &Nodes| { &m.label },
                |m: &mut Nodes| { &mut m.label },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "name",
                |m: &Nodes| { &m.name },
                |m: &mut Nodes| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "fullName",
                |m: &Nodes| { &m.fullName },
                |m: &mut Nodes| { &mut m.fullName },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "signature",
                |m: &Nodes| { &m.signature },
                |m: &mut Nodes| { &mut m.signature },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "isExternal",
                |m: &Nodes| { &m.isExternal },
                |m: &mut Nodes| { &mut m.isExternal },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "code",
                |m: &Nodes| { &m.code },
                |m: &mut Nodes| { &mut m.code },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "typeFullName",
                |m: &Nodes| { &m.typeFullName },
                |m: &mut Nodes| { &mut m.typeFullName },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "parentMethodName",
                |m: &Nodes| { &m.parentMethodName },
                |m: &mut Nodes| { &mut m.parentMethodName },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "parentFileName",
                |m: &Nodes| { &m.parentFileName },
                |m: &mut Nodes| { &mut m.parentFileName },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "parentPackageName",
                |m: &Nodes| { &m.parentPackageName },
                |m: &mut Nodes| { &mut m.parentPackageName },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "parentClassName",
                |m: &Nodes| { &m.parentClassName },
                |m: &mut Nodes| { &mut m.parentClassName },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "lineNumber",
                |m: &Nodes| { &m.lineNumber },
                |m: &mut Nodes| { &mut m.lineNumber },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "columnNumber",
                |m: &Nodes| { &m.columnNumber },
                |m: &mut Nodes| { &mut m.columnNumber },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Nodes>(
                "DataFlowSlice.Nodes",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Nodes {
        const NAME: &'static str = "Nodes";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = is.read_uint32()?;
                    },
                    16 => {
                        self.label = is.read_enum_or_unknown()?;
                    },
                    26 => {
                        self.name = is.read_string()?;
                    },
                    34 => {
                        self.fullName = is.read_string()?;
                    },
                    42 => {
                        self.signature = is.read_string()?;
                    },
                    48 => {
                        self.isExternal = is.read_bool()?;
                    },
                    58 => {
                        self.code = is.read_string()?;
                    },
                    66 => {
                        self.typeFullName = is.read_string()?;
                    },
                    74 => {
                        self.parentMethodName = is.read_string()?;
                    },
                    82 => {
                        self.parentFileName = is.read_string()?;
                    },
                    90 => {
                        self.parentPackageName = is.read_string()?;
                    },
                    98 => {
                        self.parentClassName = is.read_string()?;
                    },
                    104 => {
                        self.lineNumber = is.read_uint32()?;
                    },
                    112 => {
                        self.columnNumber = is.read_uint32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.id != 0 {
                my_size += ::protobuf::rt::uint32_size(1, self.id);
            }
            if self.label != ::protobuf::EnumOrUnknown::new(super::NodeType::UNKNOWN_NODE_TYPE) {
                my_size += ::protobuf::rt::int32_size(2, self.label.value());
            }
            if !self.name.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.name);
            }
            if !self.fullName.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.fullName);
            }
            if !self.signature.is_empty() {
                my_size += ::protobuf::rt::string_size(5, &self.signature);
            }
            if self.isExternal != false {
                my_size += 1 + 1;
            }
            if !self.code.is_empty() {
                my_size += ::protobuf::rt::string_size(7, &self.code);
            }
            if !self.typeFullName.is_empty() {
                my_size += ::protobuf::rt::string_size(8, &self.typeFullName);
            }
            if !self.parentMethodName.is_empty() {
                my_size += ::protobuf::rt::string_size(9, &self.parentMethodName);
            }
            if !self.parentFileName.is_empty() {
                my_size += ::protobuf::rt::string_size(10, &self.parentFileName);
            }
            if !self.parentPackageName.is_empty() {
                my_size += ::protobuf::rt::string_size(11, &self.parentPackageName);
            }
            if !self.parentClassName.is_empty() {
                my_size += ::protobuf::rt::string_size(12, &self.parentClassName);
            }
            if self.lineNumber != 0 {
                my_size += ::protobuf::rt::uint32_size(13, self.lineNumber);
            }
            if self.columnNumber != 0 {
                my_size += ::protobuf::rt::uint32_size(14, self.columnNumber);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.id != 0 {
                os.write_uint32(1, self.id)?;
            }
            if self.label != ::protobuf::EnumOrUnknown::new(super::NodeType::UNKNOWN_NODE_TYPE) {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.label))?;
            }
            if !self.name.is_empty() {
                os.write_string(3, &self.name)?;
            }
            if !self.fullName.is_empty() {
                os.write_string(4, &self.fullName)?;
            }
            if !self.signature.is_empty() {
                os.write_string(5, &self.signature)?;
            }
            if self.isExternal != false {
                os.write_bool(6, self.isExternal)?;
            }
            if !self.code.is_empty() {
                os.write_string(7, &self.code)?;
            }
            if !self.typeFullName.is_empty() {
                os.write_string(8, &self.typeFullName)?;
            }
            if !self.parentMethodName.is_empty() {
                os.write_string(9, &self.parentMethodName)?;
            }
            if !self.parentFileName.is_empty() {
                os.write_string(10, &self.parentFileName)?;
            }
            if !self.parentPackageName.is_empty() {
                os.write_string(11, &self.parentPackageName)?;
            }
            if !self.parentClassName.is_empty() {
                os.write_string(12, &self.parentClassName)?;
            }
            if self.lineNumber != 0 {
                os.write_uint32(13, self.lineNumber)?;
            }
            if self.columnNumber != 0 {
                os.write_uint32(14, self.columnNumber)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Nodes {
            Nodes::new()
        }

        fn clear(&mut self) {
            self.id = 0;
            self.label = ::protobuf::EnumOrUnknown::new(super::NodeType::UNKNOWN_NODE_TYPE);
            self.name.clear();
            self.fullName.clear();
            self.signature.clear();
            self.isExternal = false;
            self.code.clear();
            self.typeFullName.clear();
            self.parentMethodName.clear();
            self.parentFileName.clear();
            self.parentPackageName.clear();
            self.parentClassName.clear();
            self.lineNumber = 0;
            self.columnNumber = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Nodes {
            static instance: Nodes = Nodes {
                id: 0,
                label: ::protobuf::EnumOrUnknown::from_i32(0),
                name: ::std::string::String::new(),
                fullName: ::std::string::String::new(),
                signature: ::std::string::String::new(),
                isExternal: false,
                code: ::std::string::String::new(),
                typeFullName: ::std::string::String::new(),
                parentMethodName: ::std::string::String::new(),
                parentFileName: ::std::string::String::new(),
                parentPackageName: ::std::string::String::new(),
                parentClassName: ::std::string::String::new(),
                lineNumber: 0,
                columnNumber: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Nodes {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("DataFlowSlice.Nodes").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Nodes {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Nodes {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:atom.DataFlowSlice.Edges)
    pub struct Edges {
        // message fields
        ///  Source node id
        // @@protoc_insertion_point(field:atom.DataFlowSlice.Edges.src)
        pub src: u32,
        ///  Destination node id
        // @@protoc_insertion_point(field:atom.DataFlowSlice.Edges.dst)
        pub dst: u32,
        ///  Edge type
        // @@protoc_insertion_point(field:atom.DataFlowSlice.Edges.label)
        pub label: ::protobuf::EnumOrUnknown<super::cpg_struct::edge::EdgeType>,
        // special fields
        // @@protoc_insertion_point(special_field:atom.DataFlowSlice.Edges.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Edges {
        fn default() -> &'a Edges {
            <Edges as ::protobuf::Message>::default_instance()
        }
    }

    impl Edges {
        pub fn new() -> Edges {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "src",
                |m: &Edges| { &m.src },
                |m: &mut Edges| { &mut m.src },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "dst",
                |m: &Edges| { &m.dst },
                |m: &mut Edges| { &mut m.dst },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "label",
                |m: &Edges| { &m.label },
                |m: &mut Edges| { &mut m.label },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Edges>(
                "DataFlowSlice.Edges",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Edges {
        const NAME: &'static str = "Edges";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.src = is.read_uint32()?;
                    },
                    16 => {
                        self.dst = is.read_uint32()?;
                    },
                    24 => {
                        self.label = is.read_enum_or_unknown()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.src != 0 {
                my_size += ::protobuf::rt::uint32_size(1, self.src);
            }
            if self.dst != 0 {
                my_size += ::protobuf::rt::uint32_size(2, self.dst);
            }
            if self.label != ::protobuf::EnumOrUnknown::new(super::cpg_struct::edge::EdgeType::UNKNOWN_EDGE_TYPE) {
                my_size += ::protobuf::rt::int32_size(3, self.label.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.src != 0 {
                os.write_uint32(1, self.src)?;
            }
            if self.dst != 0 {
                os.write_uint32(2, self.dst)?;
            }
            if self.label != ::protobuf::EnumOrUnknown::new(super::cpg_struct::edge::EdgeType::UNKNOWN_EDGE_TYPE) {
                os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.label))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Edges {
            Edges::new()
        }

        fn clear(&mut self) {
            self.src = 0;
            self.dst = 0;
            self.label = ::protobuf::EnumOrUnknown::new(super::cpg_struct::edge::EdgeType::UNKNOWN_EDGE_TYPE);
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Edges {
            static instance: Edges = Edges {
                src: 0,
                dst: 0,
                label: ::protobuf::EnumOrUnknown::from_i32(0),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Edges {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("DataFlowSlice.Edges").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Edges {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Edges {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:atom.DataFlowSlice.Flows)
    pub struct Flows {
        // message fields
        ///  Node id
        // @@protoc_insertion_point(field:atom.DataFlowSlice.Flows.id)
        pub id: ::std::vec::Vec<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:atom.DataFlowSlice.Flows.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Flows {
        fn default() -> &'a Flows {
            <Flows as ::protobuf::Message>::default_instance()
        }
    }

    impl Flows {
        pub fn new() -> Flows {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "id",
                |m: &Flows| { &m.id },
                |m: &mut Flows| { &mut m.id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Flows>(
                "DataFlowSlice.Flows",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Flows {
        const NAME: &'static str = "Flows";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        is.read_repeated_packed_uint32_into(&mut self.id)?;
                    },
                    8 => {
                        self.id.push(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.id {
                my_size += ::protobuf::rt::uint32_size(1, *value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.id {
                os.write_uint32(1, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Flows {
            Flows::new()
        }

        fn clear(&mut self) {
            self.id.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Flows {
            static instance: Flows = Flows {
                id: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Flows {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("DataFlowSlice.Flows").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Flows {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Flows {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:atom.DataFlowSlice.Paths)
    pub struct Paths {
        // message fields
        ///  Flows from source to sink
        // @@protoc_insertion_point(field:atom.DataFlowSlice.Paths.flows)
        pub flows: ::std::vec::Vec<Flows>,
        // special fields
        // @@protoc_insertion_point(special_field:atom.DataFlowSlice.Paths.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Paths {
        fn default() -> &'a Paths {
            <Paths as ::protobuf::Message>::default_instance()
        }
    }

    impl Paths {
        pub fn new() -> Paths {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "flows",
                |m: &Paths| { &m.flows },
                |m: &mut Paths| { &mut m.flows },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Paths>(
                "DataFlowSlice.Paths",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Paths {
        const NAME: &'static str = "Paths";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.flows.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.flows {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.flows {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Paths {
            Paths::new()
        }

        fn clear(&mut self) {
            self.flows.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Paths {
            static instance: Paths = Paths {
                flows: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Paths {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("DataFlowSlice.Paths").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Paths {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Paths {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:atom.DataFlowSlice.Graph)
    pub struct Graph {
        // message fields
        // @@protoc_insertion_point(field:atom.DataFlowSlice.Graph.nodes)
        pub nodes: ::std::vec::Vec<Nodes>,
        // @@protoc_insertion_point(field:atom.DataFlowSlice.Graph.edges)
        pub edges: ::std::vec::Vec<Edges>,
        // special fields
        // @@protoc_insertion_point(special_field:atom.DataFlowSlice.Graph.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Graph {
        fn default() -> &'a Graph {
            <Graph as ::protobuf::Message>::default_instance()
        }
    }

    impl Graph {
        pub fn new() -> Graph {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "nodes",
                |m: &Graph| { &m.nodes },
                |m: &mut Graph| { &mut m.nodes },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "edges",
                |m: &Graph| { &m.edges },
                |m: &mut Graph| { &mut m.edges },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Graph>(
                "DataFlowSlice.Graph",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Graph {
        const NAME: &'static str = "Graph";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.nodes.push(is.read_message()?);
                    },
                    18 => {
                        self.edges.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.nodes {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.edges {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.nodes {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            for v in &self.edges {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Graph {
            Graph::new()
        }

        fn clear(&mut self) {
            self.nodes.clear();
            self.edges.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Graph {
            static instance: Graph = Graph {
                nodes: ::std::vec::Vec::new(),
                edges: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Graph {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("DataFlowSlice.Graph").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Graph {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Graph {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

///  Enum for the name of a node property
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:atom.NodePropertyName)
pub enum NodePropertyName {
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.UNKNOWN_NODE_PROPERTY)
    UNKNOWN_NODE_PROPERTY = 0,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.LINE_NUMBER)
    LINE_NUMBER = 2,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.PARSER_TYPE_NAME)
    PARSER_TYPE_NAME = 3,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.ORDER)
    ORDER = 4,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.NAME)
    NAME = 5,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.FULL_NAME)
    FULL_NAME = 6,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.IS_EXTERNAL)
    IS_EXTERNAL = 7,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.VALUE)
    VALUE = 8,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.COLUMN_NUMBER)
    COLUMN_NUMBER = 11,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.LINE_NUMBER_END)
    LINE_NUMBER_END = 12,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.VERSION)
    VERSION = 13,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.EVALUATION_STRATEGY)
    EVALUATION_STRATEGY = 15,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.COLUMN_NUMBER_END)
    COLUMN_NUMBER_END = 16,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.LANGUAGE)
    LANGUAGE = 19,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.CONTENT)
    CONTENT = 20,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.CODE)
    CODE = 21,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.SIGNATURE)
    SIGNATURE = 22,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.DISPATCH_TYPE)
    DISPATCH_TYPE = 25,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.MODIFIER_TYPE)
    MODIFIER_TYPE = 26,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.CONTROL_STRUCTURE_TYPE)
    CONTROL_STRUCTURE_TYPE = 27,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.ARGUMENT_INDEX)
    ARGUMENT_INDEX = 40,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.CLOSURE_BINDING_ID)
    CLOSURE_BINDING_ID = 50,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.TYPE_FULL_NAME)
    TYPE_FULL_NAME = 51,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.TYPE_DECL_FULL_NAME)
    TYPE_DECL_FULL_NAME = 52,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.INHERITS_FROM_TYPE_FULL_NAME)
    INHERITS_FROM_TYPE_FULL_NAME = 53,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.METHOD_FULL_NAME)
    METHOD_FULL_NAME = 54,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.AST_PARENT_TYPE)
    AST_PARENT_TYPE = 56,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.AST_PARENT_FULL_NAME)
    AST_PARENT_FULL_NAME = 57,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.DEPENDENCY_GROUP_ID)
    DEPENDENCY_GROUP_ID = 58,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.SYMBOL)
    SYMBOL = 100,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.METHOD_SHORT_NAME)
    METHOD_SHORT_NAME = 102,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.PACKAGE_NAME)
    PACKAGE_NAME = 103,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.CLASS_NAME)
    CLASS_NAME = 104,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.NODE_LABEL)
    NODE_LABEL = 105,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.FILENAME)
    FILENAME = 106,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.OVERLAYS)
    OVERLAYS = 118,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.HASH)
    HASH = 120,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.ARGUMENT_NAME)
    ARGUMENT_NAME = 130,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.KEY)
    KEY = 131,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.CLASS_SHORT_NAME)
    CLASS_SHORT_NAME = 132,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.ALIAS_TYPE_FULL_NAME)
    ALIAS_TYPE_FULL_NAME = 158,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.CLOSURE_ORIGINAL_NAME)
    CLOSURE_ORIGINAL_NAME = 159,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.IS_VARIADIC)
    IS_VARIADIC = 221,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.ROOT)
    ROOT = 1199,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.DYNAMIC_TYPE_HINT_FULL_NAME)
    DYNAMIC_TYPE_HINT_FULL_NAME = 1591,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.INDEX)
    INDEX = 2223,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.CANONICAL_NAME)
    CANONICAL_NAME = 2001092,
    // @@protoc_insertion_point(enum_value:atom.NodePropertyName.CONTAINED_REF)
    CONTAINED_REF = 2007161,
}

impl ::protobuf::Enum for NodePropertyName {
    const NAME: &'static str = "NodePropertyName";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NodePropertyName> {
        match value {
            0 => ::std::option::Option::Some(NodePropertyName::UNKNOWN_NODE_PROPERTY),
            2 => ::std::option::Option::Some(NodePropertyName::LINE_NUMBER),
            3 => ::std::option::Option::Some(NodePropertyName::PARSER_TYPE_NAME),
            4 => ::std::option::Option::Some(NodePropertyName::ORDER),
            5 => ::std::option::Option::Some(NodePropertyName::NAME),
            6 => ::std::option::Option::Some(NodePropertyName::FULL_NAME),
            7 => ::std::option::Option::Some(NodePropertyName::IS_EXTERNAL),
            8 => ::std::option::Option::Some(NodePropertyName::VALUE),
            11 => ::std::option::Option::Some(NodePropertyName::COLUMN_NUMBER),
            12 => ::std::option::Option::Some(NodePropertyName::LINE_NUMBER_END),
            13 => ::std::option::Option::Some(NodePropertyName::VERSION),
            15 => ::std::option::Option::Some(NodePropertyName::EVALUATION_STRATEGY),
            16 => ::std::option::Option::Some(NodePropertyName::COLUMN_NUMBER_END),
            19 => ::std::option::Option::Some(NodePropertyName::LANGUAGE),
            20 => ::std::option::Option::Some(NodePropertyName::CONTENT),
            21 => ::std::option::Option::Some(NodePropertyName::CODE),
            22 => ::std::option::Option::Some(NodePropertyName::SIGNATURE),
            25 => ::std::option::Option::Some(NodePropertyName::DISPATCH_TYPE),
            26 => ::std::option::Option::Some(NodePropertyName::MODIFIER_TYPE),
            27 => ::std::option::Option::Some(NodePropertyName::CONTROL_STRUCTURE_TYPE),
            40 => ::std::option::Option::Some(NodePropertyName::ARGUMENT_INDEX),
            50 => ::std::option::Option::Some(NodePropertyName::CLOSURE_BINDING_ID),
            51 => ::std::option::Option::Some(NodePropertyName::TYPE_FULL_NAME),
            52 => ::std::option::Option::Some(NodePropertyName::TYPE_DECL_FULL_NAME),
            53 => ::std::option::Option::Some(NodePropertyName::INHERITS_FROM_TYPE_FULL_NAME),
            54 => ::std::option::Option::Some(NodePropertyName::METHOD_FULL_NAME),
            56 => ::std::option::Option::Some(NodePropertyName::AST_PARENT_TYPE),
            57 => ::std::option::Option::Some(NodePropertyName::AST_PARENT_FULL_NAME),
            58 => ::std::option::Option::Some(NodePropertyName::DEPENDENCY_GROUP_ID),
            100 => ::std::option::Option::Some(NodePropertyName::SYMBOL),
            102 => ::std::option::Option::Some(NodePropertyName::METHOD_SHORT_NAME),
            103 => ::std::option::Option::Some(NodePropertyName::PACKAGE_NAME),
            104 => ::std::option::Option::Some(NodePropertyName::CLASS_NAME),
            105 => ::std::option::Option::Some(NodePropertyName::NODE_LABEL),
            106 => ::std::option::Option::Some(NodePropertyName::FILENAME),
            118 => ::std::option::Option::Some(NodePropertyName::OVERLAYS),
            120 => ::std::option::Option::Some(NodePropertyName::HASH),
            130 => ::std::option::Option::Some(NodePropertyName::ARGUMENT_NAME),
            131 => ::std::option::Option::Some(NodePropertyName::KEY),
            132 => ::std::option::Option::Some(NodePropertyName::CLASS_SHORT_NAME),
            158 => ::std::option::Option::Some(NodePropertyName::ALIAS_TYPE_FULL_NAME),
            159 => ::std::option::Option::Some(NodePropertyName::CLOSURE_ORIGINAL_NAME),
            221 => ::std::option::Option::Some(NodePropertyName::IS_VARIADIC),
            1199 => ::std::option::Option::Some(NodePropertyName::ROOT),
            1591 => ::std::option::Option::Some(NodePropertyName::DYNAMIC_TYPE_HINT_FULL_NAME),
            2223 => ::std::option::Option::Some(NodePropertyName::INDEX),
            2001092 => ::std::option::Option::Some(NodePropertyName::CANONICAL_NAME),
            2007161 => ::std::option::Option::Some(NodePropertyName::CONTAINED_REF),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [NodePropertyName] = &[
        NodePropertyName::UNKNOWN_NODE_PROPERTY,
        NodePropertyName::LINE_NUMBER,
        NodePropertyName::PARSER_TYPE_NAME,
        NodePropertyName::ORDER,
        NodePropertyName::NAME,
        NodePropertyName::FULL_NAME,
        NodePropertyName::IS_EXTERNAL,
        NodePropertyName::VALUE,
        NodePropertyName::COLUMN_NUMBER,
        NodePropertyName::LINE_NUMBER_END,
        NodePropertyName::VERSION,
        NodePropertyName::EVALUATION_STRATEGY,
        NodePropertyName::COLUMN_NUMBER_END,
        NodePropertyName::LANGUAGE,
        NodePropertyName::CONTENT,
        NodePropertyName::CODE,
        NodePropertyName::SIGNATURE,
        NodePropertyName::DISPATCH_TYPE,
        NodePropertyName::MODIFIER_TYPE,
        NodePropertyName::CONTROL_STRUCTURE_TYPE,
        NodePropertyName::ARGUMENT_INDEX,
        NodePropertyName::CLOSURE_BINDING_ID,
        NodePropertyName::TYPE_FULL_NAME,
        NodePropertyName::TYPE_DECL_FULL_NAME,
        NodePropertyName::INHERITS_FROM_TYPE_FULL_NAME,
        NodePropertyName::METHOD_FULL_NAME,
        NodePropertyName::AST_PARENT_TYPE,
        NodePropertyName::AST_PARENT_FULL_NAME,
        NodePropertyName::DEPENDENCY_GROUP_ID,
        NodePropertyName::SYMBOL,
        NodePropertyName::METHOD_SHORT_NAME,
        NodePropertyName::PACKAGE_NAME,
        NodePropertyName::CLASS_NAME,
        NodePropertyName::NODE_LABEL,
        NodePropertyName::FILENAME,
        NodePropertyName::OVERLAYS,
        NodePropertyName::HASH,
        NodePropertyName::ARGUMENT_NAME,
        NodePropertyName::KEY,
        NodePropertyName::CLASS_SHORT_NAME,
        NodePropertyName::ALIAS_TYPE_FULL_NAME,
        NodePropertyName::CLOSURE_ORIGINAL_NAME,
        NodePropertyName::IS_VARIADIC,
        NodePropertyName::ROOT,
        NodePropertyName::DYNAMIC_TYPE_HINT_FULL_NAME,
        NodePropertyName::INDEX,
        NodePropertyName::CANONICAL_NAME,
        NodePropertyName::CONTAINED_REF,
    ];
}

impl ::protobuf::EnumFull for NodePropertyName {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("NodePropertyName").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            NodePropertyName::UNKNOWN_NODE_PROPERTY => 0,
            NodePropertyName::LINE_NUMBER => 1,
            NodePropertyName::PARSER_TYPE_NAME => 2,
            NodePropertyName::ORDER => 3,
            NodePropertyName::NAME => 4,
            NodePropertyName::FULL_NAME => 5,
            NodePropertyName::IS_EXTERNAL => 6,
            NodePropertyName::VALUE => 7,
            NodePropertyName::COLUMN_NUMBER => 8,
            NodePropertyName::LINE_NUMBER_END => 9,
            NodePropertyName::VERSION => 10,
            NodePropertyName::EVALUATION_STRATEGY => 11,
            NodePropertyName::COLUMN_NUMBER_END => 12,
            NodePropertyName::LANGUAGE => 13,
            NodePropertyName::CONTENT => 14,
            NodePropertyName::CODE => 15,
            NodePropertyName::SIGNATURE => 16,
            NodePropertyName::DISPATCH_TYPE => 17,
            NodePropertyName::MODIFIER_TYPE => 18,
            NodePropertyName::CONTROL_STRUCTURE_TYPE => 19,
            NodePropertyName::ARGUMENT_INDEX => 20,
            NodePropertyName::CLOSURE_BINDING_ID => 21,
            NodePropertyName::TYPE_FULL_NAME => 22,
            NodePropertyName::TYPE_DECL_FULL_NAME => 23,
            NodePropertyName::INHERITS_FROM_TYPE_FULL_NAME => 24,
            NodePropertyName::METHOD_FULL_NAME => 25,
            NodePropertyName::AST_PARENT_TYPE => 26,
            NodePropertyName::AST_PARENT_FULL_NAME => 27,
            NodePropertyName::DEPENDENCY_GROUP_ID => 28,
            NodePropertyName::SYMBOL => 29,
            NodePropertyName::METHOD_SHORT_NAME => 30,
            NodePropertyName::PACKAGE_NAME => 31,
            NodePropertyName::CLASS_NAME => 32,
            NodePropertyName::NODE_LABEL => 33,
            NodePropertyName::FILENAME => 34,
            NodePropertyName::OVERLAYS => 35,
            NodePropertyName::HASH => 36,
            NodePropertyName::ARGUMENT_NAME => 37,
            NodePropertyName::KEY => 38,
            NodePropertyName::CLASS_SHORT_NAME => 39,
            NodePropertyName::ALIAS_TYPE_FULL_NAME => 40,
            NodePropertyName::CLOSURE_ORIGINAL_NAME => 41,
            NodePropertyName::IS_VARIADIC => 42,
            NodePropertyName::ROOT => 43,
            NodePropertyName::DYNAMIC_TYPE_HINT_FULL_NAME => 44,
            NodePropertyName::INDEX => 45,
            NodePropertyName::CANONICAL_NAME => 46,
            NodePropertyName::CONTAINED_REF => 47,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for NodePropertyName {
    fn default() -> Self {
        NodePropertyName::UNKNOWN_NODE_PROPERTY
    }
}

impl NodePropertyName {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<NodePropertyName>("NodePropertyName")
    }
}

///  Enum for the name of an edge
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:atom.EdgePropertyName)
pub enum EdgePropertyName {
    // @@protoc_insertion_point(enum_value:atom.EdgePropertyName.UNKNOWN_EDGE_PROPERTY)
    UNKNOWN_EDGE_PROPERTY = 0,
    // @@protoc_insertion_point(enum_value:atom.EdgePropertyName.VARIABLE)
    VARIABLE = 11,
}

impl ::protobuf::Enum for EdgePropertyName {
    const NAME: &'static str = "EdgePropertyName";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EdgePropertyName> {
        match value {
            0 => ::std::option::Option::Some(EdgePropertyName::UNKNOWN_EDGE_PROPERTY),
            11 => ::std::option::Option::Some(EdgePropertyName::VARIABLE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EdgePropertyName] = &[
        EdgePropertyName::UNKNOWN_EDGE_PROPERTY,
        EdgePropertyName::VARIABLE,
    ];
}

impl ::protobuf::EnumFull for EdgePropertyName {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EdgePropertyName").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EdgePropertyName::UNKNOWN_EDGE_PROPERTY => 0,
            EdgePropertyName::VARIABLE => 1,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EdgePropertyName {
    fn default() -> Self {
        EdgePropertyName::UNKNOWN_EDGE_PROPERTY
    }
}

impl EdgePropertyName {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EdgePropertyName>("EdgePropertyName")
    }
}

///  Enum for the possible modifier types for symbols, methods and class nodes
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:atom.ModifierTypes)
pub enum ModifierTypes {
    // @@protoc_insertion_point(enum_value:atom.ModifierTypes.UNKNOWN_MODIFIER_TYPE)
    UNKNOWN_MODIFIER_TYPE = 0,
    // @@protoc_insertion_point(enum_value:atom.ModifierTypes.STATIC)
    STATIC = 1,
    // @@protoc_insertion_point(enum_value:atom.ModifierTypes.PUBLIC)
    PUBLIC = 2,
    // @@protoc_insertion_point(enum_value:atom.ModifierTypes.PROTECTED)
    PROTECTED = 3,
    // @@protoc_insertion_point(enum_value:atom.ModifierTypes.PRIVATE)
    PRIVATE = 4,
    // @@protoc_insertion_point(enum_value:atom.ModifierTypes.ABSTRACT)
    ABSTRACT = 5,
    // @@protoc_insertion_point(enum_value:atom.ModifierTypes.NATIVE)
    NATIVE = 6,
    // @@protoc_insertion_point(enum_value:atom.ModifierTypes.CONSTRUCTOR)
    CONSTRUCTOR = 7,
    // @@protoc_insertion_point(enum_value:atom.ModifierTypes.VIRTUAL)
    VIRTUAL = 8,
    // @@protoc_insertion_point(enum_value:atom.ModifierTypes.INTERNAL)
    INTERNAL = 9,
    // @@protoc_insertion_point(enum_value:atom.ModifierTypes.FINAL)
    FINAL = 10,
    // @@protoc_insertion_point(enum_value:atom.ModifierTypes.READONLY)
    READONLY = 11,
}

impl ::protobuf::Enum for ModifierTypes {
    const NAME: &'static str = "ModifierTypes";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ModifierTypes> {
        match value {
            0 => ::std::option::Option::Some(ModifierTypes::UNKNOWN_MODIFIER_TYPE),
            1 => ::std::option::Option::Some(ModifierTypes::STATIC),
            2 => ::std::option::Option::Some(ModifierTypes::PUBLIC),
            3 => ::std::option::Option::Some(ModifierTypes::PROTECTED),
            4 => ::std::option::Option::Some(ModifierTypes::PRIVATE),
            5 => ::std::option::Option::Some(ModifierTypes::ABSTRACT),
            6 => ::std::option::Option::Some(ModifierTypes::NATIVE),
            7 => ::std::option::Option::Some(ModifierTypes::CONSTRUCTOR),
            8 => ::std::option::Option::Some(ModifierTypes::VIRTUAL),
            9 => ::std::option::Option::Some(ModifierTypes::INTERNAL),
            10 => ::std::option::Option::Some(ModifierTypes::FINAL),
            11 => ::std::option::Option::Some(ModifierTypes::READONLY),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ModifierTypes] = &[
        ModifierTypes::UNKNOWN_MODIFIER_TYPE,
        ModifierTypes::STATIC,
        ModifierTypes::PUBLIC,
        ModifierTypes::PROTECTED,
        ModifierTypes::PRIVATE,
        ModifierTypes::ABSTRACT,
        ModifierTypes::NATIVE,
        ModifierTypes::CONSTRUCTOR,
        ModifierTypes::VIRTUAL,
        ModifierTypes::INTERNAL,
        ModifierTypes::FINAL,
        ModifierTypes::READONLY,
    ];
}

impl ::protobuf::EnumFull for ModifierTypes {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ModifierTypes").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ModifierTypes {
    fn default() -> Self {
        ModifierTypes::UNKNOWN_MODIFIER_TYPE
    }
}

impl ModifierTypes {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ModifierTypes>("ModifierTypes")
    }
}

///  Enum to represent the frontend language
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:atom.LANGUAGES)
pub enum LANGUAGES {
    // @@protoc_insertion_point(enum_value:atom.LANGUAGES.UNKNOWN_LANGUAGE)
    UNKNOWN_LANGUAGE = 0,
    // @@protoc_insertion_point(enum_value:atom.LANGUAGES.JAVA)
    JAVA = 1,
    // @@protoc_insertion_point(enum_value:atom.LANGUAGES.JAVASCRIPT)
    JAVASCRIPT = 2,
    // @@protoc_insertion_point(enum_value:atom.LANGUAGES.GOLANG)
    GOLANG = 3,
    // @@protoc_insertion_point(enum_value:atom.LANGUAGES.CSHARP)
    CSHARP = 4,
    // @@protoc_insertion_point(enum_value:atom.LANGUAGES.C)
    C = 5,
    // @@protoc_insertion_point(enum_value:atom.LANGUAGES.PYTHON)
    PYTHON = 6,
    // @@protoc_insertion_point(enum_value:atom.LANGUAGES.LLVM)
    LLVM = 7,
    // @@protoc_insertion_point(enum_value:atom.LANGUAGES.PHP)
    PHP = 8,
    // @@protoc_insertion_point(enum_value:atom.LANGUAGES.FUZZY_TEST_LANG)
    FUZZY_TEST_LANG = 9,
    // @@protoc_insertion_point(enum_value:atom.LANGUAGES.GHIDRA)
    GHIDRA = 10,
    // @@protoc_insertion_point(enum_value:atom.LANGUAGES.KOTLIN)
    KOTLIN = 11,
    // @@protoc_insertion_point(enum_value:atom.LANGUAGES.NEWC)
    NEWC = 12,
    // @@protoc_insertion_point(enum_value:atom.LANGUAGES.JAVASRC)
    JAVASRC = 13,
    // @@protoc_insertion_point(enum_value:atom.LANGUAGES.PYTHONSRC)
    PYTHONSRC = 14,
    // @@protoc_insertion_point(enum_value:atom.LANGUAGES.JSSRC)
    JSSRC = 15,
    // @@protoc_insertion_point(enum_value:atom.LANGUAGES.SOLIDITY)
    SOLIDITY = 16,
    // @@protoc_insertion_point(enum_value:atom.LANGUAGES.RUBYSRC)
    RUBYSRC = 17,
}

impl ::protobuf::Enum for LANGUAGES {
    const NAME: &'static str = "LANGUAGES";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LANGUAGES> {
        match value {
            0 => ::std::option::Option::Some(LANGUAGES::UNKNOWN_LANGUAGE),
            1 => ::std::option::Option::Some(LANGUAGES::JAVA),
            2 => ::std::option::Option::Some(LANGUAGES::JAVASCRIPT),
            3 => ::std::option::Option::Some(LANGUAGES::GOLANG),
            4 => ::std::option::Option::Some(LANGUAGES::CSHARP),
            5 => ::std::option::Option::Some(LANGUAGES::C),
            6 => ::std::option::Option::Some(LANGUAGES::PYTHON),
            7 => ::std::option::Option::Some(LANGUAGES::LLVM),
            8 => ::std::option::Option::Some(LANGUAGES::PHP),
            9 => ::std::option::Option::Some(LANGUAGES::FUZZY_TEST_LANG),
            10 => ::std::option::Option::Some(LANGUAGES::GHIDRA),
            11 => ::std::option::Option::Some(LANGUAGES::KOTLIN),
            12 => ::std::option::Option::Some(LANGUAGES::NEWC),
            13 => ::std::option::Option::Some(LANGUAGES::JAVASRC),
            14 => ::std::option::Option::Some(LANGUAGES::PYTHONSRC),
            15 => ::std::option::Option::Some(LANGUAGES::JSSRC),
            16 => ::std::option::Option::Some(LANGUAGES::SOLIDITY),
            17 => ::std::option::Option::Some(LANGUAGES::RUBYSRC),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [LANGUAGES] = &[
        LANGUAGES::UNKNOWN_LANGUAGE,
        LANGUAGES::JAVA,
        LANGUAGES::JAVASCRIPT,
        LANGUAGES::GOLANG,
        LANGUAGES::CSHARP,
        LANGUAGES::C,
        LANGUAGES::PYTHON,
        LANGUAGES::LLVM,
        LANGUAGES::PHP,
        LANGUAGES::FUZZY_TEST_LANG,
        LANGUAGES::GHIDRA,
        LANGUAGES::KOTLIN,
        LANGUAGES::NEWC,
        LANGUAGES::JAVASRC,
        LANGUAGES::PYTHONSRC,
        LANGUAGES::JSSRC,
        LANGUAGES::SOLIDITY,
        LANGUAGES::RUBYSRC,
    ];
}

impl ::protobuf::EnumFull for LANGUAGES {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("LANGUAGES").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for LANGUAGES {
    fn default() -> Self {
        LANGUAGES::UNKNOWN_LANGUAGE
    }
}

impl LANGUAGES {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<LANGUAGES>("LANGUAGES")
    }
}

///  Enum representing the evaluation strategy of the underlying parameter or method or literal.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:atom.EvaluationStrategies)
pub enum EvaluationStrategies {
    // @@protoc_insertion_point(enum_value:atom.EvaluationStrategies.UNKNOWN_EVALUATION_STRATEGY)
    UNKNOWN_EVALUATION_STRATEGY = 0,
    // @@protoc_insertion_point(enum_value:atom.EvaluationStrategies.BY_REFERENCE)
    BY_REFERENCE = 1,
    // @@protoc_insertion_point(enum_value:atom.EvaluationStrategies.BY_SHARING)
    BY_SHARING = 2,
    // @@protoc_insertion_point(enum_value:atom.EvaluationStrategies.BY_VALUE)
    BY_VALUE = 3,
}

impl ::protobuf::Enum for EvaluationStrategies {
    const NAME: &'static str = "EvaluationStrategies";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EvaluationStrategies> {
        match value {
            0 => ::std::option::Option::Some(EvaluationStrategies::UNKNOWN_EVALUATION_STRATEGY),
            1 => ::std::option::Option::Some(EvaluationStrategies::BY_REFERENCE),
            2 => ::std::option::Option::Some(EvaluationStrategies::BY_SHARING),
            3 => ::std::option::Option::Some(EvaluationStrategies::BY_VALUE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EvaluationStrategies] = &[
        EvaluationStrategies::UNKNOWN_EVALUATION_STRATEGY,
        EvaluationStrategies::BY_REFERENCE,
        EvaluationStrategies::BY_SHARING,
        EvaluationStrategies::BY_VALUE,
    ];
}

impl ::protobuf::EnumFull for EvaluationStrategies {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EvaluationStrategies").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EvaluationStrategies {
    fn default() -> Self {
        EvaluationStrategies::UNKNOWN_EVALUATION_STRATEGY
    }
}

impl EvaluationStrategies {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EvaluationStrategies>("EvaluationStrategies")
    }
}

///  Enum representing the dispatch types
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:atom.DispatchTypes)
pub enum DispatchTypes {
    // @@protoc_insertion_point(enum_value:atom.DispatchTypes.UNKNOWN_DISPATCH_TYPE)
    UNKNOWN_DISPATCH_TYPE = 0,
    // @@protoc_insertion_point(enum_value:atom.DispatchTypes.STATIC_DISPATCH)
    STATIC_DISPATCH = 1,
    // @@protoc_insertion_point(enum_value:atom.DispatchTypes.DYNAMIC_DISPATCH)
    DYNAMIC_DISPATCH = 2,
    // @@protoc_insertion_point(enum_value:atom.DispatchTypes.INLINED)
    INLINED = 3,
}

impl ::protobuf::Enum for DispatchTypes {
    const NAME: &'static str = "DispatchTypes";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DispatchTypes> {
        match value {
            0 => ::std::option::Option::Some(DispatchTypes::UNKNOWN_DISPATCH_TYPE),
            1 => ::std::option::Option::Some(DispatchTypes::STATIC_DISPATCH),
            2 => ::std::option::Option::Some(DispatchTypes::DYNAMIC_DISPATCH),
            3 => ::std::option::Option::Some(DispatchTypes::INLINED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DispatchTypes] = &[
        DispatchTypes::UNKNOWN_DISPATCH_TYPE,
        DispatchTypes::STATIC_DISPATCH,
        DispatchTypes::DYNAMIC_DISPATCH,
        DispatchTypes::INLINED,
    ];
}

impl ::protobuf::EnumFull for DispatchTypes {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DispatchTypes").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DispatchTypes {
    fn default() -> Self {
        DispatchTypes::UNKNOWN_DISPATCH_TYPE
    }
}

impl DispatchTypes {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DispatchTypes>("DispatchTypes")
    }
}

///  Enum representing the control structure types
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:atom.CONTROL_STRUCTURE_TYPES)
pub enum CONTROL_STRUCTURE_TYPES {
    // @@protoc_insertion_point(enum_value:atom.CONTROL_STRUCTURE_TYPES.UNKNOWN_CONTROL_STRUCTURE_TYPE)
    UNKNOWN_CONTROL_STRUCTURE_TYPE = 0,
    // @@protoc_insertion_point(enum_value:atom.CONTROL_STRUCTURE_TYPES.BREAK)
    BREAK = 1,
    // @@protoc_insertion_point(enum_value:atom.CONTROL_STRUCTURE_TYPES.CONTINUE)
    CONTINUE = 2,
    // @@protoc_insertion_point(enum_value:atom.CONTROL_STRUCTURE_TYPES.WHILE)
    WHILE = 3,
    // @@protoc_insertion_point(enum_value:atom.CONTROL_STRUCTURE_TYPES.DO)
    DO = 4,
    // @@protoc_insertion_point(enum_value:atom.CONTROL_STRUCTURE_TYPES.FOR)
    FOR = 5,
    // @@protoc_insertion_point(enum_value:atom.CONTROL_STRUCTURE_TYPES.GOTO)
    GOTO = 6,
    // @@protoc_insertion_point(enum_value:atom.CONTROL_STRUCTURE_TYPES.IF)
    IF = 7,
    // @@protoc_insertion_point(enum_value:atom.CONTROL_STRUCTURE_TYPES.ELSE)
    ELSE = 8,
    // @@protoc_insertion_point(enum_value:atom.CONTROL_STRUCTURE_TYPES.SWITCH)
    SWITCH = 9,
    // @@protoc_insertion_point(enum_value:atom.CONTROL_STRUCTURE_TYPES.TRY)
    TRY = 10,
    // @@protoc_insertion_point(enum_value:atom.CONTROL_STRUCTURE_TYPES.THROW)
    THROW = 11,
    // @@protoc_insertion_point(enum_value:atom.CONTROL_STRUCTURE_TYPES.MATCH)
    MATCH = 12,
    // @@protoc_insertion_point(enum_value:atom.CONTROL_STRUCTURE_TYPES.YIELD)
    YIELD = 13,
}

impl ::protobuf::Enum for CONTROL_STRUCTURE_TYPES {
    const NAME: &'static str = "CONTROL_STRUCTURE_TYPES";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CONTROL_STRUCTURE_TYPES> {
        match value {
            0 => ::std::option::Option::Some(CONTROL_STRUCTURE_TYPES::UNKNOWN_CONTROL_STRUCTURE_TYPE),
            1 => ::std::option::Option::Some(CONTROL_STRUCTURE_TYPES::BREAK),
            2 => ::std::option::Option::Some(CONTROL_STRUCTURE_TYPES::CONTINUE),
            3 => ::std::option::Option::Some(CONTROL_STRUCTURE_TYPES::WHILE),
            4 => ::std::option::Option::Some(CONTROL_STRUCTURE_TYPES::DO),
            5 => ::std::option::Option::Some(CONTROL_STRUCTURE_TYPES::FOR),
            6 => ::std::option::Option::Some(CONTROL_STRUCTURE_TYPES::GOTO),
            7 => ::std::option::Option::Some(CONTROL_STRUCTURE_TYPES::IF),
            8 => ::std::option::Option::Some(CONTROL_STRUCTURE_TYPES::ELSE),
            9 => ::std::option::Option::Some(CONTROL_STRUCTURE_TYPES::SWITCH),
            10 => ::std::option::Option::Some(CONTROL_STRUCTURE_TYPES::TRY),
            11 => ::std::option::Option::Some(CONTROL_STRUCTURE_TYPES::THROW),
            12 => ::std::option::Option::Some(CONTROL_STRUCTURE_TYPES::MATCH),
            13 => ::std::option::Option::Some(CONTROL_STRUCTURE_TYPES::YIELD),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CONTROL_STRUCTURE_TYPES] = &[
        CONTROL_STRUCTURE_TYPES::UNKNOWN_CONTROL_STRUCTURE_TYPE,
        CONTROL_STRUCTURE_TYPES::BREAK,
        CONTROL_STRUCTURE_TYPES::CONTINUE,
        CONTROL_STRUCTURE_TYPES::WHILE,
        CONTROL_STRUCTURE_TYPES::DO,
        CONTROL_STRUCTURE_TYPES::FOR,
        CONTROL_STRUCTURE_TYPES::GOTO,
        CONTROL_STRUCTURE_TYPES::IF,
        CONTROL_STRUCTURE_TYPES::ELSE,
        CONTROL_STRUCTURE_TYPES::SWITCH,
        CONTROL_STRUCTURE_TYPES::TRY,
        CONTROL_STRUCTURE_TYPES::THROW,
        CONTROL_STRUCTURE_TYPES::MATCH,
        CONTROL_STRUCTURE_TYPES::YIELD,
    ];
}

impl ::protobuf::EnumFull for CONTROL_STRUCTURE_TYPES {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CONTROL_STRUCTURE_TYPES").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for CONTROL_STRUCTURE_TYPES {
    fn default() -> Self {
        CONTROL_STRUCTURE_TYPES::UNKNOWN_CONTROL_STRUCTURE_TYPE
    }
}

impl CONTROL_STRUCTURE_TYPES {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CONTROL_STRUCTURE_TYPES>("CONTROL_STRUCTURE_TYPES")
    }
}

/// *
///  Programming languages offer many closely-related concepts for describing blocks of code that can be executed with input parameters and return output parameters, possibly causing side effects. In the CPG specification, we refer to all of these concepts (procedures, functions, methods, etc.) as methods. A single METHOD node must exist for each method found in the source program.
///  The `FULL_NAME` field specifies the method's fully-qualified name, including information about the namespace it is contained in if applicable, the name field is the function's short name. The field `IS_EXTERNAL` indicates whether it was possible to identify a method body for the method. This is true for methods that are defined in the source program, and false for methods that are dynamically linked to the program, that is, methods that exist in an external dependency.
///  Line and column number information is specified in the optional fields `LINE_NUMBER`, `COLUMN_NUMBER`, `LINE_NUMBER_END`, and `COLUMN_NUMBER_END` and the name of the source file is specified in `FILENAME`. An optional hash value MAY be calculated over the function contents and included in the `HASH` field.
///  Finally, the fully qualified name of the program constructs that the method is immediately contained in is stored in the `AST_PARENT_FULL_NAME` field and its type is indicated in the `AST_PARENT_TYPE` field to be one of `METHOD`, `TYPE_DECL` or `NAMESPACE_BLOCK`.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:atom.NodeType)
pub enum NodeType {
    // @@protoc_insertion_point(enum_value:atom.NodeType.UNKNOWN_NODE_TYPE)
    UNKNOWN_NODE_TYPE = 0,
    // @@protoc_insertion_point(enum_value:atom.NodeType.METHOD)
    METHOD = 1,
    // @@protoc_insertion_point(enum_value:atom.NodeType.METHOD_RETURN)
    METHOD_RETURN = 3,
    // @@protoc_insertion_point(enum_value:atom.NodeType.ANNOTATION)
    ANNOTATION = 5,
    // @@protoc_insertion_point(enum_value:atom.NodeType.ANNOTATION_PARAMETER_ASSIGN)
    ANNOTATION_PARAMETER_ASSIGN = 6,
    // @@protoc_insertion_point(enum_value:atom.NodeType.ANNOTATION_PARAMETER)
    ANNOTATION_PARAMETER = 7,
    // @@protoc_insertion_point(enum_value:atom.NodeType.LITERAL)
    LITERAL = 8,
    // @@protoc_insertion_point(enum_value:atom.NodeType.MEMBER)
    MEMBER = 9,
    // @@protoc_insertion_point(enum_value:atom.NodeType.ARRAY_INITIALIZER)
    ARRAY_INITIALIZER = 14,
    // @@protoc_insertion_point(enum_value:atom.NodeType.CALL)
    CALL = 15,
    // @@protoc_insertion_point(enum_value:atom.NodeType.LOCAL)
    LOCAL = 23,
    // @@protoc_insertion_point(enum_value:atom.NodeType.TAG)
    TAG = 24,
    // @@protoc_insertion_point(enum_value:atom.NodeType.LOCATION)
    LOCATION = 25,
    // @@protoc_insertion_point(enum_value:atom.NodeType.IDENTIFIER)
    IDENTIFIER = 27,
    // @@protoc_insertion_point(enum_value:atom.NodeType.RETURN)
    RETURN = 30,
    // @@protoc_insertion_point(enum_value:atom.NodeType.BLOCK)
    BLOCK = 31,
    // @@protoc_insertion_point(enum_value:atom.NodeType.METHOD_PARAMETER_OUT)
    METHOD_PARAMETER_OUT = 33,
    // @@protoc_insertion_point(enum_value:atom.NodeType.METHOD_PARAMETER_IN)
    METHOD_PARAMETER_IN = 34,
    // @@protoc_insertion_point(enum_value:atom.NodeType.DEPENDENCY)
    DEPENDENCY = 35,
    // @@protoc_insertion_point(enum_value:atom.NodeType.FILE)
    FILE = 38,
    // @@protoc_insertion_point(enum_value:atom.NodeType.META_DATA)
    META_DATA = 39,
    // @@protoc_insertion_point(enum_value:atom.NodeType.NAMESPACE)
    NAMESPACE = 40,
    // @@protoc_insertion_point(enum_value:atom.NodeType.NAMESPACE_BLOCK)
    NAMESPACE_BLOCK = 41,
    // @@protoc_insertion_point(enum_value:atom.NodeType.UNKNOWN)
    UNKNOWN = 44,
    // @@protoc_insertion_point(enum_value:atom.NodeType.TYPE)
    TYPE = 45,
    // @@protoc_insertion_point(enum_value:atom.NodeType.TYPE_DECL)
    TYPE_DECL = 46,
    // @@protoc_insertion_point(enum_value:atom.NodeType.TYPE_PARAMETER)
    TYPE_PARAMETER = 47,
    // @@protoc_insertion_point(enum_value:atom.NodeType.TYPE_ARGUMENT)
    TYPE_ARGUMENT = 48,
    // @@protoc_insertion_point(enum_value:atom.NodeType.ANNOTATION_LITERAL)
    ANNOTATION_LITERAL = 49,
    // @@protoc_insertion_point(enum_value:atom.NodeType.CONFIG_FILE)
    CONFIG_FILE = 50,
    // @@protoc_insertion_point(enum_value:atom.NodeType.BINDING)
    BINDING = 146,
    // @@protoc_insertion_point(enum_value:atom.NodeType.TAG_NODE_PAIR)
    TAG_NODE_PAIR = 208,
    // @@protoc_insertion_point(enum_value:atom.NodeType.FINDING)
    FINDING = 214,
    // @@protoc_insertion_point(enum_value:atom.NodeType.KEY_VALUE_PAIR)
    KEY_VALUE_PAIR = 217,
    // @@protoc_insertion_point(enum_value:atom.NodeType.MODIFIER)
    MODIFIER = 300,
    // @@protoc_insertion_point(enum_value:atom.NodeType.METHOD_REF)
    METHOD_REF = 333,
    // @@protoc_insertion_point(enum_value:atom.NodeType.CLOSURE_BINDING)
    CLOSURE_BINDING = 334,
    // @@protoc_insertion_point(enum_value:atom.NodeType.TYPE_REF)
    TYPE_REF = 335,
    // @@protoc_insertion_point(enum_value:atom.NodeType.CONTROL_STRUCTURE)
    CONTROL_STRUCTURE = 339,
    // @@protoc_insertion_point(enum_value:atom.NodeType.JUMP_TARGET)
    JUMP_TARGET = 340,
    // @@protoc_insertion_point(enum_value:atom.NodeType.JUMP_LABEL)
    JUMP_LABEL = 341,
    // @@protoc_insertion_point(enum_value:atom.NodeType.TEMPLATE_DOM)
    TEMPLATE_DOM = 417,
    // @@protoc_insertion_point(enum_value:atom.NodeType.COMMENT)
    COMMENT = 511,
    // @@protoc_insertion_point(enum_value:atom.NodeType.FIELD_IDENTIFIER)
    FIELD_IDENTIFIER = 2001081,
}

impl ::protobuf::Enum for NodeType {
    const NAME: &'static str = "NodeType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NodeType> {
        match value {
            0 => ::std::option::Option::Some(NodeType::UNKNOWN_NODE_TYPE),
            1 => ::std::option::Option::Some(NodeType::METHOD),
            3 => ::std::option::Option::Some(NodeType::METHOD_RETURN),
            5 => ::std::option::Option::Some(NodeType::ANNOTATION),
            6 => ::std::option::Option::Some(NodeType::ANNOTATION_PARAMETER_ASSIGN),
            7 => ::std::option::Option::Some(NodeType::ANNOTATION_PARAMETER),
            8 => ::std::option::Option::Some(NodeType::LITERAL),
            9 => ::std::option::Option::Some(NodeType::MEMBER),
            14 => ::std::option::Option::Some(NodeType::ARRAY_INITIALIZER),
            15 => ::std::option::Option::Some(NodeType::CALL),
            23 => ::std::option::Option::Some(NodeType::LOCAL),
            24 => ::std::option::Option::Some(NodeType::TAG),
            25 => ::std::option::Option::Some(NodeType::LOCATION),
            27 => ::std::option::Option::Some(NodeType::IDENTIFIER),
            30 => ::std::option::Option::Some(NodeType::RETURN),
            31 => ::std::option::Option::Some(NodeType::BLOCK),
            33 => ::std::option::Option::Some(NodeType::METHOD_PARAMETER_OUT),
            34 => ::std::option::Option::Some(NodeType::METHOD_PARAMETER_IN),
            35 => ::std::option::Option::Some(NodeType::DEPENDENCY),
            38 => ::std::option::Option::Some(NodeType::FILE),
            39 => ::std::option::Option::Some(NodeType::META_DATA),
            40 => ::std::option::Option::Some(NodeType::NAMESPACE),
            41 => ::std::option::Option::Some(NodeType::NAMESPACE_BLOCK),
            44 => ::std::option::Option::Some(NodeType::UNKNOWN),
            45 => ::std::option::Option::Some(NodeType::TYPE),
            46 => ::std::option::Option::Some(NodeType::TYPE_DECL),
            47 => ::std::option::Option::Some(NodeType::TYPE_PARAMETER),
            48 => ::std::option::Option::Some(NodeType::TYPE_ARGUMENT),
            49 => ::std::option::Option::Some(NodeType::ANNOTATION_LITERAL),
            50 => ::std::option::Option::Some(NodeType::CONFIG_FILE),
            146 => ::std::option::Option::Some(NodeType::BINDING),
            208 => ::std::option::Option::Some(NodeType::TAG_NODE_PAIR),
            214 => ::std::option::Option::Some(NodeType::FINDING),
            217 => ::std::option::Option::Some(NodeType::KEY_VALUE_PAIR),
            300 => ::std::option::Option::Some(NodeType::MODIFIER),
            333 => ::std::option::Option::Some(NodeType::METHOD_REF),
            334 => ::std::option::Option::Some(NodeType::CLOSURE_BINDING),
            335 => ::std::option::Option::Some(NodeType::TYPE_REF),
            339 => ::std::option::Option::Some(NodeType::CONTROL_STRUCTURE),
            340 => ::std::option::Option::Some(NodeType::JUMP_TARGET),
            341 => ::std::option::Option::Some(NodeType::JUMP_LABEL),
            417 => ::std::option::Option::Some(NodeType::TEMPLATE_DOM),
            511 => ::std::option::Option::Some(NodeType::COMMENT),
            2001081 => ::std::option::Option::Some(NodeType::FIELD_IDENTIFIER),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [NodeType] = &[
        NodeType::UNKNOWN_NODE_TYPE,
        NodeType::METHOD,
        NodeType::METHOD_RETURN,
        NodeType::ANNOTATION,
        NodeType::ANNOTATION_PARAMETER_ASSIGN,
        NodeType::ANNOTATION_PARAMETER,
        NodeType::LITERAL,
        NodeType::MEMBER,
        NodeType::ARRAY_INITIALIZER,
        NodeType::CALL,
        NodeType::LOCAL,
        NodeType::TAG,
        NodeType::LOCATION,
        NodeType::IDENTIFIER,
        NodeType::RETURN,
        NodeType::BLOCK,
        NodeType::METHOD_PARAMETER_OUT,
        NodeType::METHOD_PARAMETER_IN,
        NodeType::DEPENDENCY,
        NodeType::FILE,
        NodeType::META_DATA,
        NodeType::NAMESPACE,
        NodeType::NAMESPACE_BLOCK,
        NodeType::UNKNOWN,
        NodeType::TYPE,
        NodeType::TYPE_DECL,
        NodeType::TYPE_PARAMETER,
        NodeType::TYPE_ARGUMENT,
        NodeType::ANNOTATION_LITERAL,
        NodeType::CONFIG_FILE,
        NodeType::BINDING,
        NodeType::TAG_NODE_PAIR,
        NodeType::FINDING,
        NodeType::KEY_VALUE_PAIR,
        NodeType::MODIFIER,
        NodeType::METHOD_REF,
        NodeType::CLOSURE_BINDING,
        NodeType::TYPE_REF,
        NodeType::CONTROL_STRUCTURE,
        NodeType::JUMP_TARGET,
        NodeType::JUMP_LABEL,
        NodeType::TEMPLATE_DOM,
        NodeType::COMMENT,
        NodeType::FIELD_IDENTIFIER,
    ];
}

impl ::protobuf::EnumFull for NodeType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("NodeType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            NodeType::UNKNOWN_NODE_TYPE => 0,
            NodeType::METHOD => 1,
            NodeType::METHOD_RETURN => 2,
            NodeType::ANNOTATION => 3,
            NodeType::ANNOTATION_PARAMETER_ASSIGN => 4,
            NodeType::ANNOTATION_PARAMETER => 5,
            NodeType::LITERAL => 6,
            NodeType::MEMBER => 7,
            NodeType::ARRAY_INITIALIZER => 8,
            NodeType::CALL => 9,
            NodeType::LOCAL => 10,
            NodeType::TAG => 11,
            NodeType::LOCATION => 12,
            NodeType::IDENTIFIER => 13,
            NodeType::RETURN => 14,
            NodeType::BLOCK => 15,
            NodeType::METHOD_PARAMETER_OUT => 16,
            NodeType::METHOD_PARAMETER_IN => 17,
            NodeType::DEPENDENCY => 18,
            NodeType::FILE => 19,
            NodeType::META_DATA => 20,
            NodeType::NAMESPACE => 21,
            NodeType::NAMESPACE_BLOCK => 22,
            NodeType::UNKNOWN => 23,
            NodeType::TYPE => 24,
            NodeType::TYPE_DECL => 25,
            NodeType::TYPE_PARAMETER => 26,
            NodeType::TYPE_ARGUMENT => 27,
            NodeType::ANNOTATION_LITERAL => 28,
            NodeType::CONFIG_FILE => 29,
            NodeType::BINDING => 30,
            NodeType::TAG_NODE_PAIR => 31,
            NodeType::FINDING => 32,
            NodeType::KEY_VALUE_PAIR => 33,
            NodeType::MODIFIER => 34,
            NodeType::METHOD_REF => 35,
            NodeType::CLOSURE_BINDING => 36,
            NodeType::TYPE_REF => 37,
            NodeType::CONTROL_STRUCTURE => 38,
            NodeType::JUMP_TARGET => 39,
            NodeType::JUMP_LABEL => 40,
            NodeType::TEMPLATE_DOM => 41,
            NodeType::COMMENT => 42,
            NodeType::FIELD_IDENTIFIER => 43,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for NodeType {
    fn default() -> Self {
        NodeType::UNKNOWN_NODE_TYPE
    }
}

impl NodeType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<NodeType>("NodeType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\natom.proto\x12\x04atom\"\xca\x04\n\rPropertyValue\x12#\n\x0cstring_v\
    alue\x18\x01\x20\x01(\tH\0R\x0bstringValue\x12\x1f\n\nbool_value\x18\x02\
    \x20\x01(\x08H\0R\tboolValue\x12\x1d\n\tint_value\x18\x03\x20\x01(\x05H\
    \0R\x08intValue\x12\x1f\n\nlong_value\x18\x04\x20\x01(\x03H\0R\tlongValu\
    e\x12!\n\x0bfloat_value\x18\x05\x20\x01(\x02H\0R\nfloatValue\x12#\n\x0cd\
    ouble_value\x18\x06\x20\x01(\x01H\0R\x0bdoubleValue\x123\n\x0bstring_lis\
    t\x18\x07\x20\x01(\x0b2\x10.atom.StringListH\0R\nstringList\x12-\n\tbool\
    _list\x18\x08\x20\x01(\x0b2\x0e.atom.BoolListH\0R\x08boolList\x12*\n\x08\
    int_list\x18\t\x20\x01(\x0b2\r.atom.IntListH\0R\x07intList\x12-\n\tlong_\
    list\x18\n\x20\x01(\x0b2\x0e.atom.LongListH\0R\x08longList\x120\n\nfloat\
    _list\x18\x0b\x20\x01(\x0b2\x0f.atom.FloatListH\0R\tfloatList\x123\n\x0b\
    double_list\x18\x0c\x20\x01(\x0b2\x10.atom.DoubleListH\0R\ndoubleList\
    \x12<\n\x0econtained_refs\x18\r\x20\x01(\x0b2\x13.atom.ContainedRefsH\0R\
    \rcontainedRefsB\x07\n\x05value\"B\n\rContainedRefs\x12\x1d\n\nlocal_nam\
    e\x18\x01\x20\x01(\tR\tlocalName\x12\x12\n\x04refs\x18\x02\x20\x03(\x03R\
    \x04refs\"$\n\nStringList\x12\x16\n\x06values\x18\x01\x20\x03(\tR\x06val\
    ues\"\"\n\x08BoolList\x12\x16\n\x06values\x18\x01\x20\x03(\x08R\x06value\
    s\"!\n\x07IntList\x12\x16\n\x06values\x18\x01\x20\x03(\x05R\x06values\"\
    \"\n\x08LongList\x12\x16\n\x06values\x18\x01\x20\x03(\x03R\x06values\"#\
    \n\tFloatList\x12\x16\n\x06values\x18\x01\x20\x03(\x02R\x06values\"$\n\n\
    DoubleList\x12\x16\n\x06values\x18\x01\x20\x03(\x01R\x06values\"\xcf\x07\
    \n\tCpgStruct\x12(\n\x04node\x18\x01\x20\x03(\x0b2\x14.atom.CpgStruct.No\
    deR\x04node\x12(\n\x04edge\x18\x02\x20\x03(\x0b2\x14.atom.CpgStruct.Edge\
    R\x04edge\x1a\xda\x01\n\x04Node\x12\x10\n\x03key\x18\x01\x20\x01(\x03R\
    \x03key\x12\"\n\x04type\x18\x02\x20\x01(\x0e2\x0e.atom.NodeTypeR\x04type\
    \x129\n\x08property\x18\x03\x20\x03(\x0b2\x1d.atom.CpgStruct.Node.Proper\
    tyR\x08property\x1aa\n\x08Property\x12*\n\x04name\x18\x01\x20\x01(\x0e2\
    \x16.atom.NodePropertyNameR\x04name\x12)\n\x05value\x18\x02\x20\x01(\x0b\
    2\x13.atom.PropertyValueR\x05value\x1a\x90\x05\n\x04Edge\x12\x10\n\x03sr\
    c\x18\x01\x20\x01(\x03R\x03src\x12\x10\n\x03dst\x18\x02\x20\x01(\x03R\
    \x03dst\x121\n\x04type\x18\x03\x20\x01(\x0e2\x1d.atom.CpgStruct.Edge.Edg\
    eTypeR\x04type\x129\n\x08property\x18\x04\x20\x03(\x0b2\x1d.atom.CpgStru\
    ct.Edge.PropertyR\x08property\x1aa\n\x08Property\x12*\n\x04name\x18\x01\
    \x20\x01(\x0e2\x16.atom.EdgePropertyNameR\x04name\x12)\n\x05value\x18\
    \x02\x20\x01(\x0b2\x13.atom.PropertyValueR\x05value\"\x87\x03\n\x08EdgeT\
    ype\x12\x15\n\x11UNKNOWN_EDGE_TYPE\x10\0\x12\x07\n\x03AST\x10\x03\x12\
    \x08\n\x04CALL\x10\x06\x12\x07\n\x03REF\x10\n\x12\r\n\tTAGGED_BY\x10\x0b\
    \x12\x12\n\x0ePARAMETER_LINK\x10\x0c\x12\x07\n\x03CFG\x10\x13\x12\r\n\tE\
    VAL_TYPE\x10\x15\x12\x0c\n\x08BINDS_TO\x10\x16\x12\x11\n\rINHERITS_FROM\
    \x10\x17\x12\x0c\n\x08CONTAINS\x10\x1c\x12\x0b\n\x07CAPTURE\x10(\x12\x0f\
    \n\x0bCAPTURED_BY\x10)\x12\x0c\n\x08RECEIVER\x107\x12\r\n\tCONDITION\x10\
    8\x12\x11\n\x0cREACHING_DEF\x10\x89\x01\x12\r\n\x08ALIAS_OF\x10\x8a\x01\
    \x12\n\n\x05BINDS\x10\x9b\x01\x12\r\n\x08ARGUMENT\x10\x9c\x01\x12\x10\n\
    \x0bSOURCE_FILE\x10\x9d\x01\x12\r\n\x08DOMINATE\x10\xb5\x01\x12\x12\n\rP\
    OST_DOMINATE\x10\xb6\x01\x12\x08\n\x03CDG\x10\xb7\x01\x12\r\n\x07IMPORTS\
    \x10\xef\xb8\x01\x12\x18\n\x12IS_CALL_FOR_IMPORT\x10\xf0\xb8\x01J\x04\
    \x08\x05\x10\x06R\x03key\"l\n\x16AdditionalNodeProperty\x12\x17\n\x07nod\
    e_id\x18\x01\x20\x01(\x03R\x06nodeId\x129\n\x08property\x18\x02\x20\x01(\
    \x0b2\x1d.atom.CpgStruct.Node.PropertyR\x08property\"\xea\x01\n\x16Addit\
    ionalEdgeProperty\x12\x17\n\x07edge_id\x18\x01\x20\x01(\x03R\x06edgeId\
    \x129\n\x08property\x18\x02\x20\x01(\x0b2\x1d.atom.CpgStruct.Edge.Proper\
    tyR\x08property\x12\x20\n\x0cout_node_key\x18\x03\x20\x01(\x03R\noutNode\
    Key\x12\x1e\n\x0bin_node_key\x18\x04\x20\x01(\x03R\tinNodeKey\x12:\n\ted\
    ge_type\x18\x05\x20\x01(\x0e2\x1d.atom.CpgStruct.Edge.EdgeTypeR\x08edgeT\
    ype\"\xe6\x01\n\nCpgOverlay\x12(\n\x04node\x18\x01\x20\x03(\x0b2\x14.ato\
    m.CpgStruct.NodeR\x04node\x12(\n\x04edge\x18\x02\x20\x03(\x0b2\x14.atom.\
    CpgStruct.EdgeR\x04edge\x12A\n\rnode_property\x18\x03\x20\x03(\x0b2\x1c.\
    atom.AdditionalNodePropertyR\x0cnodeProperty\x12A\n\redge_property\x18\
    \x04\x20\x03(\x0b2\x1c.atom.AdditionalEdgePropertyR\x0cedgeProperty\"\
    \xa1\t\n\tDiffGraph\x12/\n\x07entries\x18\x01\x20\x03(\x0b2\x15.atom.Dif\
    fGraph.EntryR\x07entries\x1a\x1e\n\nRemoveNode\x12\x10\n\x03key\x18\x01\
    \x20\x01(\x03R\x03key\x1aq\n\x12RemoveNodeProperty\x12\x10\n\x03key\x18\
    \x01\x20\x01(\x03R\x03key\x12*\n\x04name\x18\x02\x20\x01(\x0e2\x16.atom.\
    NodePropertyNameR\x04name\x12\x1d\n\nlocal_name\x18\x03\x20\x01(\tR\tloc\
    alName\x1a\xb2\x01\n\nRemoveEdge\x12\x20\n\x0cout_node_key\x18\x01\x20\
    \x01(\x03R\noutNodeKey\x12\x1e\n\x0bin_node_key\x18\x02\x20\x01(\x03R\ti\
    nNodeKey\x12:\n\tedge_type\x18\x03\x20\x01(\x0e2\x1d.atom.CpgStruct.Edge\
    .EdgeTypeR\x08edgeType\x12&\n\x0epropertiesHash\x18\x04\x20\x01(\x0cR\
    \x0epropertiesHash\x1a\xf7\x01\n\x12RemoveEdgeProperty\x12\x20\n\x0cout_\
    node_key\x18\x01\x20\x01(\x03R\noutNodeKey\x12\x1e\n\x0bin_node_key\x18\
    \x02\x20\x01(\x03R\tinNodeKey\x12:\n\tedge_type\x18\x03\x20\x01(\x0e2\
    \x1d.atom.CpgStruct.Edge.EdgeTypeR\x08edgeType\x12&\n\x0epropertiesHash\
    \x18\x04\x20\x01(\x0cR\x0epropertiesHash\x12;\n\rproperty_name\x18\x05\
    \x20\x01(\x0e2\x16.atom.EdgePropertyNameR\x0cpropertyName\x1a\xa0\x04\n\
    \x05Entry\x12*\n\x04node\x18\x01\x20\x01(\x0b2\x14.atom.CpgStruct.NodeH\
    \0R\x04node\x12*\n\x04edge\x18\x02\x20\x01(\x0b2\x14.atom.CpgStruct.Edge\
    H\0R\x04edge\x12C\n\rnode_property\x18\x03\x20\x01(\x0b2\x1c.atom.Additi\
    onalNodePropertyH\0R\x0cnodeProperty\x12C\n\redge_property\x18\x04\x20\
    \x01(\x0b2\x1c.atom.AdditionalEdgePropertyH\0R\x0cedgeProperty\x12=\n\
    \x0bremove_node\x18\x05\x20\x01(\x0b2\x1a.atom.DiffGraph.RemoveNodeH\0R\
    \nremoveNode\x12V\n\x14remove_node_property\x18\x06\x20\x01(\x0b2\".atom\
    .DiffGraph.RemoveNodePropertyH\0R\x12removeNodeProperty\x12=\n\x0bremove\
    _edge\x18\x07\x20\x01(\x0b2\x1a.atom.DiffGraph.RemoveEdgeH\0R\nremoveEdg\
    e\x12V\n\x14remove_edge_property\x18\x08\x20\x01(\x0b2\".atom.DiffGraph.\
    RemoveEdgePropertyH\0R\x12removeEdgePropertyB\x07\n\x05value\"\x88\x13\n\
    \nUsageSlice\x12E\n\x0cobjectSlices\x18\x01\x20\x03(\x0b2!.atom.UsageSli\
    ce.MethodUsageSliceR\x0cobjectSlices\x12M\n\x10userDefinedTypes\x18\x02\
    \x20\x03(\x0b2!.atom.UsageSlice.UserDefinedTypesR\x10userDefinedTypes\
    \x1a\xf5\x01\n\tTargetObj\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \x12\"\n\x0ctypeFullName\x18\x02\x20\x01(\tR\x0ctypeFullName\x12\x1a\n\
    \x08position\x18\x03\x20\x01(\rR\x08position\x12\x1e\n\nisExternal\x18\
    \x04\x20\x01(\x08R\nisExternal\x12\x1e\n\nlineNumber\x18\x05\x20\x01(\rR\
    \nlineNumber\x12\"\n\x0ccolumnNumber\x18\x06\x20\x01(\rR\x0ccolumnNumber\
    \x120\n\x05label\x18\x07\x20\x01(\x0e2\x1a.atom.UsageSlice.LabelTypeR\
    \x05label\x1a\x81\x02\n\tDefinedBy\x12\x12\n\x04name\x18\x01\x20\x01(\tR\
    \x04name\x12\"\n\x0ctypeFullName\x18\x02\x20\x01(\tR\x0ctypeFullName\x12\
    &\n\x0eresolvedMethod\x18\x03\x20\x01(\tR\x0eresolvedMethod\x12\x1a\n\
    \x08position\x18\x04\x20\x01(\rR\x08position\x12\x1e\n\nisExternal\x18\
    \x05\x20\x01(\x08R\nisExternal\x12\x1e\n\nlineNumber\x18\x06\x20\x01(\rR\
    \nlineNumber\x12\"\n\x0ccolumnNumber\x18\x07\x20\x01(\rR\x0ccolumnNumber\
    \x12\x14\n\x05label\x18\x08\x20\x01(\tR\x05label\x1a\xf6\x01\n\x0cInvoke\
    dCalls\x12\x1a\n\x08callName\x18\x01\x20\x01(\tR\x08callName\x12&\n\x0er\
    esolvedMethod\x18\x02\x20\x01(\tR\x0eresolvedMethod\x12\x1e\n\nparamType\
    s\x18\x03\x20\x03(\tR\nparamTypes\x12\x1e\n\nreturnType\x18\x04\x20\x01(\
    \tR\nreturnType\x12\x1e\n\nisExternal\x18\x05\x20\x01(\x08R\nisExternal\
    \x12\x1e\n\nlineNumber\x18\x06\x20\x01(\rR\nlineNumber\x12\"\n\x0ccolumn\
    Number\x18\x07\x20\x01(\rR\x0ccolumnNumber\x1a\x90\x02\n\nArgToCalls\x12\
    \x1a\n\x08callName\x18\x01\x20\x01(\tR\x08callName\x12&\n\x0eresolvedMet\
    hod\x18\x02\x20\x01(\tR\x0eresolvedMethod\x12\x1e\n\nparamTypes\x18\x03\
    \x20\x03(\tR\nparamTypes\x12\x1e\n\nreturnType\x18\x04\x20\x01(\tR\nretu\
    rnType\x12\x1a\n\x08position\x18\x05\x20\x01(\rR\x08position\x12\x1e\n\n\
    isExternal\x18\x06\x20\x01(\x08R\nisExternal\x12\x1e\n\nlineNumber\x18\
    \x07\x20\x01(\rR\nlineNumber\x12\"\n\x0ccolumnNumber\x18\x08\x20\x01(\rR\
    \x0ccolumnNumber\x1a\x86\x02\n\x10ObjectUsageSlice\x128\n\ttargetObj\x18\
    \x01\x20\x01(\x0b2\x1a.atom.UsageSlice.TargetObjR\ttargetObj\x128\n\tdef\
    inedBy\x18\x02\x20\x01(\x0b2\x1a.atom.UsageSlice.DefinedByR\tdefinedBy\
    \x12A\n\x0cinvokedCalls\x18\x03\x20\x03(\x0b2\x1d.atom.UsageSlice.Invoke\
    dCallsR\x0cinvokedCalls\x12;\n\nargToCalls\x18\x04\x20\x03(\x0b2\x1b.ato\
    m.UsageSlice.ArgToCallsR\nargToCalls\x1a\xdd\x01\n\x10MethodUsageSlice\
    \x12\x12\n\x04code\x18\x01\x20\x01(\tR\x04code\x12\x1a\n\x08fullName\x18\
    \x02\x20\x01(\tR\x08fullName\x12\x1a\n\x08fileName\x18\x03\x20\x01(\tR\
    \x08fileName\x12\x1e\n\nlineNumber\x18\x04\x20\x01(\rR\nlineNumber\x12\"\
    \n\x0ccolumnNumber\x18\x05\x20\x01(\rR\x0ccolumnNumber\x129\n\x06usages\
    \x18\x06\x20\x03(\x0b2!.atom.UsageSlice.ObjectUsageSliceR\x06usages\x1a\
    \xb6\x01\n\x06Fields\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\"\
    \n\x0ctypeFullName\x18\x02\x20\x01(\tR\x0ctypeFullName\x12\x1e\n\nlineNu\
    mber\x18\x03\x20\x01(\rR\nlineNumber\x12\"\n\x0ccolumnNumber\x18\x04\x20\
    \x01(\rR\x0ccolumnNumber\x120\n\x05label\x18\x05\x20\x01(\x0e2\x1a.atom.\
    UsageSlice.LabelTypeR\x05label\x1a\xd4\x01\n\nProcedures\x12\x1a\n\x08ca\
    llName\x18\x01\x20\x01(\tR\x08callName\x12&\n\x0eresolvedMethod\x18\x02\
    \x20\x01(\tR\x0eresolvedMethod\x12\x1e\n\nparamTypes\x18\x03\x20\x03(\tR\
    \nparamTypes\x12\x1e\n\nreturnType\x18\x04\x20\x01(\tR\nreturnType\x12\
    \x1e\n\nlineNumber\x18\x05\x20\x01(\rR\nlineNumber\x12\"\n\x0ccolumnNumb\
    er\x18\x06\x20\x01(\rR\x0ccolumnNumber\x1a\xf4\x01\n\x10UserDefinedTypes\
    \x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12/\n\x06fields\x18\x02\
    \x20\x03(\x0b2\x17.atom.UsageSlice.FieldsR\x06fields\x12;\n\nprocedures\
    \x18\x03\x20\x03(\x0b2\x1b.atom.UsageSlice.ProceduresR\nprocedures\x12\
    \x1a\n\x08fileName\x18\x04\x20\x01(\tR\x08fileName\x12\x1e\n\nlineNumber\
    \x18\x05\x20\x01(\rR\nlineNumber\x12\"\n\x0ccolumnNumber\x18\x06\x20\x01\
    (\rR\x0ccolumnNumber\"l\n\tLabelType\x12\x07\n\x03ANY\x10\0\x12\t\n\x05L\
    OCAL\x10\x01\x12\x0b\n\x07LITERAL\x10\x02\x12\t\n\x05PARAM\x10\x03\x12\
    \x08\n\x04CALL\x10\x04\x12\x0e\n\nIDENTIFIER\x10\x05\x12\x0c\n\x08TYPE_R\
    EF\x10\x06\x12\x0b\n\x07UNKNOWN\x10\n\"\xe5\x06\n\rDataFlowSlice\x12/\n\
    \x05graph\x18\x01\x20\x01(\x0b2\x19.atom.DataFlowSlice.GraphR\x05graph\
    \x12-\n\x04path\x18\x02\x20\x01(\x0b2\x19.atom.DataFlowSlice.PathsR\x04p\
    ath\x1a\xd3\x03\n\x05Nodes\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\x12\
    $\n\x05label\x18\x02\x20\x01(\x0e2\x0e.atom.NodeTypeR\x05label\x12\x12\n\
    \x04name\x18\x03\x20\x01(\tR\x04name\x12\x1a\n\x08fullName\x18\x04\x20\
    \x01(\tR\x08fullName\x12\x1c\n\tsignature\x18\x05\x20\x01(\tR\tsignature\
    \x12\x1e\n\nisExternal\x18\x06\x20\x01(\x08R\nisExternal\x12\x12\n\x04co\
    de\x18\x07\x20\x01(\tR\x04code\x12\"\n\x0ctypeFullName\x18\x08\x20\x01(\
    \tR\x0ctypeFullName\x12*\n\x10parentMethodName\x18\t\x20\x01(\tR\x10pare\
    ntMethodName\x12&\n\x0eparentFileName\x18\n\x20\x01(\tR\x0eparentFileNam\
    e\x12,\n\x11parentPackageName\x18\x0b\x20\x01(\tR\x11parentPackageName\
    \x12(\n\x0fparentClassName\x18\x0c\x20\x01(\tR\x0fparentClassName\x12\
    \x1e\n\nlineNumber\x18\r\x20\x01(\rR\nlineNumber\x12\"\n\x0ccolumnNumber\
    \x18\x0e\x20\x01(\rR\x0ccolumnNumber\x1a`\n\x05Edges\x12\x10\n\x03src\
    \x18\x01\x20\x01(\rR\x03src\x12\x10\n\x03dst\x18\x02\x20\x01(\rR\x03dst\
    \x123\n\x05label\x18\x03\x20\x01(\x0e2\x1d.atom.CpgStruct.Edge.EdgeTypeR\
    \x05label\x1a\x17\n\x05Flows\x12\x0e\n\x02id\x18\x01\x20\x03(\rR\x02id\
    \x1a8\n\x05Paths\x12/\n\x05flows\x18\x01\x20\x03(\x0b2\x19.atom.DataFlow\
    Slice.FlowsR\x05flows\x1ai\n\x05Graph\x12/\n\x05nodes\x18\x01\x20\x03(\
    \x0b2\x19.atom.DataFlowSlice.NodesR\x05nodes\x12/\n\x05edges\x18\x02\x20\
    \x03(\x0b2\x19.atom.DataFlowSlice.EdgesR\x05edges*\xa5\x07\n\x10NodeProp\
    ertyName\x12\x19\n\x15UNKNOWN_NODE_PROPERTY\x10\0\x12\x0f\n\x0bLINE_NUMB\
    ER\x10\x02\x12\x14\n\x10PARSER_TYPE_NAME\x10\x03\x12\t\n\x05ORDER\x10\
    \x04\x12\x08\n\x04NAME\x10\x05\x12\r\n\tFULL_NAME\x10\x06\x12\x0f\n\x0bI\
    S_EXTERNAL\x10\x07\x12\t\n\x05VALUE\x10\x08\x12\x11\n\rCOLUMN_NUMBER\x10\
    \x0b\x12\x13\n\x0fLINE_NUMBER_END\x10\x0c\x12\x0b\n\x07VERSION\x10\r\x12\
    \x17\n\x13EVALUATION_STRATEGY\x10\x0f\x12\x15\n\x11COLUMN_NUMBER_END\x10\
    \x10\x12\x0c\n\x08LANGUAGE\x10\x13\x12\x0b\n\x07CONTENT\x10\x14\x12\x08\
    \n\x04CODE\x10\x15\x12\r\n\tSIGNATURE\x10\x16\x12\x11\n\rDISPATCH_TYPE\
    \x10\x19\x12\x11\n\rMODIFIER_TYPE\x10\x1a\x12\x1a\n\x16CONTROL_STRUCTURE\
    _TYPE\x10\x1b\x12\x12\n\x0eARGUMENT_INDEX\x10(\x12\x16\n\x12CLOSURE_BIND\
    ING_ID\x102\x12\x12\n\x0eTYPE_FULL_NAME\x103\x12\x17\n\x13TYPE_DECL_FULL\
    _NAME\x104\x12\x20\n\x1cINHERITS_FROM_TYPE_FULL_NAME\x105\x12\x14\n\x10M\
    ETHOD_FULL_NAME\x106\x12\x13\n\x0fAST_PARENT_TYPE\x108\x12\x18\n\x14AST_\
    PARENT_FULL_NAME\x109\x12\x17\n\x13DEPENDENCY_GROUP_ID\x10:\x12\n\n\x06S\
    YMBOL\x10d\x12\x15\n\x11METHOD_SHORT_NAME\x10f\x12\x10\n\x0cPACKAGE_NAME\
    \x10g\x12\x0e\n\nCLASS_NAME\x10h\x12\x0e\n\nNODE_LABEL\x10i\x12\x0c\n\
    \x08FILENAME\x10j\x12\x0c\n\x08OVERLAYS\x10v\x12\x08\n\x04HASH\x10x\x12\
    \x12\n\rARGUMENT_NAME\x10\x82\x01\x12\x08\n\x03KEY\x10\x83\x01\x12\x15\n\
    \x10CLASS_SHORT_NAME\x10\x84\x01\x12\x19\n\x14ALIAS_TYPE_FULL_NAME\x10\
    \x9e\x01\x12\x1a\n\x15CLOSURE_ORIGINAL_NAME\x10\x9f\x01\x12\x10\n\x0bIS_\
    VARIADIC\x10\xdd\x01\x12\t\n\x04ROOT\x10\xaf\t\x12\x20\n\x1bDYNAMIC_TYPE\
    _HINT_FULL_NAME\x10\xb7\x0c\x12\n\n\x05INDEX\x10\xaf\x11\x12\x14\n\x0eCA\
    NONICAL_NAME\x10\xc4\x91z\x12\x13\n\rCONTAINED_REF\x10\xf9\xc0z*;\n\x10E\
    dgePropertyName\x12\x19\n\x15UNKNOWN_EDGE_PROPERTY\x10\0\x12\x0c\n\x08VA\
    RIABLE\x10\x0b*\xbd\x01\n\rModifierTypes\x12\x19\n\x15UNKNOWN_MODIFIER_T\
    YPE\x10\0\x12\n\n\x06STATIC\x10\x01\x12\n\n\x06PUBLIC\x10\x02\x12\r\n\tP\
    ROTECTED\x10\x03\x12\x0b\n\x07PRIVATE\x10\x04\x12\x0c\n\x08ABSTRACT\x10\
    \x05\x12\n\n\x06NATIVE\x10\x06\x12\x0f\n\x0bCONSTRUCTOR\x10\x07\x12\x0b\
    \n\x07VIRTUAL\x10\x08\x12\x0c\n\x08INTERNAL\x10\t\x12\t\n\x05FINAL\x10\n\
    \x12\x0c\n\x08READONLY\x10\x0b*\xf2\x01\n\tLANGUAGES\x12\x14\n\x10UNKNOW\
    N_LANGUAGE\x10\0\x12\x08\n\x04JAVA\x10\x01\x12\x0e\n\nJAVASCRIPT\x10\x02\
    \x12\n\n\x06GOLANG\x10\x03\x12\n\n\x06CSHARP\x10\x04\x12\x05\n\x01C\x10\
    \x05\x12\n\n\x06PYTHON\x10\x06\x12\x08\n\x04LLVM\x10\x07\x12\x07\n\x03PH\
    P\x10\x08\x12\x13\n\x0fFUZZY_TEST_LANG\x10\t\x12\n\n\x06GHIDRA\x10\n\x12\
    \n\n\x06KOTLIN\x10\x0b\x12\x08\n\x04NEWC\x10\x0c\x12\x0b\n\x07JAVASRC\
    \x10\r\x12\r\n\tPYTHONSRC\x10\x0e\x12\t\n\x05JSSRC\x10\x0f\x12\x0c\n\x08\
    SOLIDITY\x10\x10\x12\x0b\n\x07RUBYSRC\x10\x11*g\n\x14EvaluationStrategie\
    s\x12\x1f\n\x1bUNKNOWN_EVALUATION_STRATEGY\x10\0\x12\x10\n\x0cBY_REFEREN\
    CE\x10\x01\x12\x0e\n\nBY_SHARING\x10\x02\x12\x0c\n\x08BY_VALUE\x10\x03*b\
    \n\rDispatchTypes\x12\x19\n\x15UNKNOWN_DISPATCH_TYPE\x10\0\x12\x13\n\x0f\
    STATIC_DISPATCH\x10\x01\x12\x14\n\x10DYNAMIC_DISPATCH\x10\x02\x12\x0b\n\
    \x07INLINED\x10\x03*\xc4\x01\n\x17CONTROL_STRUCTURE_TYPES\x12\"\n\x1eUNK\
    NOWN_CONTROL_STRUCTURE_TYPE\x10\0\x12\t\n\x05BREAK\x10\x01\x12\x0c\n\x08\
    CONTINUE\x10\x02\x12\t\n\x05WHILE\x10\x03\x12\x06\n\x02DO\x10\x04\x12\
    \x07\n\x03FOR\x10\x05\x12\x08\n\x04GOTO\x10\x06\x12\x06\n\x02IF\x10\x07\
    \x12\x08\n\x04ELSE\x10\x08\x12\n\n\x06SWITCH\x10\t\x12\x07\n\x03TRY\x10\
    \n\x12\t\n\x05THROW\x10\x0b\x12\t\n\x05MATCH\x10\x0c\x12\t\n\x05YIELD\
    \x10\r*\x82\x06\n\x08NodeType\x12\x15\n\x11UNKNOWN_NODE_TYPE\x10\0\x12\n\
    \n\x06METHOD\x10\x01\x12\x11\n\rMETHOD_RETURN\x10\x03\x12\x0e\n\nANNOTAT\
    ION\x10\x05\x12\x1f\n\x1bANNOTATION_PARAMETER_ASSIGN\x10\x06\x12\x18\n\
    \x14ANNOTATION_PARAMETER\x10\x07\x12\x0b\n\x07LITERAL\x10\x08\x12\n\n\
    \x06MEMBER\x10\t\x12\x15\n\x11ARRAY_INITIALIZER\x10\x0e\x12\x08\n\x04CAL\
    L\x10\x0f\x12\t\n\x05LOCAL\x10\x17\x12\x07\n\x03TAG\x10\x18\x12\x0c\n\
    \x08LOCATION\x10\x19\x12\x0e\n\nIDENTIFIER\x10\x1b\x12\n\n\x06RETURN\x10\
    \x1e\x12\t\n\x05BLOCK\x10\x1f\x12\x18\n\x14METHOD_PARAMETER_OUT\x10!\x12\
    \x17\n\x13METHOD_PARAMETER_IN\x10\"\x12\x0e\n\nDEPENDENCY\x10#\x12\x08\n\
    \x04FILE\x10&\x12\r\n\tMETA_DATA\x10'\x12\r\n\tNAMESPACE\x10(\x12\x13\n\
    \x0fNAMESPACE_BLOCK\x10)\x12\x0b\n\x07UNKNOWN\x10,\x12\x08\n\x04TYPE\x10\
    -\x12\r\n\tTYPE_DECL\x10.\x12\x12\n\x0eTYPE_PARAMETER\x10/\x12\x11\n\rTY\
    PE_ARGUMENT\x100\x12\x16\n\x12ANNOTATION_LITERAL\x101\x12\x0f\n\x0bCONFI\
    G_FILE\x102\x12\x0c\n\x07BINDING\x10\x92\x01\x12\x12\n\rTAG_NODE_PAIR\
    \x10\xd0\x01\x12\x0c\n\x07FINDING\x10\xd6\x01\x12\x13\n\x0eKEY_VALUE_PAI\
    R\x10\xd9\x01\x12\r\n\x08MODIFIER\x10\xac\x02\x12\x0f\n\nMETHOD_REF\x10\
    \xcd\x02\x12\x14\n\x0fCLOSURE_BINDING\x10\xce\x02\x12\r\n\x08TYPE_REF\
    \x10\xcf\x02\x12\x16\n\x11CONTROL_STRUCTURE\x10\xd3\x02\x12\x10\n\x0bJUM\
    P_TARGET\x10\xd4\x02\x12\x0f\n\nJUMP_LABEL\x10\xd5\x02\x12\x11\n\x0cTEMP\
    LATE_DOM\x10\xa1\x03\x12\x0c\n\x07COMMENT\x10\xff\x03\x12\x16\n\x10FIELD\
    _IDENTIFIER\x10\xb9\x91zBH\n\x11io.appthreat.atomB\x04AtomZ\x19github.co\
    m/AppThreat/atom\xaa\x02\x11io.appthreat.atomJ\xc1\x9e\x03\n\x07\x12\x05\
    \0\0\xde\x07\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x91\x03\n\x01\x02\x12\
    \x03\n\0\r\x1a\x86\x03*\n\x20Atom\x20is\x20a\x20novel\x20intermediate\
    \x20representation\x20for\x20applications.\x20The\x20representation\x20i\
    s\x20optimized\x20for\x20operations\x20such\x20as\x20slicing\x20useful\
    \x20for\x20application\x20analytics.\n\n\x20![Atom\x20logo](./docs/Atom-\
    logo.png)\n\x20Atom\x20v1.0.0\x20specification\x20is\x20currently\x20com\
    patible\x20with\x20Joern\x20CPG\x20v1.1\x20specification\x20with\x201\
    \x20modification\n\x20-\x20imports\x20edges\x20are\x20not\x20hidden\x20i\
    n\x20atom\n\x20[https://cpg.joern.io](https://cpg.joern.io)\n\n\x08\n\
    \x01\x08\x12\x03\x0c\00\n\t\n\x02\x08\x0b\x12\x03\x0c\00\n\x08\n\x01\x08\
    \x12\x03\r\0*\n\t\n\x02\x08\x01\x12\x03\r\0*\n\x08\n\x01\x08\x12\x03\x0e\
    \0%\n\t\n\x02\x08\x08\x12\x03\x0e\0%\n\x08\n\x01\x08\x12\x03\x0f\0.\n\t\
    \n\x02\x08%\x12\x03\x0f\0.\n3\n\x02\x05\0\x12\x05\x12\0\xa2\x01\x01\x1a&\
    \x20Enum\x20for\x20the\x20name\x20of\x20a\x20node\x20property\n\n\n\n\
    \x03\x05\0\x01\x12\x03\x12\x05\x15\n\x0b\n\x04\x05\0\x02\0\x12\x03\x13\
    \x02\x1c\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x13\x02\x17\n\x0c\n\x05\x05\
    \0\x02\0\x02\x12\x03\x13\x1a\x1b\nm\n\x04\x05\0\x02\x01\x12\x03\x16\x02\
    \x12\x1a`\x20This\x20optional\x20field\x20provides\x20the\x20line\x20num\
    ber\x20of\x20the\x20program\x20construct\x20represented\x20by\x20the\x20\
    node.\n\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\x16\x02\r\n\x0c\n\x05\x05\
    \0\x02\x01\x02\x12\x03\x16\x10\x11\n4\n\x04\x05\0\x02\x02\x12\x03\x19\
    \x02\x17\x1a'\x20AST\x20node\x20type\x20name\x20emitted\x20by\x20parser.\
    \n\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\x19\x02\x12\n\x0c\n\x05\x05\0\
    \x02\x02\x02\x12\x03\x19\x15\x16\n\x84\x01\n\x04\x05\0\x02\x03\x12\x03\
    \x1c\x02\x0c\x1aw\x20This\x20integer\x20indicates\x20the\x20position\x20\
    of\x20the\x20node\x20among\x20its\x20siblings\x20in\x20the\x20AST.\x20Th\
    e\x20left-most\x20child\x20has\x20an\x20order\x20of\x200.\n\n\x0c\n\x05\
    \x05\0\x02\x03\x01\x12\x03\x1c\x02\x07\n\x0c\n\x05\x05\0\x02\x03\x02\x12\
    \x03\x1c\n\x0b\nI\n\x04\x05\0\x02\x04\x12\x03\x1f\x02\x0b\x1a<\x20Name\
    \x20of\x20represented\x20object,\x20e.g.,\x20method\x20name\x20(e.g.\x20\
    \"run\")\n\n\x0c\n\x05\x05\0\x02\x04\x01\x12\x03\x1f\x02\x06\n\x0c\n\x05\
    \x05\0\x02\x04\x02\x12\x03\x1f\t\n\n\xe5\x01\n\x04\x05\0\x02\x05\x12\x03\
    \"\x02\x10\x1a\xd7\x01\x20This\x20is\x20the\x20fully-qualified\x20name\
    \x20of\x20an\x20entity,\x20e.g.,\x20the\x20fully-qualified\x20name\x20of\
    \x20a\x20method\x20or\x20type.\x20The\x20details\x20of\x20what\x20consti\
    tutes\x20a\x20fully-qualified\x20name\x20are\x20language\x20specific.\
    \x20This\x20field\x20SHOULD\x20be\x20human\x20readable.\n\n\x0c\n\x05\
    \x05\0\x02\x05\x01\x12\x03\"\x02\x0b\n\x0c\n\x05\x05\0\x02\x05\x02\x12\
    \x03\"\x0e\x0f\n\xe0\x01\n\x04\x05\0\x02\x06\x12\x03%\x02\x12\x1a\xd2\
    \x01\x20Indicates\x20that\x20the\x20construct\x20(METHOD\x20or\x20TYPE_D\
    ECL)\x20is\x20external,\x20that\x20is,\x20it\x20is\x20referenced\x20but\
    \x20not\x20defined\x20in\x20the\x20code\x20(applies\x20both\x20to\x20ins\
    ular\x20parsing\x20and\x20to\x20library\x20functions\x20where\x20we\x20h\
    ave\x20header\x20files\x20only)\n\n\x0c\n\x05\x05\0\x02\x06\x01\x12\x03%\
    \x02\r\n\x0c\n\x05\x05\0\x02\x06\x02\x12\x03%\x10\x11\nP\n\x04\x05\0\x02\
    \x07\x12\x03(\x02\x0c\x1aC\x20This\x20property\x20denotes\x20a\x20string\
    \x20value\x20as\x20used\x20in\x20a\x20key-value\x20pair.\n\n\x0c\n\x05\
    \x05\0\x02\x07\x01\x12\x03(\x02\x07\n\x0c\n\x05\x05\0\x02\x07\x02\x12\
    \x03(\n\x0b\np\n\x04\x05\0\x02\x08\x12\x03+\x02\x15\x1ac\x20This\x20opti\
    onal\x20fields\x20provides\x20the\x20column\x20number\x20of\x20the\x20pr\
    ogram\x20construct\x20represented\x20by\x20the\x20node.\n\n\x0c\n\x05\
    \x05\0\x02\x08\x01\x12\x03+\x02\x0f\n\x0c\n\x05\x05\0\x02\x08\x02\x12\
    \x03+\x12\x14\ny\n\x04\x05\0\x02\t\x12\x03.\x02\x17\x1al\x20This\x20opti\
    onal\x20fields\x20provides\x20the\x20line\x20number\x20at\x20which\x20th\
    e\x20program\x20construct\x20represented\x20by\x20the\x20node\x20ends.\n\
    \n\x0c\n\x05\x05\0\x02\t\x01\x12\x03.\x02\x11\n\x0c\n\x05\x05\0\x02\t\
    \x02\x12\x03.\x14\x16\n\x96\x01\n\x04\x05\0\x02\n\x12\x031\x02\x0f\x1a\
    \x88\x01\x20A\x20version,\x20given\x20as\x20a\x20string.\x20Used,\x20for\
    \x20example,\x20in\x20the\x20META_DATA\x20node\x20to\x20indicate\x20whic\
    h\x20version\x20of\x20the\x20CPG\x20spec\x20this\x20CPG\x20conforms\x20t\
    o.\n\n\x0c\n\x05\x05\0\x02\n\x01\x12\x031\x02\t\n\x0c\n\x05\x05\0\x02\n\
    \x02\x12\x031\x0c\x0e\n\xf1\x03\n\x04\x05\0\x02\x0b\x12\x034\x02\x1b\x1a\
    \xe3\x03\x20For\x20formal\x20method\x20input\x20parameters,\x20output\
    \x20parameters,\x20and\x20return\x20parameters,\x20this\x20field\x20hold\
    s\x20the\x20evaluation\x20strategy,\x20which\x20is\x20one\x20of\x20the\
    \x20following:\x201)\x20`BY_REFERENCE`\x20indicates\x20that\x20the\x20pa\
    rameter\x20is\x20passed\x20by\x20reference,\x202)\x20`BY_VALUE`\x20indic\
    ates\x20that\x20it\x20is\x20passed\x20by\x20value,\x20that\x20is,\x20a\
    \x20copy\x20is\x20made,\x203)\x20`BY_SHARING`\x20the\x20parameter\x20is\
    \x20a\x20pointer/reference\x20and\x20it\x20is\x20shared\x20with\x20the\
    \x20caller/callee.\x20While\x20a\x20copy\x20of\x20the\x20pointer\x20is\
    \x20made,\x20a\x20copy\x20of\x20the\x20object\x20that\x20it\x20points\
    \x20to\x20is\x20not\x20made.\n\n\x0c\n\x05\x05\0\x02\x0b\x01\x12\x034\
    \x02\x15\n\x0c\n\x05\x05\0\x02\x0b\x02\x12\x034\x18\x1a\n{\n\x04\x05\0\
    \x02\x0c\x12\x037\x02\x19\x1an\x20This\x20optional\x20fields\x20provides\
    \x20the\x20column\x20number\x20at\x20which\x20the\x20program\x20construc\
    t\x20represented\x20by\x20the\x20node\x20ends.\n\n\x0c\n\x05\x05\0\x02\
    \x0c\x01\x12\x037\x02\x13\n\x0c\n\x05\x05\0\x02\x0c\x02\x12\x037\x16\x18\
    \n\x85\x02\n\x04\x05\0\x02\r\x12\x03:\x02\x10\x1a\xf7\x01\x20This\x20fie\
    ld\x20indicates\x20which\x20CPG\x20language\x20frontend\x20generated\x20\
    the\x20CPG.\x20Frontend\x20developers\x20may\x20freely\x20choose\x20a\
    \x20value\x20that\x20describes\x20their\x20frontend\x20so\x20long\x20as\
    \x20it\x20is\x20not\x20used\x20by\x20an\x20existing\x20frontend.\x20Rese\
    rved\x20values\x20are\x20to\x20date:\x20C,\x20LLVM,\x20GHIDRA,\x20PHP.\n\
    \n\x0c\n\x05\x05\0\x02\r\x01\x12\x03:\x02\n\n\x0c\n\x05\x05\0\x02\r\x02\
    \x12\x03:\r\x0f\n\x9b\x01\n\x04\x05\0\x02\x0e\x12\x03=\x02\x0f\x1a\x8d\
    \x01\x20Certain\x20files,\x20e.g.,\x20configuration\x20files,\x20may\x20\
    be\x20included\x20in\x20the\x20CPG\x20as-is.\x20For\x20such\x20files,\
    \x20the\x20`CONTENT`\x20field\x20contains\x20the\x20files\x20content.\n\
    \n\x0c\n\x05\x05\0\x02\x0e\x01\x12\x03=\x02\t\n\x0c\n\x05\x05\0\x02\x0e\
    \x02\x12\x03=\x0c\x0e\nJ\n\x04\x05\0\x02\x0f\x12\x03@\x02\x0c\x1a=\x20Th\
    is\x20field\x20holds\x20the\x20code\x20snippet\x20that\x20the\x20node\
    \x20represents.\n\n\x0c\n\x05\x05\0\x02\x0f\x01\x12\x03@\x02\x06\n\x0c\n\
    \x05\x05\0\x02\x0f\x02\x12\x03@\t\x0b\n\x9a\x03\n\x04\x05\0\x02\x10\x12\
    \x03C\x02\x11\x1a\x8c\x03\x20The\x20method\x20signature\x20encodes\x20th\
    e\x20types\x20of\x20parameters\x20in\x20a\x20string.\x20The\x20string\
    \x20SHOULD\x20be\x20human\x20readable\x20and\x20suitable\x20for\x20diffe\
    rentiating\x20methods\x20with\x20different\x20parameter\x20types\x20suff\
    iciently\x20to\x20allow\x20for\x20resolving\x20of\x20function\x20overloa\
    ding.\x20The\x20present\x20specification\x20does\x20not\x20enforce\x20a\
    \x20strict\x20format\x20for\x20the\x20signature,\x20that\x20is,\x20it\
    \x20can\x20be\x20chosen\x20by\x20the\x20frontend\x20implementor\x20to\
    \x20fit\x20the\x20source\x20language.\n\n\x0c\n\x05\x05\0\x02\x10\x01\
    \x12\x03C\x02\x0b\n\x0c\n\x05\x05\0\x02\x10\x02\x12\x03C\x0e\x10\n\x85\
    \x03\n\x04\x05\0\x02\x11\x12\x03F\x02\x15\x1a\xf7\x02\x20This\x20field\
    \x20holds\x20the\x20dispatch\x20type\x20of\x20a\x20call,\x20which\x20is\
    \x20either\x20`STATIC_DISPATCH`\x20or\x20`DYNAMIC_DISPATCH`.\x20For\x20s\
    tatically\x20dispatched\x20method\x20calls,\x20the\x20call\x20target\x20\
    is\x20known\x20at\x20compile\x20time\x20while\x20for\x20dynamically\x20d\
    ispatched\x20calls,\x20it\x20can\x20only\x20be\x20determined\x20at\x20ru\
    ntime\x20as\x20it\x20may\x20depend\x20on\x20the\x20type\x20of\x20an\x20o\
    bject\x20(as\x20is\x20the\x20case\x20for\x20virtual\x20method\x20calls)\
    \x20or\x20calculation\x20of\x20an\x20offset.\n\n\x0c\n\x05\x05\0\x02\x11\
    \x01\x12\x03F\x02\x0f\n\x0c\n\x05\x05\0\x02\x11\x02\x12\x03F\x12\x14\n\
    \xbc\x01\n\x04\x05\0\x02\x12\x12\x03I\x02\x15\x1a\xae\x01\x20The\x20modi\
    fier\x20type\x20is\x20a\x20free-form\x20string.\x20The\x20following\x20a\
    re\x20known\x20modifier\x20types:\x20`STATIC`,\x20`PUBLIC`,\x20`PROTECTE\
    D`,\x20`PRIVATE`,\x20`ABSTRACT`,\x20`NATIVE`,\x20`CONSTRUCTOR`,\x20`VIRT\
    UAL`.\n\n\x0c\n\x05\x05\0\x02\x12\x01\x12\x03I\x02\x0f\n\x0c\n\x05\x05\0\
    \x02\x12\x02\x12\x03I\x12\x14\n\xf2\x01\n\x04\x05\0\x02\x13\x12\x03L\x02\
    \x1e\x1a\xe4\x01\x20The\x20`CONTROL_STRUCTURE_TYPE`\x20field\x20indicate\
    s\x20which\x20kind\x20of\x20control\x20structure\x20a\x20`CONTROL_STRUCT\
    URE`\x20node\x20represents.\x20The\x20available\x20types\x20are\x20the\
    \x20following:\x20BREAK,\x20CONTINUE,\x20DO,\x20WHILE,\x20FOR,\x20GOTO,\
    \x20IF,\x20ELSE,\x20TRY,\x20THROW\x20and\x20SWITCH.\n\n\x0c\n\x05\x05\0\
    \x02\x13\x01\x12\x03L\x02\x18\n\x0c\n\x05\x05\0\x02\x13\x02\x12\x03L\x1b\
    \x1d\n\xd2\x04\n\x04\x05\0\x02\x14\x12\x03O\x02\x16\x1a\xc4\x04\x20AST-c\
    hildren\x20of\x20CALL\x20nodes\x20have\x20an\x20argument\x20index,\x20th\
    at\x20is\x20used\x20to\x20match\x20call-site\x20arguments\x20with\x20cal\
    lee\x20parameters.\x20Explicit\x20parameters\x20are\x20numbered\x20from\
    \x201\x20to\x20N,\x20while\x20index\x200\x20is\x20reserved\x20for\x20imp\
    licit\x20self\x20/\x20this\x20parameter.\x20CALLs\x20without\x20implicit\
    \x20parameter\x20therefore\x20have\x20arguments\x20starting\x20with\x20i\
    ndex\x201.\x20AST-children\x20of\x20BLOCK\x20nodes\x20may\x20have\x20an\
    \x20argument\x20index\x20as\x20well;\x20in\x20this\x20case,\x20the\x20la\
    st\x20argument\x20index\x20determines\x20the\x20return\x20expression\x20\
    of\x20a\x20BLOCK\x20expression.\x20If\x20the\x20`PARAMETER_NAME`\x20fiel\
    d\x20is\x20set,\x20then\x20the\x20`ARGUMENT_INDEX`\x20field\x20is\x20ign\
    ored.\x20It\x20is\x20suggested\x20to\x20set\x20it\x20to\x20-1.\n\n\x0c\n\
    \x05\x05\0\x02\x14\x01\x12\x03O\x02\x10\n\x0c\n\x05\x05\0\x02\x14\x02\
    \x12\x03O\x13\x15\n\xa8\x01\n\x04\x05\0\x02\x15\x12\x03R\x02\x1a\x1a\x9a\
    \x01\x20Identifier\x20which\x20uniquely\x20describes\x20a\x20CLOSURE_BIN\
    DING.\x20This\x20property\x20is\x20used\x20to\x20match\x20captured\x20LO\
    CAL\x20nodes\x20with\x20the\x20corresponding\x20CLOSURE_BINDING\x20nodes\
    .\n\n\x0c\n\x05\x05\0\x02\x15\x01\x12\x03R\x02\x14\n\x0c\n\x05\x05\0\x02\
    \x15\x02\x12\x03R\x17\x19\n\xb2\x02\n\x04\x05\0\x02\x16\x12\x03U\x02\x16\
    \x1a\xa4\x02\x20This\x20field\x20contains\x20the\x20fully-qualified\x20s\
    tatic\x20type\x20name\x20of\x20the\x20program\x20construct\x20represente\
    d\x20by\x20a\x20node.\x20It\x20is\x20the\x20name\x20of\x20an\x20instanti\
    ated\x20type,\x20e.g.,\x20`java.util.List<Integer>`,\x20rather\x20than\
    \x20`java.util.List[T]`.\x20If\x20the\x20type\x20cannot\x20be\x20determi\
    ned,\x20this\x20field\x20should\x20be\x20set\x20to\x20the\x20empty\x20st\
    ring.\n\n\x0c\n\x05\x05\0\x02\x16\x01\x12\x03U\x02\x10\n\x0c\n\x05\x05\0\
    \x02\x16\x02\x12\x03U\x13\x15\n\xc7\x01\n\x04\x05\0\x02\x17\x12\x03X\x02\
    \x1b\x1a\xb9\x01\x20The\x20static\x20type\x20decl\x20of\x20a\x20TYPE.\
    \x20This\x20property\x20is\x20matched\x20against\x20the\x20FULL_NAME\x20\
    of\x20TYPE_DECL\x20nodes.\x20It\x20is\x20required\x20to\x20have\x20exact\
    ly\x20one\x20TYPE_DECL\x20for\x20each\x20different\x20TYPE_DECL_FULL_NAM\
    E.\n\n\x0c\n\x05\x05\0\x02\x17\x01\x12\x03X\x02\x15\n\x0c\n\x05\x05\0\
    \x02\x17\x02\x12\x03X\x18\x1a\n\xc8\x01\n\x04\x05\0\x02\x18\x12\x03[\x02\
    $\x1a\xba\x01\x20The\x20static\x20types\x20a\x20TYPE_DECL\x20inherits\
    \x20from.\x20This\x20property\x20is\x20matched\x20against\x20the\x20FULL\
    _NAME\x20of\x20TYPE\x20nodes\x20and\x20thus\x20it\x20is\x20required\x20t\
    o\x20have\x20at\x20least\x20one\x20TYPE\x20node\x20for\x20each\x20TYPE_F\
    ULL_NAME.\n\n\x0c\n\x05\x05\0\x02\x18\x01\x12\x03[\x02\x1e\n\x0c\n\x05\
    \x05\0\x02\x18\x02\x12\x03[!#\n\x98\x01\n\x04\x05\0\x02\x19\x12\x03^\x02\
    \x18\x1a\x8a\x01\x20The\x20FULL_NAME\x20of\x20a\x20method.\x20Used\x20to\
    \x20link\x20CALL\x20and\x20METHOD\x20nodes.\x20It\x20is\x20required\x20t\
    o\x20have\x20exactly\x20one\x20METHOD\x20node\x20for\x20each\x20METHOD_F\
    ULL_NAME.\n\n\x0c\n\x05\x05\0\x02\x19\x01\x12\x03^\x02\x12\n\x0c\n\x05\
    \x05\0\x02\x19\x02\x12\x03^\x15\x17\n\xd2\x01\n\x04\x05\0\x02\x1a\x12\
    \x03a\x02\x17\x1a\xc4\x01\x20The\x20type\x20of\x20the\x20AST\x20parent.\
    \x20Since\x20this\x20is\x20only\x20used\x20in\x20some\x20parts\x20of\x20\
    the\x20graph,\x20the\x20list\x20does\x20not\x20include\x20all\x20possibl\
    e\x20parents\x20by\x20intention.\x20Possible\x20parents:\x20METHOD,\x20T\
    YPE_DECL,\x20NAMESPACE_BLOCK.\n\n\x0c\n\x05\x05\0\x02\x1a\x01\x12\x03a\
    \x02\x11\n\x0c\n\x05\x05\0\x02\x1a\x02\x12\x03a\x14\x16\nM\n\x04\x05\0\
    \x02\x1b\x12\x03d\x02\x1c\x1a@\x20This\x20field\x20holds\x20the\x20FULL_\
    NAME\x20of\x20the\x20AST\x20parent\x20of\x20an\x20entity.\n\n\x0c\n\x05\
    \x05\0\x02\x1b\x01\x12\x03d\x02\x16\n\x0c\n\x05\x05\0\x02\x1b\x02\x12\
    \x03d\x19\x1b\n,\n\x04\x05\0\x02\x1c\x12\x03g\x02\x1b\x1a\x1f\x20The\x20\
    group\x20ID\x20for\x20a\x20dependency\n\n\x0c\n\x05\x05\0\x02\x1c\x01\
    \x12\x03g\x02\x15\n\x0c\n\x05\x05\0\x02\x1c\x02\x12\x03g\x18\x1a\n\x16\n\
    \x04\x05\0\x02\x1d\x12\x03j\x02\x0f\x1a\t\x20Symbols\n\n\x0c\n\x05\x05\0\
    \x02\x1d\x01\x12\x03j\x02\x08\n\x0c\n\x05\x05\0\x02\x1d\x02\x12\x03j\x0b\
    \x0e\n!\n\x04\x05\0\x02\x1e\x12\x03m\x02\x1a\x1a\x14\x20Method\x20short\
    \x20name.\n\n\x0c\n\x05\x05\0\x02\x1e\x01\x12\x03m\x02\x13\n\x0c\n\x05\
    \x05\0\x02\x1e\x02\x12\x03m\x16\x19\n#\n\x04\x05\0\x02\x1f\x12\x03p\x02\
    \x15\x1a\x16\x20Method\x20package\x20name.\n\n\x0c\n\x05\x05\0\x02\x1f\
    \x01\x12\x03p\x02\x0e\n\x0c\n\x05\x05\0\x02\x1f\x02\x12\x03p\x11\x14\n!\
    \n\x04\x05\0\x02\x20\x12\x03s\x02\x13\x1a\x14\x20Method\x20class\x20name\
    .\n\n\x0c\n\x05\x05\0\x02\x20\x01\x12\x03s\x02\x0c\n\x0c\n\x05\x05\0\x02\
    \x20\x02\x12\x03s\x0f\x12\n6\n\x04\x05\0\x02!\x12\x03v\x02\x13\x1a)\x20L\
    abel\x20for\x20the\x20node\x20which\x20could\x20be\x20code.\n\n\x0c\n\
    \x05\x05\0\x02!\x01\x12\x03v\x02\x0c\n\x0c\n\x05\x05\0\x02!\x02\x12\x03v\
    \x0f\x12\n\x89\x03\n\x04\x05\0\x02\"\x12\x03y\x02\x11\x1a\xfb\x02\x20The\
    \x20path\x20of\x20the\x20source\x20file\x20this\x20node\x20was\x20genera\
    ted\x20from,\x20relative\x20to\x20the\x20root\x20path\x20in\x20the\x20me\
    ta\x20data\x20node.\x20This\x20field\x20must\x20be\x20set\x20but\x20may\
    \x20be\x20set\x20to\x20the\x20value\x20`<unknown>`\x20to\x20indicate\x20\
    that\x20no\x20source\x20file\x20can\x20be\x20associated\x20with\x20the\
    \x20node,\x20e.g.,\x20because\x20the\x20node\x20represents\x20an\x20enti\
    ty\x20known\x20to\x20exist\x20because\x20it\x20is\x20referenced,\x20but\
    \x20for\x20which\x20the\x20file\x20that\x20is\x20is\x20declared\x20in\
    \x20is\x20unknown.\n\n\x0c\n\x05\x05\0\x02\"\x01\x12\x03y\x02\n\n\x0c\n\
    \x05\x05\0\x02\"\x02\x12\x03y\r\x10\n\x98\x02\n\x04\x05\0\x02#\x12\x03|\
    \x02\x11\x1a\x8a\x02\x20The\x20field\x20contains\x20the\x20names\x20of\
    \x20the\x20overlays\x20applied\x20to\x20this\x20CPG,\x20in\x20order\x20o\
    f\x20their\x20application.\x20Names\x20are\x20free-form\x20strings,\x20t\
    hat\x20is,\x20this\x20specification\x20does\x20not\x20dictate\x20them\
    \x20but\x20rather\x20requires\x20tool\x20producers\x20and\x20consumers\
    \x20to\x20communicate\x20them\x20between\x20each\x20other.\n\n\x0c\n\x05\
    \x05\0\x02#\x01\x12\x03|\x02\n\n\x0c\n\x05\x05\0\x02#\x02\x12\x03|\r\x10\
    \n\x8a\x03\n\x04\x05\0\x02$\x12\x03\x7f\x02\r\x1a\xfc\x02\x20This\x20pro\
    perty\x20contains\x20a\x20hash\x20value\x20in\x20the\x20form\x20of\x20a\
    \x20string.\x20Hashes\x20can\x20be\x20used\x20to\x20summarize\x20data,\
    \x20e.g.,\x20to\x20summarize\x20the\x20contents\x20of\x20source\x20files\
    \x20or\x20sub\x20graphs.\x20Such\x20summaries\x20are\x20useful\x20to\x20\
    determine\x20whether\x20code\x20has\x20already\x20been\x20analyzed\x20in\
    \x20incremental\x20analysis\x20pipelines.\x20This\x20property\x20is\x20o\
    ptional\x20to\x20allow\x20its\x20calculation\x20to\x20be\x20deferred\x20\
    or\x20skipped\x20if\x20the\x20hash\x20is\x20not\x20needed.\n\n\x0c\n\x05\
    \x05\0\x02$\x01\x12\x03\x7f\x02\x06\n\x0c\n\x05\x05\0\x02$\x02\x12\x03\
    \x7f\t\x0c\n\xb9\x01\n\x04\x05\0\x02%\x12\x04\x82\x01\x02\x16\x1a\xaa\
    \x01\x20For\x20calls\x20involving\x20named\x20parameters,\x20the\x20`ARG\
    UMENT_NAME`\x20field\x20holds\x20the\x20name\x20of\x20the\x20parameter\
    \x20initialized\x20by\x20the\x20expression.\x20For\x20all\x20other\x20ca\
    lls,\x20this\x20field\x20is\x20unset.\n\n\r\n\x05\x05\0\x02%\x01\x12\x04\
    \x82\x01\x02\x0f\n\r\n\x05\x05\0\x02%\x02\x12\x04\x82\x01\x12\x15\n@\n\
    \x04\x05\0\x02&\x12\x04\x85\x01\x02\x0c\x1a2\x20This\x20property\x20deno\
    tes\x20a\x20key\x20of\x20a\x20key-value\x20pair.\n\n\r\n\x05\x05\0\x02&\
    \x01\x12\x04\x85\x01\x02\x05\n\r\n\x05\x05\0\x02&\x02\x12\x04\x85\x01\
    \x08\x0b\n\x20\n\x04\x05\0\x02'\x12\x04\x88\x01\x02\x19\x1a\x12\x20Class\
    \x20short\x20name\n\n\r\n\x05\x05\0\x02'\x01\x12\x04\x88\x01\x02\x12\n\r\
    \n\x05\x05\0\x02'\x02\x12\x04\x88\x01\x15\x18\nj\n\x04\x05\0\x02(\x12\
    \x04\x8b\x01\x02\x1d\x1a\\\x20This\x20property\x20holds\x20the\x20fully\
    \x20qualified\x20name\x20of\x20the\x20type\x20that\x20the\x20node\x20is\
    \x20a\x20type\x20alias\x20of.\n\n\r\n\x05\x05\0\x02(\x01\x12\x04\x8b\x01\
    \x02\x16\n\r\n\x05\x05\0\x02(\x02\x12\x04\x8b\x01\x19\x1c\nP\n\x04\x05\0\
    \x02)\x12\x04\x8e\x01\x02\x1e\x1aB\x20The\x20original\x20name\x20of\x20t\
    he\x20(potentially\x20mangled)\x20captured\x20variable\n\n\r\n\x05\x05\0\
    \x02)\x01\x12\x04\x8e\x01\x02\x17\n\r\n\x05\x05\0\x02)\x02\x12\x04\x8e\
    \x01\x1a\x1d\n\xbd\x01\n\x04\x05\0\x02*\x12\x04\x91\x01\x02\x14\x1a\xae\
    \x01\x20Specifies\x20whether\x20a\x20parameter\x20is\x20the\x20variadic\
    \x20argument\x20handling\x20parameter\x20of\x20a\x20variadic\x20method.\
    \x20Only\x20one\x20parameter\x20of\x20a\x20method\x20is\x20allowed\x20to\
    \x20have\x20this\x20property\x20set\x20to\x20true.\n\n\r\n\x05\x05\0\x02\
    *\x01\x12\x04\x91\x01\x02\r\n\r\n\x05\x05\0\x02*\x02\x12\x04\x91\x01\x10\
    \x13\n_\n\x04\x05\0\x02+\x12\x04\x94\x01\x02\x0e\x1aQ\x20The\x20path\x20\
    to\x20the\x20root\x20directory\x20of\x20the\x20source/binary\x20this\x20\
    CPG\x20is\x20generated\x20from.\n\n\r\n\x05\x05\0\x02+\x01\x12\x04\x94\
    \x01\x02\x06\n\r\n\x05\x05\0\x02+\x02\x12\x04\x94\x01\t\r\n/\n\x04\x05\0\
    \x02,\x12\x04\x97\x01\x02%\x1a!\x20Type\x20hint\x20for\x20the\x20dynamic\
    \x20type.\n\n\r\n\x05\x05\0\x02,\x01\x12\x04\x97\x01\x02\x1d\n\r\n\x05\
    \x05\0\x02,\x02\x12\x04\x97\x01\x20$\n\xb3\x01\n\x04\x05\0\x02-\x12\x04\
    \x9a\x01\x02\x0f\x1a\xa4\x01\x20Specifies\x20an\x20index,\x20e.g.,\x20fo\
    r\x20a\x20parameter\x20or\x20argument.\x20Explicit\x20parameters\x20are\
    \x20numbered\x20from\x201\x20to\x20N,\x20while\x20index\x200\x20is\x20re\
    served\x20for\x20implicit\x20self\x20/\x20this\x20parameter.\n\n\r\n\x05\
    \x05\0\x02-\x01\x12\x04\x9a\x01\x02\x07\n\r\n\x05\x05\0\x02-\x02\x12\x04\
    \x9a\x01\n\x0e\n\xf6\x03\n\x04\x05\0\x02.\x12\x04\x9d\x01\x02\x1b\x1a\
    \xe7\x03\x20This\x20field\x20holds\x20the\x20canonical\x20name\x20of\x20\
    a\x20`FIELD_IDENTIFIER`.\x20It\x20is\x20typically\x20identical\x20to\x20\
    the\x20CODE\x20field,\x20but\x20canonicalized\x20according\x20to\x20sour\
    ce\x20language\x20semantics.\x20Human\x20readable\x20names\x20are\x20pre\
    ferable.\x20`FIELD_IDENTIFIER`\x20nodes\x20must\x20share\x20identical\
    \x20`CANONICAL_NAME`\x20if\x20and\x20only\x20if\x20they\x20alias,\x20e.g\
    .,\x20in\x20C-style\x20unions\x20(if\x20the\x20aliasing\x20relationship\
    \x20is\x20unknown\x20or\x20there\x20are\x20partial\x20overlaps,\x20then\
    \x20one\x20must\x20make\x20a\x20reasonable\x20guess,\x20and\x20trade\x20\
    off\x20between\x20false\x20negatives\x20and\x20false\x20positives).\n\n\
    \r\n\x05\x05\0\x02.\x01\x12\x04\x9d\x01\x02\x10\n\r\n\x05\x05\0\x02.\x02\
    \x12\x04\x9d\x01\x13\x1a\n\xac\x01\n\x04\x05\0\x02/\x12\x04\xa0\x01\x02\
    \x1a\x1a\x9d\x01\x20References\x20to\x20other\x20nodes.\x20This\x20is\
    \x20not\x20a\x20real\x20property;\x20it\x20exists\x20here\x20for\x20the\
    \x20sake\x20of\x20proto\x20serialization\x20only.\x20valueType\x20and\
    \x20cardinality\x20are\x20meaningless.\n\n\r\n\x05\x05\0\x02/\x01\x12\
    \x04\xa0\x01\x02\x0f\n\r\n\x05\x05\0\x02/\x02\x12\x04\xa0\x01\x12\x19\n,\
    \n\x02\x05\x01\x12\x06\xa5\x01\0\xaa\x01\x01\x1a\x1e\x20Enum\x20for\x20t\
    he\x20name\x20of\x20an\x20edge\n\n\x0b\n\x03\x05\x01\x01\x12\x04\xa5\x01\
    \x05\x15\n\x0c\n\x04\x05\x01\x02\0\x12\x04\xa6\x01\x02\x1c\n\r\n\x05\x05\
    \x01\x02\0\x01\x12\x04\xa6\x01\x02\x17\n\r\n\x05\x05\x01\x02\0\x02\x12\
    \x04\xa6\x01\x1a\x1b\nd\n\x04\x05\x01\x02\x01\x12\x04\xa9\x01\x02\x10\
    \x1aV\x20This\x20edge\x20property\x20represents\x20the\x20variable\x20pr\
    opagated\x20by\x20a\x20reaching\x20definition\x20edge.\n\n\r\n\x05\x05\
    \x01\x02\x01\x01\x12\x04\xa9\x01\x02\n\n\r\n\x05\x05\x01\x02\x01\x02\x12\
    \x04\xa9\x01\r\x0f\nY\n\x02\x05\x02\x12\x06\xad\x01\0\xd0\x01\x01\x1aK\
    \x20Enum\x20for\x20the\x20possible\x20modifier\x20types\x20for\x20symbol\
    s,\x20methods\x20and\x20class\x20nodes\n\n\x0b\n\x03\x05\x02\x01\x12\x04\
    \xad\x01\x05\x12\n\x0c\n\x04\x05\x02\x02\0\x12\x04\xae\x01\x02\x1c\n\r\n\
    \x05\x05\x02\x02\0\x01\x12\x04\xae\x01\x02\x17\n\r\n\x05\x05\x02\x02\0\
    \x02\x12\x04\xae\x01\x1a\x1b\n#\n\x04\x05\x02\x02\x01\x12\x04\xb1\x01\
    \x02\r\x1a\x15\x20The\x20static\x20modifier\n\n\r\n\x05\x05\x02\x02\x01\
    \x01\x12\x04\xb1\x01\x02\x08\n\r\n\x05\x05\x02\x02\x01\x02\x12\x04\xb1\
    \x01\x0b\x0c\n#\n\x04\x05\x02\x02\x02\x12\x04\xb4\x01\x02\r\x1a\x15\x20T\
    he\x20public\x20modifier\n\n\r\n\x05\x05\x02\x02\x02\x01\x12\x04\xb4\x01\
    \x02\x08\n\r\n\x05\x05\x02\x02\x02\x02\x12\x04\xb4\x01\x0b\x0c\n&\n\x04\
    \x05\x02\x02\x03\x12\x04\xb7\x01\x02\x10\x1a\x18\x20The\x20protected\x20\
    modifier\n\n\r\n\x05\x05\x02\x02\x03\x01\x12\x04\xb7\x01\x02\x0b\n\r\n\
    \x05\x05\x02\x02\x03\x02\x12\x04\xb7\x01\x0e\x0f\n$\n\x04\x05\x02\x02\
    \x04\x12\x04\xba\x01\x02\x0e\x1a\x16\x20The\x20private\x20modifier\n\n\r\
    \n\x05\x05\x02\x02\x04\x01\x12\x04\xba\x01\x02\t\n\r\n\x05\x05\x02\x02\
    \x04\x02\x12\x04\xba\x01\x0c\r\n%\n\x04\x05\x02\x02\x05\x12\x04\xbd\x01\
    \x02\x0f\x1a\x17\x20The\x20abstract\x20modifier\n\n\r\n\x05\x05\x02\x02\
    \x05\x01\x12\x04\xbd\x01\x02\n\n\r\n\x05\x05\x02\x02\x05\x02\x12\x04\xbd\
    \x01\r\x0e\n#\n\x04\x05\x02\x02\x06\x12\x04\xc0\x01\x02\r\x1a\x15\x20The\
    \x20native\x20modifier\n\n\r\n\x05\x05\x02\x02\x06\x01\x12\x04\xc0\x01\
    \x02\x08\n\r\n\x05\x05\x02\x02\x06\x02\x12\x04\xc0\x01\x0b\x0c\n(\n\x04\
    \x05\x02\x02\x07\x12\x04\xc3\x01\x02\x12\x1a\x1a\x20The\x20constructor\
    \x20modifier\n\n\r\n\x05\x05\x02\x02\x07\x01\x12\x04\xc3\x01\x02\r\n\r\n\
    \x05\x05\x02\x02\x07\x02\x12\x04\xc3\x01\x10\x11\n$\n\x04\x05\x02\x02\
    \x08\x12\x04\xc6\x01\x02\x0e\x1a\x16\x20The\x20virtual\x20modifier\n\n\r\
    \n\x05\x05\x02\x02\x08\x01\x12\x04\xc6\x01\x02\t\n\r\n\x05\x05\x02\x02\
    \x08\x02\x12\x04\xc6\x01\x0c\r\n%\n\x04\x05\x02\x02\t\x12\x04\xc9\x01\
    \x02\x0f\x1a\x17\x20The\x20internal\x20modifier\n\n\r\n\x05\x05\x02\x02\
    \t\x01\x12\x04\xc9\x01\x02\n\n\r\n\x05\x05\x02\x02\t\x02\x12\x04\xc9\x01\
    \r\x0e\n\"\n\x04\x05\x02\x02\n\x12\x04\xcc\x01\x02\r\x1a\x14\x20The\x20f\
    inal\x20modifier\n\n\r\n\x05\x05\x02\x02\n\x01\x12\x04\xcc\x01\x02\x07\n\
    \r\n\x05\x05\x02\x02\n\x02\x12\x04\xcc\x01\n\x0c\n%\n\x04\x05\x02\x02\
    \x0b\x12\x04\xcf\x01\x02\x10\x1a\x17\x20The\x20readonly\x20modifier\n\n\
    \r\n\x05\x05\x02\x02\x0b\x01\x12\x04\xcf\x01\x02\n\n\r\n\x05\x05\x02\x02\
    \x0b\x02\x12\x04\xcf\x01\r\x0f\n7\n\x02\x05\x03\x12\x06\xd3\x01\0\x8b\
    \x02\x01\x1a)\x20Enum\x20to\x20represent\x20the\x20frontend\x20language\
    \n\n\x0b\n\x03\x05\x03\x01\x12\x04\xd3\x01\x05\x0e\n\x20\n\x04\x05\x03\
    \x02\0\x12\x04\xd6\x01\x02\x17\x1a\x12\x20Unknown\x20language\n\n\r\n\
    \x05\x05\x03\x02\0\x01\x12\x04\xd6\x01\x02\x12\n\r\n\x05\x05\x03\x02\0\
    \x02\x12\x04\xd6\x01\x15\x16\n\x14\n\x04\x05\x03\x02\x01\x12\x04\xd9\x01\
    \x02\x0b\x1a\x06\x20Java\n\n\r\n\x05\x05\x03\x02\x01\x01\x12\x04\xd9\x01\
    \x02\x06\n\r\n\x05\x05\x03\x02\x01\x02\x12\x04\xd9\x01\t\n\n)\n\x04\x05\
    \x03\x02\x02\x12\x04\xdc\x01\x02\x11\x1a\x1b\x20JavaScript\x20and\x20Typ\
    eScript\n\n\r\n\x05\x05\x03\x02\x02\x01\x12\x04\xdc\x01\x02\x0c\n\r\n\
    \x05\x05\x03\x02\x02\x02\x12\x04\xdc\x01\x0f\x10\n\x12\n\x04\x05\x03\x02\
    \x03\x12\x04\xdf\x01\x02\r\x1a\x04\x20Go\n\n\r\n\x05\x05\x03\x02\x03\x01\
    \x12\x04\xdf\x01\x02\x08\n\r\n\x05\x05\x03\x02\x03\x02\x12\x04\xdf\x01\
    \x0b\x0c\n\x1f\n\x04\x05\x03\x02\x04\x12\x04\xe2\x01\x02\r\x1a\x11\x20cs\
    harp\x20/\x20dotnet\n\n\r\n\x05\x05\x03\x02\x04\x01\x12\x04\xe2\x01\x02\
    \x08\n\r\n\x05\x05\x03\x02\x04\x02\x12\x04\xe2\x01\x0b\x0c\n\x15\n\x04\
    \x05\x03\x02\x05\x12\x04\xe5\x01\x02\x08\x1a\x07\x20C/C++\n\n\r\n\x05\
    \x05\x03\x02\x05\x01\x12\x04\xe5\x01\x02\x03\n\r\n\x05\x05\x03\x02\x05\
    \x02\x12\x04\xe5\x01\x06\x07\n\x16\n\x04\x05\x03\x02\x06\x12\x04\xe8\x01\
    \x02\r\x1a\x08\x20Python\n\n\r\n\x05\x05\x03\x02\x06\x01\x12\x04\xe8\x01\
    \x02\x08\n\r\n\x05\x05\x03\x02\x06\x02\x12\x04\xe8\x01\x0b\x0c\n\x14\n\
    \x04\x05\x03\x02\x07\x12\x04\xeb\x01\x02\x0b\x1a\x06\x20llvm\n\n\r\n\x05\
    \x05\x03\x02\x07\x01\x12\x04\xeb\x01\x02\x06\n\r\n\x05\x05\x03\x02\x07\
    \x02\x12\x04\xeb\x01\t\n\n\x13\n\x04\x05\x03\x02\x08\x12\x04\xee\x01\x02\
    \n\x1a\x05\x20PHP\n\n\r\n\x05\x05\x03\x02\x08\x01\x12\x04\xee\x01\x02\
    \x05\n\r\n\x05\x05\x03\x02\x08\x02\x12\x04\xee\x01\x08\t\n\x14\n\x04\x05\
    \x03\x02\t\x12\x04\xf1\x01\x02\x16\x1a\x06\x20Test\n\n\r\n\x05\x05\x03\
    \x02\t\x01\x12\x04\xf1\x01\x02\x11\n\r\n\x05\x05\x03\x02\t\x02\x12\x04\
    \xf1\x01\x14\x15\n5\n\x04\x05\x03\x02\n\x12\x04\xf4\x01\x02\x0e\x1a'\x20\
    generic\x20reverse\x20engineering\x20framework\n\n\r\n\x05\x05\x03\x02\n\
    \x01\x12\x04\xf4\x01\x02\x08\n\r\n\x05\x05\x03\x02\n\x02\x12\x04\xf4\x01\
    \x0b\r\n\x16\n\x04\x05\x03\x02\x0b\x12\x04\xf7\x01\x02\x0e\x1a\x08\x20Ko\
    tlin\n\n\r\n\x05\x05\x03\x02\x0b\x01\x12\x04\xf7\x01\x02\x08\n\r\n\x05\
    \x05\x03\x02\x0b\x02\x12\x04\xf7\x01\x0b\r\n2\n\x04\x05\x03\x02\x0c\x12\
    \x04\xfa\x01\x02\x0c\x1a$\x20Eclipse\x20CDT\x20based\x20parser\x20for\
    \x20C/C++\n\n\r\n\x05\x05\x03\x02\x0c\x01\x12\x04\xfa\x01\x02\x06\n\r\n\
    \x05\x05\x03\x02\x0c\x02\x12\x04\xfa\x01\t\x0b\n/\n\x04\x05\x03\x02\r\
    \x12\x04\xfd\x01\x02\x0f\x1a!\x20Source-based\x20front-end\x20for\x20Jav\
    a\n\n\r\n\x05\x05\x03\x02\r\x01\x12\x04\xfd\x01\x02\t\n\r\n\x05\x05\x03\
    \x02\r\x02\x12\x04\xfd\x01\x0c\x0e\n1\n\x04\x05\x03\x02\x0e\x12\x04\x80\
    \x02\x02\x11\x1a#\x20Source-based\x20front-end\x20for\x20Python\n\n\r\n\
    \x05\x05\x03\x02\x0e\x01\x12\x04\x80\x02\x02\x0b\n\r\n\x05\x05\x03\x02\
    \x0e\x02\x12\x04\x80\x02\x0e\x10\n7\n\x04\x05\x03\x02\x0f\x12\x04\x83\
    \x02\x02\r\x1a)\x20Source-based\x20JS\x20frontend\x20based\x20on\x20Babe\
    l\n\n\r\n\x05\x05\x03\x02\x0f\x01\x12\x04\x83\x02\x02\x07\n\r\n\x05\x05\
    \x03\x02\x0f\x02\x12\x04\x83\x02\n\x0c\n*\n\x04\x05\x03\x02\x10\x12\x04\
    \x86\x02\x02\x10\x1a\x1c\x20Solidity\x20language\x20frontend\n\n\r\n\x05\
    \x05\x03\x02\x10\x01\x12\x04\x86\x02\x02\n\n\r\n\x05\x05\x03\x02\x10\x02\
    \x12\x04\x86\x02\r\x0f\n.\n\x04\x05\x03\x02\x11\x12\x04\x89\x02\x02\x0f\
    \x1a\x20\x20Source-based\x20frontend\x20for\x20Ruby\n\n\r\n\x05\x05\x03\
    \x02\x11\x01\x12\x04\x89\x02\x02\t\n\r\n\x05\x05\x03\x02\x11\x02\x12\x04\
    \x89\x02\x0c\x0e\nk\n\x02\x05\x04\x12\x06\x8e\x02\0\x9a\x02\x01\x1a]\x20\
    Enum\x20representing\x20the\x20evaluation\x20strategy\x20of\x20the\x20un\
    derlying\x20parameter\x20or\x20method\x20or\x20literal.\n\n\x0b\n\x03\
    \x05\x04\x01\x12\x04\x8e\x02\x05\x19\n\x0c\n\x04\x05\x04\x02\0\x12\x04\
    \x8f\x02\x02\"\n\r\n\x05\x05\x04\x02\0\x01\x12\x04\x8f\x02\x02\x1d\n\r\n\
    \x05\x05\x04\x02\0\x02\x12\x04\x8f\x02\x20!\n{\n\x04\x05\x04\x02\x01\x12\
    \x04\x92\x02\x02\x13\x1am\x20A\x20parameter\x20or\x20return\x20of\x20a\
    \x20function\x20is\x20passed\x20by\x20reference\x20which\x20means\x20an\
    \x20address\x20is\x20used\x20behind\x20the\x20scenes\n\n\r\n\x05\x05\x04\
    \x02\x01\x01\x12\x04\x92\x02\x02\x0e\n\r\n\x05\x05\x04\x02\x01\x02\x12\
    \x04\x92\x02\x11\x12\n\xd7\x01\n\x04\x05\x04\x02\x02\x12\x04\x95\x02\x02\
    \x11\x1a\xc8\x01\x20Only\x20applicable\x20to\x20object\x20parameter\x20o\
    r\x20return\x20values.\x20The\x20pointer\x20to\x20the\x20object\x20is\
    \x20passed\x20by\x20value\x20but\x20the\x20object\x20itself\x20is\x20not\
    \x20copied\x20and\x20changes\x20to\x20it\x20are\x20thus\x20propagated\
    \x20out\x20of\x20the\x20method\x20context\n\n\r\n\x05\x05\x04\x02\x02\
    \x01\x12\x04\x95\x02\x02\x0c\n\r\n\x05\x05\x04\x02\x02\x02\x12\x04\x95\
    \x02\x0f\x10\nc\n\x04\x05\x04\x02\x03\x12\x04\x98\x02\x02\x0f\x1aU\x20A\
    \x20parameter\x20or\x20return\x20of\x20a\x20function\x20passed\x20by\x20\
    value\x20which\x20means\x20a\x20flat\x20copy\x20is\x20used\n\n\r\n\x05\
    \x05\x04\x02\x03\x01\x12\x04\x98\x02\x02\n\n\r\n\x05\x05\x04\x02\x03\x02\
    \x12\x04\x98\x02\r\x0e\n4\n\x02\x05\x05\x12\x06\x9d\x02\0\xa9\x02\x01\
    \x1a&\x20Enum\x20representing\x20the\x20dispatch\x20types\n\n\x0b\n\x03\
    \x05\x05\x01\x12\x04\x9d\x02\x05\x12\n\x0c\n\x04\x05\x05\x02\0\x12\x04\
    \x9e\x02\x02\x1c\n\r\n\x05\x05\x05\x02\0\x01\x12\x04\x9e\x02\x02\x17\n\r\
    \n\x05\x05\x05\x02\0\x02\x12\x04\x9e\x02\x1a\x1b\na\n\x04\x05\x05\x02\
    \x01\x12\x04\xa1\x02\x02\x16\x1aS\x20For\x20statically\x20dispatched\x20\
    calls\x20the\x20call\x20target\x20is\x20known\x20before\x20program\x20ex\
    ecution\n\n\r\n\x05\x05\x05\x02\x01\x01\x12\x04\xa1\x02\x02\x11\n\r\n\
    \x05\x05\x05\x02\x01\x02\x12\x04\xa1\x02\x14\x15\nX\n\x04\x05\x05\x02\
    \x02\x12\x04\xa4\x02\x02\x17\x1aJ\x20For\x20dynamically\x20dispatched\
    \x20calls\x20the\x20target\x20is\x20determined\x20during\x20runtime\n\n\
    \r\n\x05\x05\x05\x02\x02\x01\x12\x04\xa4\x02\x02\x12\n\r\n\x05\x05\x05\
    \x02\x02\x02\x12\x04\xa4\x02\x15\x16\n6\n\x04\x05\x05\x02\x03\x12\x04\
    \xa7\x02\x02\x0e\x1a(\x20For\x20macro\x20expansions,\x20code\x20is\x20in\
    lined.\n\n\r\n\x05\x05\x05\x02\x03\x01\x12\x04\xa7\x02\x02\t\n\r\n\x05\
    \x05\x05\x02\x03\x02\x12\x04\xa7\x02\x0c\r\n=\n\x02\x05\x06\x12\x06\xac\
    \x02\0\xd6\x02\x01\x1a/\x20Enum\x20representing\x20the\x20control\x20str\
    ucture\x20types\n\n\x0b\n\x03\x05\x06\x01\x12\x04\xac\x02\x05\x1c\n\x0c\
    \n\x04\x05\x06\x02\0\x12\x04\xad\x02\x02%\n\r\n\x05\x05\x06\x02\0\x01\
    \x12\x04\xad\x02\x02\x20\n\r\n\x05\x05\x06\x02\0\x02\x12\x04\xad\x02#$\n\
    z\n\x04\x05\x06\x02\x01\x12\x04\xb0\x02\x02\x0c\x1al\x20Represents\x20a\
    \x20break\x20statement.\x20Labeled\x20breaks\x20are\x20expected\x20to\
    \x20have\x20a\x20JUMP_LABEL\x20node\x20AST\x20child\x20with\x20ORDER\x20\
    1\n\n\r\n\x05\x05\x06\x02\x01\x01\x12\x04\xb0\x02\x02\x07\n\r\n\x05\x05\
    \x06\x02\x01\x02\x12\x04\xb0\x02\n\x0b\n\x80\x01\n\x04\x05\x06\x02\x02\
    \x12\x04\xb3\x02\x02\x0f\x1ar\x20Represents\x20a\x20continue\x20statemen\
    t.\x20Labeled\x20continues\x20are\x20expected\x20to\x20have\x20a\x20JUMP\
    _LABEL\x20node\x20AST\x20child\x20with\x20ORDER\x201\n\n\r\n\x05\x05\x06\
    \x02\x02\x01\x12\x04\xb3\x02\x02\n\n\r\n\x05\x05\x06\x02\x02\x02\x12\x04\
    \xb3\x02\r\x0e\n,\n\x04\x05\x06\x02\x03\x12\x04\xb6\x02\x02\x0c\x1a\x1e\
    \x20Represents\x20a\x20while\x20statement\n\n\r\n\x05\x05\x06\x02\x03\
    \x01\x12\x04\xb6\x02\x02\x07\n\r\n\x05\x05\x06\x02\x03\x02\x12\x04\xb6\
    \x02\n\x0b\n)\n\x04\x05\x06\x02\x04\x12\x04\xb9\x02\x02\t\x1a\x1b\x20Rep\
    resents\x20a\x20do\x20statement\n\n\r\n\x05\x05\x06\x02\x04\x01\x12\x04\
    \xb9\x02\x02\x04\n\r\n\x05\x05\x06\x02\x04\x02\x12\x04\xb9\x02\x07\x08\n\
    *\n\x04\x05\x06\x02\x05\x12\x04\xbc\x02\x02\n\x1a\x1c\x20Represents\x20a\
    \x20for\x20statement\n\n\r\n\x05\x05\x06\x02\x05\x01\x12\x04\xbc\x02\x02\
    \x05\n\r\n\x05\x05\x06\x02\x05\x02\x12\x04\xbc\x02\x08\t\n+\n\x04\x05\
    \x06\x02\x06\x12\x04\xbf\x02\x02\x0b\x1a\x1d\x20Represents\x20a\x20goto\
    \x20statement\n\n\r\n\x05\x05\x06\x02\x06\x01\x12\x04\xbf\x02\x02\x06\n\
    \r\n\x05\x05\x06\x02\x06\x02\x12\x04\xbf\x02\t\n\n*\n\x04\x05\x06\x02\
    \x07\x12\x04\xc2\x02\x02\t\x1a\x1c\x20Represents\x20an\x20if\x20statemen\
    t\n\n\r\n\x05\x05\x06\x02\x07\x01\x12\x04\xc2\x02\x02\x04\n\r\n\x05\x05\
    \x06\x02\x07\x02\x12\x04\xc2\x02\x07\x08\n,\n\x04\x05\x06\x02\x08\x12\
    \x04\xc5\x02\x02\x0b\x1a\x1e\x20Represents\x20an\x20else\x20statement\n\
    \n\r\n\x05\x05\x06\x02\x08\x01\x12\x04\xc5\x02\x02\x06\n\r\n\x05\x05\x06\
    \x02\x08\x02\x12\x04\xc5\x02\t\n\n-\n\x04\x05\x06\x02\t\x12\x04\xc8\x02\
    \x02\r\x1a\x1f\x20Represents\x20a\x20switch\x20statement\n\n\r\n\x05\x05\
    \x06\x02\t\x01\x12\x04\xc8\x02\x02\x08\n\r\n\x05\x05\x06\x02\t\x02\x12\
    \x04\xc8\x02\x0b\x0c\n*\n\x04\x05\x06\x02\n\x12\x04\xcb\x02\x02\x0b\x1a\
    \x1c\x20Represents\x20a\x20try\x20statement\n\n\r\n\x05\x05\x06\x02\n\
    \x01\x12\x04\xcb\x02\x02\x05\n\r\n\x05\x05\x06\x02\n\x02\x12\x04\xcb\x02\
    \x08\n\n,\n\x04\x05\x06\x02\x0b\x12\x04\xce\x02\x02\r\x1a\x1e\x20Represe\
    nts\x20a\x20throw\x20statement\n\n\r\n\x05\x05\x06\x02\x0b\x01\x12\x04\
    \xce\x02\x02\x07\n\r\n\x05\x05\x06\x02\x0b\x02\x12\x04\xce\x02\n\x0c\n-\
    \n\x04\x05\x06\x02\x0c\x12\x04\xd1\x02\x02\r\x1a\x1f\x20Represents\x20a\
    \x20match\x20expression\n\n\r\n\x05\x05\x06\x02\x0c\x01\x12\x04\xd1\x02\
    \x02\x07\n\r\n\x05\x05\x06\x02\x0c\x02\x12\x04\xd1\x02\n\x0c\n-\n\x04\
    \x05\x06\x02\r\x12\x04\xd4\x02\x02\r\x1a\x1f\x20Represents\x20a\x20yield\
    \x20expression\n\n\r\n\x05\x05\x06\x02\r\x01\x12\x04\xd4\x02\x02\x07\n\r\
    \n\x05\x05\x06\x02\r\x02\x12\x04\xd4\x02\n\x0c\n\xa7\x0b\n\x02\x05\x07\
    \x12\x06\xde\x02\0\xf7\x03\x01\x1a\x98\x0b*\n\x20Programming\x20language\
    s\x20offer\x20many\x20closely-related\x20concepts\x20for\x20describing\
    \x20blocks\x20of\x20code\x20that\x20can\x20be\x20executed\x20with\x20inp\
    ut\x20parameters\x20and\x20return\x20output\x20parameters,\x20possibly\
    \x20causing\x20side\x20effects.\x20In\x20the\x20CPG\x20specification,\
    \x20we\x20refer\x20to\x20all\x20of\x20these\x20concepts\x20(procedures,\
    \x20functions,\x20methods,\x20etc.)\x20as\x20methods.\x20A\x20single\x20\
    METHOD\x20node\x20must\x20exist\x20for\x20each\x20method\x20found\x20in\
    \x20the\x20source\x20program.\n\x20The\x20`FULL_NAME`\x20field\x20specif\
    ies\x20the\x20method's\x20fully-qualified\x20name,\x20including\x20infor\
    mation\x20about\x20the\x20namespace\x20it\x20is\x20contained\x20in\x20if\
    \x20applicable,\x20the\x20name\x20field\x20is\x20the\x20function's\x20sh\
    ort\x20name.\x20The\x20field\x20`IS_EXTERNAL`\x20indicates\x20whether\
    \x20it\x20was\x20possible\x20to\x20identify\x20a\x20method\x20body\x20fo\
    r\x20the\x20method.\x20This\x20is\x20true\x20for\x20methods\x20that\x20a\
    re\x20defined\x20in\x20the\x20source\x20program,\x20and\x20false\x20for\
    \x20methods\x20that\x20are\x20dynamically\x20linked\x20to\x20the\x20prog\
    ram,\x20that\x20is,\x20methods\x20that\x20exist\x20in\x20an\x20external\
    \x20dependency.\n\x20Line\x20and\x20column\x20number\x20information\x20i\
    s\x20specified\x20in\x20the\x20optional\x20fields\x20`LINE_NUMBER`,\x20`\
    COLUMN_NUMBER`,\x20`LINE_NUMBER_END`,\x20and\x20`COLUMN_NUMBER_END`\x20a\
    nd\x20the\x20name\x20of\x20the\x20source\x20file\x20is\x20specified\x20i\
    n\x20`FILENAME`.\x20An\x20optional\x20hash\x20value\x20MAY\x20be\x20calc\
    ulated\x20over\x20the\x20function\x20contents\x20and\x20included\x20in\
    \x20the\x20`HASH`\x20field.\n\x20Finally,\x20the\x20fully\x20qualified\
    \x20name\x20of\x20the\x20program\x20constructs\x20that\x20the\x20method\
    \x20is\x20immediately\x20contained\x20in\x20is\x20stored\x20in\x20the\
    \x20`AST_PARENT_FULL_NAME`\x20field\x20and\x20its\x20type\x20is\x20indic\
    ated\x20in\x20the\x20`AST_PARENT_TYPE`\x20field\x20to\x20be\x20one\x20of\
    \x20`METHOD`,\x20`TYPE_DECL`\x20or\x20`NAMESPACE_BLOCK`.\n\n\x0b\n\x03\
    \x05\x07\x01\x12\x04\xde\x02\x05\r\n\x0c\n\x04\x05\x07\x02\0\x12\x04\xdf\
    \x02\x02\x18\n\r\n\x05\x05\x07\x02\0\x01\x12\x04\xdf\x02\x02\x13\n\r\n\
    \x05\x05\x07\x02\0\x02\x12\x04\xdf\x02\x16\x17\n\x1c\n\x04\x05\x07\x02\
    \x01\x12\x04\xe2\x02\x02\r\x1a\x0e\x20Method\x20Nodes\n\n\r\n\x05\x05\
    \x07\x02\x01\x01\x12\x04\xe2\x02\x02\x08\n\r\n\x05\x05\x07\x02\x01\x02\
    \x12\x04\xe2\x02\x0b\x0c\n\x93\x02\n\x04\x05\x07\x02\x02\x12\x04\xe5\x02\
    \x02\x14\x1a\x84\x02\x20This\x20node\x20represents\x20an\x20(unnamed)\
    \x20formal\x20method\x20return\x20parameter.\x20It\x20carries\x20its\x20\
    fully\x20qualified\x20type\x20name\x20in\x20`TYPE_FULL_NAME`.\x20The\x20\
    `CODE`\x20field\x20MAY\x20be\x20set\x20freely,\x20e.g.,\x20to\x20the\x20\
    constant\x20`RET`,\x20however,\x20subsequent\x20layer\x20creators\x20MUS\
    T\x20NOT\x20depend\x20on\x20this\x20value.\n\n\r\n\x05\x05\x07\x02\x02\
    \x01\x12\x04\xe5\x02\x02\x0f\n\r\n\x05\x05\x07\x02\x02\x02\x12\x04\xe5\
    \x02\x12\x13\n\xf9\x01\n\x04\x05\x07\x02\x03\x12\x04\xe8\x02\x02\x11\x1a\
    \xea\x01\x20A\x20method\x20annotation.\x20The\x20semantics\x20of\x20the\
    \x20FULL_NAME\x20property\x20on\x20this\x20node\x20differ\x20from\x20the\
    \x20usual\x20FULL_NAME\x20semantics\x20in\x20the\x20sense\x20that\x20FUL\
    L_NAME\x20describes\x20the\x20represented\x20annotation\x20class/interfa\
    ce\x20itself\x20and\x20not\x20the\x20ANNOTATION\x20node.\n\n\r\n\x05\x05\
    \x07\x02\x03\x01\x12\x04\xe8\x02\x02\x0c\n\r\n\x05\x05\x07\x02\x03\x02\
    \x12\x04\xe8\x02\x0f\x10\nI\n\x04\x05\x07\x02\x04\x12\x04\xeb\x02\x02\"\
    \x1a;\x20Assignment\x20of\x20annotation\x20argument\x20to\x20annotation\
    \x20parameter\n\n\r\n\x05\x05\x07\x02\x04\x01\x12\x04\xeb\x02\x02\x1d\n\
    \r\n\x05\x05\x07\x02\x04\x02\x12\x04\xeb\x02\x20!\n+\n\x04\x05\x07\x02\
    \x05\x12\x04\xee\x02\x02\x1b\x1a\x1d\x20Formal\x20annotation\x20paramete\
    r\n\n\r\n\x05\x05\x07\x02\x05\x01\x12\x04\xee\x02\x02\x16\n\r\n\x05\x05\
    \x07\x02\x05\x02\x12\x04\xee\x02\x19\x1a\n\x90\x02\n\x04\x05\x07\x02\x06\
    \x12\x04\xf1\x02\x02\x0e\x1a\x81\x02\x20This\x20node\x20represents\x20a\
    \x20literal\x20such\x20as\x20an\x20integer\x20or\x20string\x20constant.\
    \x20Literals\x20are\x20symbols\x20included\x20in\x20the\x20code\x20in\
    \x20verbatim\x20form\x20and\x20which\x20are\x20immutable.\x20The\x20`TYP\
    E_FULL_NAME`\x20field\x20stores\x20the\x20literal's\x20fully-qualified\
    \x20type\x20name,\x20e.g.,\x20`java.lang.Integer`.\n\n\r\n\x05\x05\x07\
    \x02\x06\x01\x12\x04\xf1\x02\x02\t\n\r\n\x05\x05\x07\x02\x06\x02\x12\x04\
    \xf1\x02\x0c\r\n\xba\x01\n\x04\x05\x07\x02\x07\x12\x04\xf4\x02\x02\r\x1a\
    \xab\x01\x20This\x20node\x20represents\x20a\x20type\x20member\x20of\x20a\
    \x20class,\x20struct\x20or\x20union,\x20e.g.,\x20for\x20the\x20type\x20d\
    eclaration\x20`class\x20Foo{\x20int\x20i\x20;\x20}`,\x20it\x20represents\
    \x20the\x20declaration\x20of\x20the\x20variable\x20`i`.\n\n\r\n\x05\x05\
    \x07\x02\x07\x01\x12\x04\xf4\x02\x02\x08\n\r\n\x05\x05\x07\x02\x07\x02\
    \x12\x04\xf4\x02\x0b\x0c\n3\n\x04\x05\x07\x02\x08\x12\x04\xf7\x02\x02\
    \x19\x1a%\x20Initialization\x20construct\x20for\x20arrays\n\n\r\n\x05\
    \x05\x07\x02\x08\x01\x12\x04\xf7\x02\x02\x13\n\r\n\x05\x05\x07\x02\x08\
    \x02\x12\x04\xf7\x02\x16\x18\n\xc0\x05\n\x04\x05\x07\x02\t\x12\x04\xfa\
    \x02\x02\x0c\x1a\xb1\x05\x20A\x20(function/method/procedure)\x20call.\
    \x20The\x20`METHOD_FULL_NAME`\x20property\x20is\x20the\x20name\x20of\x20\
    the\x20invoked\x20method\x20(the\x20callee)\x20while\x20the\x20`TYPE_FUL\
    L_NAME`\x20is\x20its\x20return\x20type,\x20and\x20therefore,\x20the\x20r\
    eturn\x20type\x20of\x20the\x20call\x20when\x20viewing\x20it\x20as\x20an\
    \x20expression.\x20For\x20languages\x20like\x20Javascript,\x20it\x20is\
    \x20common\x20that\x20we\x20may\x20know\x20the\x20(short-)\x20name\x20of\
    \x20the\x20invoked\x20method,\x20but\x20we\x20do\x20not\x20know\x20at\
    \x20compile\x20time\x20which\x20method\x20will\x20actually\x20be\x20invo\
    ked,\x20e.g.,\x20because\x20it\x20depends\x20on\x20a\x20dynamic\x20impor\
    t.\x20In\x20this\x20case,\x20we\x20leave\x20`METHOD_FULL_NAME`\x20blank\
    \x20but\x20at\x20least\x20fill\x20out\x20`NAME`,\x20which\x20contains\
    \x20the\x20method's\x20(short-)\x20name\x20and\x20`SIGNATURE`,\x20which\
    \x20contains\x20any\x20information\x20we\x20may\x20have\x20about\x20the\
    \x20types\x20of\x20arguments\x20and\x20return\x20value.\n\n\r\n\x05\x05\
    \x07\x02\t\x01\x12\x04\xfa\x02\x02\x06\n\r\n\x05\x05\x07\x02\t\x02\x12\
    \x04\xfa\x02\t\x0b\n\xa5\x02\n\x04\x05\x07\x02\n\x12\x04\xfd\x02\x02\r\
    \x1a\x96\x02\x20This\x20node\x20represents\x20a\x20local\x20variable.\
    \x20Its\x20fully\x20qualified\x20type\x20name\x20is\x20stored\x20in\x20t\
    he\x20`TYPE_FULL_NAME`\x20field\x20and\x20its\x20name\x20in\x20the\x20`N\
    AME`\x20field.\x20The\x20`CODE`\x20field\x20contains\x20the\x20entire\
    \x20local\x20variable\x20declaration\x20without\x20initialization,\x20e.\
    g.,\x20for\x20`int\x20x\x20=\x2010;`,\x20it\x20contains\x20`int\x20x`.\n\
    \n\r\n\x05\x05\x07\x02\n\x01\x12\x04\xfd\x02\x02\x07\n\r\n\x05\x05\x07\
    \x02\n\x02\x12\x04\xfd\x02\n\x0c\n+\n\x04\x05\x07\x02\x0b\x12\x04\x80\
    \x03\x02\x0b\x1a\x1d\x20This\x20node\x20represents\x20a\x20tag.\n\n\r\n\
    \x05\x05\x07\x02\x0b\x01\x12\x04\x80\x03\x02\x05\n\r\n\x05\x05\x07\x02\
    \x0b\x02\x12\x04\x80\x03\x08\n\nB\n\x04\x05\x07\x02\x0c\x12\x04\x83\x03\
    \x02\x10\x1a4\x20A\x20location\x20node\x20summarizes\x20a\x20source\x20c\
    ode\x20location.\n\n\r\n\x05\x05\x07\x02\x0c\x01\x12\x04\x83\x03\x02\n\n\
    \r\n\x05\x05\x07\x02\x0c\x02\x12\x04\x83\x03\r\x0f\n\xcb\x01\n\x04\x05\
    \x07\x02\r\x12\x04\x86\x03\x02\x12\x1a\xbc\x01\x20This\x20node\x20repres\
    ents\x20an\x20identifier\x20as\x20used\x20when\x20referring\x20to\x20a\
    \x20variable\x20by\x20name.\x20It\x20holds\x20the\x20identifier's\x20nam\
    e\x20in\x20the\x20`NAME`\x20field\x20and\x20its\x20fully-qualified\x20ty\
    pe\x20name\x20in\x20`TYPE_FULL_NAME`.\n\n\r\n\x05\x05\x07\x02\r\x01\x12\
    \x04\x86\x03\x02\x0c\n\r\n\x05\x05\x07\x02\r\x02\x12\x04\x86\x03\x0f\x11\
    \n\xce\x01\n\x04\x05\x07\x02\x0e\x12\x04\x89\x03\x02\x0e\x1a\xbf\x01\x20\
    This\x20node\x20represents\x20a\x20return\x20instruction,\x20e.g.,\x20`r\
    eturn\x20x`.\x20Note\x20that\x20it\x20does\x20NOT\x20represent\x20a\x20f\
    ormal\x20return\x20parameter\x20as\x20formal\x20return\x20parameters\x20\
    are\x20represented\x20via\x20`METHOD_RETURN`\x20nodes.\n\n\r\n\x05\x05\
    \x07\x02\x0e\x01\x12\x04\x89\x03\x02\x08\n\r\n\x05\x05\x07\x02\x0e\x02\
    \x12\x04\x89\x03\x0b\r\n\xee\x05\n\x04\x05\x07\x02\x0f\x12\x04\x8c\x03\
    \x02\r\x1a\xdf\x05\x20This\x20node\x20represents\x20a\x20compound\x20sta\
    tement.\x20Compound\x20statements\x20are\x20used\x20in\x20many\x20langua\
    ges\x20to\x20allow\x20grouping\x20a\x20sequence\x20of\x20statements.\x20\
    For\x20example,\x20in\x20C\x20and\x20Java,\x20compound\x20statements\x20\
    are\x20statements\x20enclosed\x20by\x20curly\x20braces.\x20Function/Meth\
    od\x20bodies\x20are\x20compound\x20statements.\x20We\x20do\x20not\x20use\
    \x20the\x20term\x20\"compound\x20statement\"\x20because\x20\"statement\"\
    \x20would\x20imply\x20that\x20the\x20block\x20does\x20not\x20yield\x20a\
    \x20value\x20upon\x20evaluation,\x20that\x20is,\x20that\x20it\x20is\x20n\
    ot\x20an\x20expression.\x20This\x20is\x20true\x20in\x20languages\x20such\
    \x20as\x20C\x20and\x20Java,\x20but\x20not\x20for\x20languages\x20such\
    \x20as\x20Scala\x20where\x20the\x20value\x20of\x20the\x20block\x20is\x20\
    given\x20by\x20that\x20of\x20the\x20last\x20expression\x20it\x20contains\
    .\x20In\x20fact,\x20the\x20Scala\x20grammar\x20uses\x20the\x20term\x20\"\
    BlockExpr\"\x20(short\x20for\x20\"block\x20expression\")\x20to\x20descri\
    be\x20what\x20in\x20the\x20CPG\x20we\x20call\x20\"Block\".\n\n\r\n\x05\
    \x05\x07\x02\x0f\x01\x12\x04\x8c\x03\x02\x07\n\r\n\x05\x05\x07\x02\x0f\
    \x02\x12\x04\x8c\x03\n\x0c\n\xd7\x01\n\x04\x05\x07\x02\x10\x12\x04\x8f\
    \x03\x02\x1c\x1a\xc8\x01\x20This\x20node\x20represents\x20a\x20formal\
    \x20output\x20parameter.\x20Corresponding\x20output\x20parameters\x20for\
    \x20input\x20parameters\x20MUST\x20NOT\x20be\x20created\x20by\x20the\x20\
    frontend\x20as\x20they\x20are\x20automatically\x20created\x20upon\x20fir\
    st\x20loading\x20the\x20CPG.\n\n\r\n\x05\x05\x07\x02\x10\x01\x12\x04\x8f\
    \x03\x02\x16\n\r\n\x05\x05\x07\x02\x10\x02\x12\x04\x8f\x03\x19\x1b\n\xac\
    \x01\n\x04\x05\x07\x02\x11\x12\x04\x92\x03\x02\x1b\x1a\x9d\x01\x20This\
    \x20node\x20represents\x20a\x20formal\x20input\x20parameter.\x20The\x20f\
    ield\x20`NAME`\x20contains\x20its\x20name,\x20while\x20the\x20field\x20`\
    TYPE_FULL_NAME`\x20contains\x20the\x20fully\x20qualified\x20type\x20name\
    .\n\n\r\n\x05\x05\x07\x02\x11\x01\x12\x04\x92\x03\x02\x15\n\r\n\x05\x05\
    \x07\x02\x11\x02\x12\x04\x92\x03\x18\x1a\n1\n\x04\x05\x07\x02\x12\x12\
    \x04\x95\x03\x02\x12\x1a#\x20This\x20node\x20represents\x20a\x20dependen\
    cy\n\n\r\n\x05\x05\x07\x02\x12\x01\x12\x04\x95\x03\x02\x0c\n\r\n\x05\x05\
    \x07\x02\x12\x02\x12\x04\x95\x03\x0f\x11\n\xd9\x07\n\x04\x05\x07\x02\x13\
    \x12\x04\x9d\x03\x02\x0c\x1a\xca\x07*\n\x20File\x20nodes\x20represent\
    \x20source\x20files\x20or\x20a\x20shared\x20objects\x20from\x20which\x20\
    the\x20CPG\x20was\x20generated.\x20File\x20nodes\x20serve\x20as\x20indic\
    es,\x20that\x20is,\x20they\x20allow\x20looking\x20up\x20all\x20elements\
    \x20of\x20the\x20code\x20by\x20file.\n\x20For\x20each\x20file,\x20the\
    \x20graph\x20MUST\x20contain\x20exactly\x20one\x20File\x20node.\x20As\
    \x20file\x20nodes\x20are\x20root\x20nodes\x20of\x20abstract\x20syntax\
    \x20tress,\x20they\x20are\x20AstNodes\x20and\x20their\x20order\x20field\
    \x20is\x20set\x20to\x200.\x20This\x20is\x20because\x20they\x20have\x20no\
    \x20sibling\x20nodes,\x20not\x20because\x20they\x20are\x20the\x20first\
    \x20node\x20of\x20the\x20AST.\n\x20Each\x20CPG\x20MUST\x20contain\x20a\
    \x20special\x20file\x20node\x20with\x20name\x20set\x20to\x20`<unknown>`.\
    \x20This\x20node\x20is\x20a\x20placeholder\x20used\x20in\x20cases\x20whe\
    re\x20a\x20file\x20cannot\x20be\x20determined\x20at\x20compile\x20time.\
    \x20As\x20an\x20example,\x20consider\x20external\x20library\x20functions\
    .\x20As\x20their\x20code\x20is\x20not\x20available\x20on\x20CPG\x20const\
    ruction,\x20the\x20file\x20name\x20is\x20unknown.\n\x20File\x20nodes\x20\
    MUST\x20NOT\x20be\x20created\x20by\x20the\x20language\x20frontend.\x20In\
    stead,\x20the\x20language\x20frontend\x20is\x20assumed\x20to\x20fill\x20\
    out\x20the\x20`FILENAME`\x20field\x20wherever\x20possible,\x20allowing\
    \x20File\x20nodes\x20to\x20be\x20created\x20automatically\x20upon\x20fir\
    st\x20loading\x20the\x20CPG.\n\n\r\n\x05\x05\x07\x02\x13\x01\x12\x04\x9d\
    \x03\x02\x06\n\r\n\x05\x05\x07\x02\x13\x02\x12\x04\x9d\x03\t\x0b\n\xc4\
    \x03\n\x04\x05\x07\x02\x14\x12\x04\xa0\x03\x02\x11\x1a\xb5\x03\x20This\
    \x20node\x20contains\x20the\x20CPG\x20meta\x20data.\x20Exactly\x20one\
    \x20node\x20of\x20this\x20type\x20MUST\x20exist\x20per\x20CPG.\x20The\
    \x20`HASH`\x20property\x20MAY\x20contain\x20a\x20hash\x20value\x20calcul\
    ated\x20over\x20the\x20source\x20files\x20this\x20CPG\x20was\x20generate\
    d\x20from.\x20The\x20`VERSION`\x20MUST\x20be\x20set\x20to\x20the\x20vers\
    ion\x20of\x20the\x20specification\x20(\"1.1\").\x20The\x20language\x20fi\
    eld\x20indicates\x20which\x20language\x20frontend\x20was\x20used\x20to\
    \x20generate\x20the\x20CPG\x20and\x20the\x20list\x20property\x20`OVERLAY\
    S`\x20specifies\x20which\x20overlays\x20have\x20been\x20applied\x20to\
    \x20the\x20CPG.\n\n\r\n\x05\x05\x07\x02\x14\x01\x12\x04\xa0\x03\x02\x0b\
    \n\r\n\x05\x05\x07\x02\x14\x02\x12\x04\xa0\x03\x0e\x10\n\xfa\x02\n\x04\
    \x05\x07\x02\x15\x12\x04\xa4\x03\x02\x11\x1a\xeb\x02\x20This\x20node\x20\
    represents\x20a\x20namespace.\x20Similar\x20to\x20FILE\x20nodes,\x20NAME\
    SPACE\x20nodes\x20serve\x20as\x20indices\x20that\x20allow\x20all\x20defi\
    nitions\x20inside\x20a\x20namespace\x20to\x20be\x20obtained\x20by\x20fol\
    lowing\x20outgoing\x20edges\x20from\x20a\x20NAMESPACE\x20node.\n\x20NAME\
    SPACE\x20nodes\x20MUST\x20NOT\x20be\x20created\x20by\x20language\x20fron\
    tends.\x20Instead,\x20they\x20are\x20generated\x20from\x20NAMESPACE_BLOC\
    K\x20nodes\x20automatically\x20upon\x20first\x20loading\x20of\x20the\x20\
    CPG.\n\n\r\n\x05\x05\x07\x02\x15\x01\x12\x04\xa4\x03\x02\x0b\n\r\n\x05\
    \x05\x07\x02\x15\x02\x12\x04\xa4\x03\x0e\x10\n\xcd\x06\n\x04\x05\x07\x02\
    \x16\x12\x04\xad\x03\x02\x17\x1a\xbe\x06*\n\x20A\x20reference\x20to\x20a\
    \x20namespace.\n\x20We\x20borrow\x20the\x20concept\x20of\x20a\x20\"names\
    pace\x20block\"\x20from\x20C++,\x20that\x20is,\x20a\x20namespace\x20bloc\
    k\x20is\x20a\x20block\x20of\x20code\x20that\x20has\x20been\x20placed\x20\
    in\x20the\x20same\x20namespace\x20by\x20a\x20programmer.\x20This\x20bloc\
    k\x20may\x20be\x20introduced\x20via\x20a\x20`package`\x20statement\x20in\
    \x20Java\x20or\x20a\x20`namespace{\x20}`\x20statement\x20in\x20C++.\n\
    \x20The\x20`FULL_NAME`\x20field\x20contains\x20a\x20unique\x20identifier\
    \x20to\x20represent\x20the\x20namespace\x20block\x20itself\x20not\x20jus\
    t\x20the\x20namespace\x20it\x20references.\x20So\x20in\x20addition\x20to\
    \x20the\x20namespace\x20name\x20it\x20can\x20be\x20useful\x20to\x20use\
    \x20the\x20containing\x20file\x20name\x20to\x20derive\x20a\x20unique\x20\
    identifier.\n\n\x20The\x20`NAME`\x20field\x20contains\x20the\x20namespac\
    e\x20name\x20in\x20a\x20human-readable\x20format.\x20The\x20name\x20shou\
    ld\x20be\x20given\x20in\x20dot-separated\x20form\x20where\x20a\x20dot\
    \x20indicates\x20that\x20the\x20right\x20hand\x20side\x20is\x20a\x20sub\
    \x20namespace\x20of\x20the\x20left\x20hand\x20side,\x20e.g.,\x20`foo.bar\
    `\x20denotes\x20the\x20namespace\x20`bar`\x20contained\x20in\x20the\x20n\
    amespace\x20`foo`.\n\n\r\n\x05\x05\x07\x02\x16\x01\x12\x04\xad\x03\x02\
    \x11\n\r\n\x05\x05\x07\x02\x16\x02\x12\x04\xad\x03\x14\x16\n\xc9\x01\n\
    \x04\x05\x07\x02\x17\x12\x04\xb0\x03\x02\x0f\x1a\xba\x01\x20Any\x20AST\
    \x20node\x20that\x20the\x20frontend\x20would\x20like\x20to\x20include\
    \x20in\x20the\x20AST\x20but\x20for\x20which\x20no\x20suitable\x20AST\x20\
    node\x20is\x20specified\x20in\x20the\x20CPG\x20specification\x20may\x20b\
    e\x20included\x20using\x20a\x20node\x20of\x20type\x20`UNKNOWN`.\n\n\r\n\
    \x05\x05\x07\x02\x17\x01\x12\x04\xb0\x03\x02\t\n\r\n\x05\x05\x07\x02\x17\
    \x02\x12\x04\xb0\x03\x0c\x0e\nn\n\x04\x05\x07\x02\x18\x12\x04\xb3\x03\
    \x02\x0c\x1a`\x20This\x20node\x20represents\x20a\x20type\x20instance,\
    \x20that\x20is,\x20a\x20concrete\x20instantiation\x20of\x20a\x20type\x20\
    declaration.\n\n\r\n\x05\x05\x07\x02\x18\x01\x12\x04\xb3\x03\x02\x06\n\r\
    \n\x05\x05\x07\x02\x18\x02\x12\x04\xb3\x03\t\x0b\n\xf1\x0c\n\x04\x05\x07\
    \x02\x19\x12\x04\xbc\x03\x02\x11\x1a\xe2\x0c*\n\x20This\x20node\x20repre\
    sents\x20a\x20type\x20declaration\x20as\x20for\x20example\x20given\x20by\
    \x20a\x20class-,\x20struct-,\x20or\x20union\x20declaration.\x20In\x20con\
    trast\x20to\x20a\x20`TYPE`\x20node,\x20this\x20node\x20does\x20not\x20re\
    present\x20a\x20concrete\x20instantiation\x20of\x20a\x20type,\x20e.g.,\
    \x20for\x20the\x20parametrized\x20type\x20`List[T]`,\x20it\x20represents\
    \x20`List[T]`,\x20but\x20not\x20`List[Integer]`\x20where\x20`Integer`\
    \x20is\x20a\x20concrete\x20type.\n\x20The\x20language\x20frontend\x20MUS\
    T\x20create\x20type\x20declarations\x20for\x20all\x20types\x20declared\
    \x20in\x20the\x20source\x20program\x20and\x20MAY\x20provide\x20type\x20d\
    eclarations\x20for\x20types\x20that\x20are\x20not\x20declared\x20but\x20\
    referenced\x20by\x20the\x20source\x20program.\x20If\x20a\x20declaration\
    \x20is\x20present\x20in\x20the\x20source\x20program,\x20the\x20field\x20\
    `IS_EXTERNAL`\x20is\x20set\x20to\x20`false`.\x20Otherwise,\x20it\x20is\
    \x20set\x20to\x20`true`.\n\x20The\x20`FULL_NAME`\x20field\x20specifies\
    \x20the\x20type's\x20fully-qualified\x20name,\x20including\x20informatio\
    n\x20about\x20the\x20namespace\x20it\x20is\x20contained\x20in\x20if\x20a\
    pplicable,\x20the\x20name\x20field\x20is\x20the\x20type's\x20short\x20na\
    me.\x20Line\x20and\x20column\x20number\x20information\x20is\x20specified\
    \x20in\x20the\x20optional\x20fields\x20`LINE_NUMBER`,\x20`COLUMN_NUMBER`\
    ,\x20`LINE_NUMBER_END`,\x20and\x20`COLUMN_NUMBER_END`\x20and\x20the\x20n\
    ame\x20of\x20the\x20source\x20file\x20is\x20specified\x20in\x20`FILENAME\
    `.\n\x20Base\x20types\x20can\x20be\x20specified\x20via\x20the\x20`INHERI\
    TS_FROM_TYPE_FULL_NAME`\x20list,\x20where\x20each\x20entry\x20contains\
    \x20the\x20fully-qualified\x20name\x20of\x20a\x20base\x20type.\x20If\x20\
    the\x20type\x20is\x20known\x20to\x20be\x20an\x20alias\x20of\x20another\
    \x20type\x20(as\x20for\x20example\x20introduced\x20via\x20the\x20C\x20`t\
    ypedef`\x20statement),\x20the\x20name\x20of\x20the\x20alias\x20is\x20sto\
    red\x20in\x20`ALIAS_TYPE_FULL_NAME`.\n\x20Finally,\x20the\x20fully\x20qu\
    alified\x20name\x20of\x20the\x20program\x20constructs\x20that\x20the\x20\
    type\x20declaration\x20is\x20immediately\x20contained\x20in\x20is\x20sto\
    red\x20in\x20the\x20`AST_PARENT_FULL_NAME`\x20field\x20and\x20its\x20typ\
    e\x20is\x20indicated\x20in\x20the\x20`AST_PARENT_TYPE`\x20field\x20to\
    \x20be\x20one\x20of\x20`METHOD`,\x20`TYPE_DECL`\x20or\x20`NAMESPACE_BLOC\
    K`.\n\n\r\n\x05\x05\x07\x02\x19\x01\x12\x04\xbc\x03\x02\x0b\n\r\n\x05\
    \x05\x07\x02\x19\x02\x12\x04\xbc\x03\x0e\x10\n\xf7\x02\n\x04\x05\x07\x02\
    \x1a\x12\x04\xbf\x03\x02\x16\x1a\xe8\x02\x20This\x20node\x20represents\
    \x20a\x20formal\x20type\x20parameter,\x20that\x20is,\x20the\x20type\x20p\
    arameter\x20as\x20given\x20in\x20a\x20type-parametrized\x20method\x20or\
    \x20type\x20declaration.\x20Examples\x20for\x20languages\x20that\x20supp\
    ort\x20type\x20parameters\x20are\x20Java\x20(via\x20Generics)\x20and\x20\
    C++\x20(via\x20templates).\x20Apart\x20from\x20the\x20standard\x20fields\
    \x20of\x20AST\x20nodes,\x20the\x20type\x20parameter\x20carries\x20only\
    \x20a\x20`NAME`\x20field\x20that\x20holds\x20the\x20parameters\x20name.\
    \n\n\r\n\x05\x05\x07\x02\x1a\x01\x12\x04\xbf\x03\x02\x10\n\r\n\x05\x05\
    \x07\x02\x1a\x02\x12\x04\xbf\x03\x13\x15\n\xc5\x02\n\x04\x05\x07\x02\x1b\
    \x12\x04\xc2\x03\x02\x15\x1a\xb6\x02\x20An\x20(actual)\x20type\x20argume\
    nt\x20as\x20used\x20to\x20instantiate\x20a\x20parametrized\x20type,\x20i\
    n\x20the\x20same\x20way\x20an\x20(actual)\x20arguments\x20provides\x20co\
    ncrete\x20values\x20for\x20a\x20parameter\x20at\x20method\x20call\x20sit\
    es.\x20As\x20it\x20true\x20for\x20arguments,\x20the\x20method\x20is\x20n\
    ot\x20expected\x20to\x20\x20interpret\x20the\x20type\x20argument.\x20It\
    \x20MUST\x20however\x20store\x20its\x20code\x20in\x20the\x20`CODE`\x20fi\
    eld.\n\n\r\n\x05\x05\x07\x02\x1b\x01\x12\x04\xc2\x03\x02\x0f\n\r\n\x05\
    \x05\x07\x02\x1b\x02\x12\x04\xc2\x03\x12\x14\nC\n\x04\x05\x07\x02\x1c\
    \x12\x04\xc5\x03\x02\x1a\x1a5\x20A\x20literal\x20value\x20assigned\x20to\
    \x20an\x20ANNOTATION_PARAMETER\n\n\r\n\x05\x05\x07\x02\x1c\x01\x12\x04\
    \xc5\x03\x02\x14\n\r\n\x05\x05\x07\x02\x1c\x02\x12\x04\xc5\x03\x17\x19\n\
    \x8e\x02\n\x04\x05\x07\x02\x1d\x12\x04\xc8\x03\x02\x13\x1a\xff\x01\x20Th\
    is\x20node\x20type\x20represent\x20a\x20configuration\x20file,\x20where\
    \x20`NAME`\x20is\x20the\x20name\x20of\x20the\x20file\x20and\x20`content`\
    \x20is\x20its\x20content.\x20The\x20exact\x20representation\x20of\x20the\
    \x20name\x20is\x20left\x20undefined\x20and\x20can\x20be\x20chosen\x20as\
    \x20required\x20by\x20consumers\x20of\x20the\x20corresponding\x20configu\
    ration\x20files.\n\n\r\n\x05\x05\x07\x02\x1d\x01\x12\x04\xc8\x03\x02\r\n\
    \r\n\x05\x05\x07\x02\x1d\x02\x12\x04\xc8\x03\x10\x12\n\xde\x02\n\x04\x05\
    \x07\x02\x1e\x12\x04\xcb\x03\x02\x10\x1a\xcf\x02\x20`BINDING`\x20nodes\
    \x20represent\x20name-signature\x20pairs\x20that\x20can\x20be\x20resolve\
    d\x20at\x20a\x20type\x20declaration\x20(`TYPE_DECL`).\x20They\x20are\x20\
    connected\x20to\x20`TYPE_DECL`\x20nodes\x20via\x20incoming\x20`BINDS`\
    \x20edges.\x20The\x20bound\x20method\x20is\x20either\x20associated\x20wi\
    th\x20an\x20outgoing\x20`REF`\x20edge\x20to\x20a\x20`METHOD`\x20or\x20wi\
    th\x20the\x20`METHOD_FULL_NAME`\x20property.\x20The\x20`REF`\x20edge\x20\
    if\x20present\x20has\x20priority.\n\n\r\n\x05\x05\x07\x02\x1e\x01\x12\
    \x04\xcb\x03\x02\t\n\r\n\x05\x05\x07\x02\x1e\x02\x12\x04\xcb\x03\x0c\x0f\
    \nP\n\x04\x05\x07\x02\x1f\x12\x04\xce\x03\x02\x16\x1aB\x20This\x20node\
    \x20contains\x20an\x20arbitrary\x20node\x20and\x20an\x20associated\x20ta\
    g\x20node.\n\n\r\n\x05\x05\x07\x02\x1f\x01\x12\x04\xce\x03\x02\x0f\n\r\n\
    \x05\x05\x07\x02\x1f\x02\x12\x04\xce\x03\x12\x15\n\xf0\x02\n\x04\x05\x07\
    \x02\x20\x12\x04\xd2\x03\x02\x10\x1a\xe1\x02\x20Finding\x20nodes\x20may\
    \x20be\x20used\x20to\x20store\x20analysis\x20results\x20in\x20the\x20gra\
    ph\x20that\x20are\x20to\x20be\x20exposed\x20to\x20an\x20end-user,\x20e.g\
    .,\x20information\x20about\x20potential\x20vulnerabilities\x20or\x20dang\
    erous\x20programming\x20practices.\n\x20A\x20Finding\x20node\x20may\x20c\
    ontain\x20an\x20abitrary\x20list\x20of\x20key\x20value\x20pairs\x20that\
    \x20characterize\x20the\x20finding,\x20as\x20well\x20as\x20a\x20list\x20\
    of\x20nodes\x20that\x20serve\x20as\x20evidence\x20for\x20the\x20finding.\
    \n\n\r\n\x05\x05\x07\x02\x20\x01\x12\x04\xd2\x03\x02\t\n\r\n\x05\x05\x07\
    \x02\x20\x02\x12\x04\xd2\x03\x0c\x0f\nd\n\x04\x05\x07\x02!\x12\x04\xd5\
    \x03\x02\x17\x1aV\x20This\x20node\x20represents\x20a\x20key\x20value\x20\
    pair,\x20where\x20both\x20the\x20key\x20and\x20the\x20value\x20are\x20st\
    rings.\n\n\r\n\x05\x05\x07\x02!\x01\x12\x04\xd5\x03\x02\x10\n\r\n\x05\
    \x05\x07\x02!\x02\x12\x04\xd5\x03\x13\x16\n\xfc\x01\n\x04\x05\x07\x02\"\
    \x12\x04\xd8\x03\x02\x11\x1a\xed\x01\x20This\x20field\x20represents\x20a\
    \x20(language-dependent)\x20modifier\x20such\x20as\x20`static`,\x20`priv\
    ate`\x20or\x20`public`.\x20Unlike\x20most\x20other\x20AST\x20nodes,\x20i\
    t\x20is\x20NOT\x20an\x20expression,\x20that\x20is,\x20it\x20cannot\x20be\
    \x20evaluated\x20and\x20cannot\x20be\x20passed\x20as\x20an\x20argument\
    \x20in\x20function\x20calls.\n\n\r\n\x05\x05\x07\x02\"\x01\x12\x04\xd8\
    \x03\x02\n\n\r\n\x05\x05\x07\x02\"\x02\x12\x04\xd8\x03\r\x10\n\xa3\x02\n\
    \x04\x05\x07\x02#\x12\x04\xdb\x03\x02\x13\x1a\x94\x02\x20This\x20node\
    \x20represents\x20a\x20reference\x20to\x20a\x20method/function/procedure\
    \x20as\x20it\x20appears\x20when\x20a\x20method\x20is\x20passed\x20as\x20\
    an\x20argument\x20in\x20a\x20call.\x20The\x20`METHOD_FULL_NAME`\x20field\
    \x20holds\x20the\x20fully-qualified\x20name\x20of\x20the\x20referenced\
    \x20method\x20and\x20the\x20`TYPE_FULL_NAME`\x20holds\x20its\x20fully-qu\
    alified\x20type\x20name.\n\n\r\n\x05\x05\x07\x02#\x01\x12\x04\xdb\x03\
    \x02\x0c\n\r\n\x05\x05\x07\x02#\x02\x12\x04\xdb\x03\x0f\x12\ne\n\x04\x05\
    \x07\x02$\x12\x04\xde\x03\x02\x18\x1aW\x20Represents\x20the\x20binding\
    \x20of\x20a\x20LOCAL\x20or\x20METHOD_PARAMETER_IN\x20into\x20the\x20clos\
    ure\x20of\x20a\x20method\n\n\r\n\x05\x05\x07\x02$\x01\x12\x04\xde\x03\
    \x02\x11\n\r\n\x05\x05\x07\x02$\x02\x12\x04\xde\x03\x14\x17\n)\n\x04\x05\
    \x07\x02%\x12\x04\xe1\x03\x02\x11\x1a\x1b\x20Reference\x20to\x20a\x20typ\
    e/class\n\n\r\n\x05\x05\x07\x02%\x01\x12\x04\xe1\x03\x02\n\n\r\n\x05\x05\
    \x07\x02%\x02\x12\x04\xe1\x03\r\x10\n\xc4\x05\n\x04\x05\x07\x02&\x12\x04\
    \xe6\x03\x02\x1a\x1a\x9c\x02\x20In\x20addition\x20to\x20the\x20`CONTROL_\
    STRUCTURE_TYPE`\x20field,\x20the\x20`PARSER_TYPE_NAME`\x20field\x20MAY\
    \x20be\x20used\x20by\x20frontends\x20to\x20store\x20the\x20name\x20of\
    \x20the\x20control\x20structure\x20as\x20emitted\x20by\x20the\x20parser\
    \x20or\x20disassembler,\x20however,\x20the\x20value\x20of\x20this\x20fie\
    ld\x20is\x20not\x20relevant\x20for\x20construction\x20of\x20the\x20contr\
    ol\x20flow\x20layer.\n2\x96\x03\x20This\x20node\x20represents\x20a\x20co\
    ntrol\x20structure\x20as\x20introduced\x20by\x20control\x20structure\x20\
    statements\x20as\x20well\x20as\x20conditional\x20and\x20unconditional\
    \x20jumps.\x20Its\x20type\x20is\x20stored\x20in\x20the\x20`CONTROL_STRUC\
    TURE_TYPE`\x20field\x20to\x20be\x20one\x20of\x20several\x20pre-defined\
    \x20types.\x20These\x20types\x20are\x20used\x20in\x20the\x20construction\
    \x20of\x20the\x20control\x20flow\x20layer,\x20making\x20it\x20possible\
    \x20to\x20generate\x20the\x20control\x20flow\x20layer\x20from\x20the\x20\
    abstract\x20syntax\x20tree\x20layer\x20automatically.\n\n\r\n\x05\x05\
    \x07\x02&\x01\x12\x04\xe6\x03\x02\x13\n\r\n\x05\x05\x07\x02&\x02\x12\x04\
    \xe6\x03\x16\x19\n\xb3\x02\n\x04\x05\x07\x02'\x12\x04\xe9\x03\x02\x14\
    \x1a\xa4\x02\x20A\x20jump\x20target\x20is\x20any\x20location\x20in\x20th\
    e\x20code\x20that\x20has\x20been\x20specifically\x20marked\x20as\x20the\
    \x20target\x20of\x20a\x20jump,\x20e.g.,\x20via\x20a\x20label.\x20The\x20\
    `NAME`\x20field\x20holds\x20the\x20name\x20of\x20the\x20label\x20while\
    \x20the\x20`PARSER_TYPE_NAME`\x20field\x20holds\x20the\x20name\x20of\x20\
    language\x20construct\x20that\x20this\x20jump\x20target\x20is\x20created\
    \x20from,\x20e.g.,\x20\"Label\".\n\n\r\n\x05\x05\x07\x02'\x01\x12\x04\
    \xe9\x03\x02\r\n\r\n\x05\x05\x07\x02'\x02\x12\x04\xe9\x03\x10\x13\n\x9e\
    \x02\n\x04\x05\x07\x02(\x12\x04\xec\x03\x02\x13\x1a\x8f\x02\x20A\x20jump\
    \x20label\x20specifies\x20the\x20label\x20and\x20thus\x20the\x20JUMP_TAR\
    GET\x20of\x20control\x20structures\x20BREAK\x20and\x20CONTINUE.\x20The\
    \x20`NAME`\x20field\x20holds\x20the\x20name\x20of\x20the\x20label\x20whi\
    le\x20the\x20`PARSER_TYPE_NAME`\x20field\x20holds\x20the\x20name\x20of\
    \x20language\x20construct\x20that\x20this\x20jump\x20label\x20is\x20crea\
    ted\x20from,\x20e.g.,\x20\"Label\".\n\n\r\n\x05\x05\x07\x02(\x01\x12\x04\
    \xec\x03\x02\x0c\n\r\n\x05\x05\x07\x02(\x02\x12\x04\xec\x03\x0f\x12\nY\n\
    \x04\x05\x07\x02)\x12\x04\xef\x03\x02\x15\x1aK\x20This\x20node\x20repres\
    ents\x20a\x20DOM\x20node\x20used\x20in\x20template\x20languages,\x20e.g.\
    ,\x20JSX/TSX\n\n\r\n\x05\x05\x07\x02)\x01\x12\x04\xef\x03\x02\x0e\n\r\n\
    \x05\x05\x07\x02)\x02\x12\x04\xef\x03\x11\x14\n%\n\x04\x05\x07\x02*\x12\
    \x04\xf2\x03\x02\x10\x1a\x17\x20A\x20source\x20code\x20comment\n\n\r\n\
    \x05\x05\x07\x02*\x01\x12\x04\xf2\x03\x02\t\n\r\n\x05\x05\x07\x02*\x02\
    \x12\x04\xf2\x03\x0c\x0f\n\x92\x05\n\x04\x05\x07\x02+\x12\x04\xf5\x03\
    \x02\x1d\x1a\x83\x05\x20This\x20node\x20represents\x20the\x20field\x20ac\
    cessed\x20in\x20a\x20field\x20access,\x20e.g.,\x20in\x20`a.b`,\x20it\x20\
    represents\x20`b`.\x20The\x20field\x20name\x20as\x20it\x20occurs\x20in\
    \x20the\x20code\x20is\x20stored\x20in\x20the\x20`CODE`\x20field.\x20This\
    \x20may\x20mean\x20that\x20the\x20`CODE`\x20field\x20holds\x20an\x20expr\
    ession.\x20The\x20`CANONICAL_NAME`\x20field\x20MAY\x20contain\x20the\x20\
    same\x20value\x20is\x20the\x20`CODE`\x20field\x20but\x20SHOULD\x20contai\
    n\x20the\x20normalized\x20name\x20that\x20results\x20from\x20evaluating\
    \x20`CODE`\x20as\x20an\x20expression\x20if\x20such\x20an\x20evaluation\
    \x20is\x20possible\x20for\x20the\x20language\x20frontend.\x20The\x20obje\
    ctive\x20is\x20to\x20store\x20an\x20identifier\x20in\x20`CANONICAL_NAME`\
    \x20that\x20is\x20the\x20same\x20for\x20two\x20nodes\x20iff\x20they\x20r\
    efer\x20to\x20the\x20same\x20field,\x20regardless\x20of\x20whether\x20th\
    ey\x20use\x20the\x20same\x20expression\x20to\x20reference\x20it.\n\n\r\n\
    \x05\x05\x07\x02+\x01\x12\x04\xf5\x03\x02\x12\n\r\n\x05\x05\x07\x02+\x02\
    \x12\x04\xf5\x03\x15\x1c\nQ\n\x02\x04\0\x12\x06\xfb\x03\0\x8b\x04\x01\
    \x1aC\x20Message\x20to\x20store\x20the\x20property\x20values\x20such\x20\
    as\x20string\x20or\x20int\x20values\n\n\x0b\n\x03\x04\0\x01\x12\x04\xfb\
    \x03\x08\x15\n\x0e\n\x04\x04\0\x08\0\x12\x06\xfc\x03\x02\x8a\x04\x03\n\r\
    \n\x05\x04\0\x08\0\x01\x12\x04\xfc\x03\x08\r\n\x0c\n\x04\x04\0\x02\0\x12\
    \x04\xfd\x03\x04\x1c\n\r\n\x05\x04\0\x02\0\x05\x12\x04\xfd\x03\x04\n\n\r\
    \n\x05\x04\0\x02\0\x01\x12\x04\xfd\x03\x0b\x17\n\r\n\x05\x04\0\x02\0\x03\
    \x12\x04\xfd\x03\x1a\x1b\n\x0c\n\x04\x04\0\x02\x01\x12\x04\xfe\x03\x04\
    \x18\n\r\n\x05\x04\0\x02\x01\x05\x12\x04\xfe\x03\x04\x08\n\r\n\x05\x04\0\
    \x02\x01\x01\x12\x04\xfe\x03\t\x13\n\r\n\x05\x04\0\x02\x01\x03\x12\x04\
    \xfe\x03\x16\x17\n\x0c\n\x04\x04\0\x02\x02\x12\x04\xff\x03\x04\x18\n\r\n\
    \x05\x04\0\x02\x02\x05\x12\x04\xff\x03\x04\t\n\r\n\x05\x04\0\x02\x02\x01\
    \x12\x04\xff\x03\n\x13\n\r\n\x05\x04\0\x02\x02\x03\x12\x04\xff\x03\x16\
    \x17\n\x0c\n\x04\x04\0\x02\x03\x12\x04\x80\x04\x04\x19\n\r\n\x05\x04\0\
    \x02\x03\x05\x12\x04\x80\x04\x04\t\n\r\n\x05\x04\0\x02\x03\x01\x12\x04\
    \x80\x04\n\x14\n\r\n\x05\x04\0\x02\x03\x03\x12\x04\x80\x04\x17\x18\n\x0c\
    \n\x04\x04\0\x02\x04\x12\x04\x81\x04\x04\x1a\n\r\n\x05\x04\0\x02\x04\x05\
    \x12\x04\x81\x04\x04\t\n\r\n\x05\x04\0\x02\x04\x01\x12\x04\x81\x04\n\x15\
    \n\r\n\x05\x04\0\x02\x04\x03\x12\x04\x81\x04\x18\x19\n\x0c\n\x04\x04\0\
    \x02\x05\x12\x04\x82\x04\x04\x1c\n\r\n\x05\x04\0\x02\x05\x05\x12\x04\x82\
    \x04\x04\n\n\r\n\x05\x04\0\x02\x05\x01\x12\x04\x82\x04\x0b\x17\n\r\n\x05\
    \x04\0\x02\x05\x03\x12\x04\x82\x04\x1a\x1b\n\x0c\n\x04\x04\0\x02\x06\x12\
    \x04\x83\x04\x04\x1f\n\r\n\x05\x04\0\x02\x06\x06\x12\x04\x83\x04\x04\x0e\
    \n\r\n\x05\x04\0\x02\x06\x01\x12\x04\x83\x04\x0f\x1a\n\r\n\x05\x04\0\x02\
    \x06\x03\x12\x04\x83\x04\x1d\x1e\n\x0c\n\x04\x04\0\x02\x07\x12\x04\x84\
    \x04\x04\x1b\n\r\n\x05\x04\0\x02\x07\x06\x12\x04\x84\x04\x04\x0c\n\r\n\
    \x05\x04\0\x02\x07\x01\x12\x04\x84\x04\r\x16\n\r\n\x05\x04\0\x02\x07\x03\
    \x12\x04\x84\x04\x19\x1a\n\x0c\n\x04\x04\0\x02\x08\x12\x04\x85\x04\x04\
    \x19\n\r\n\x05\x04\0\x02\x08\x06\x12\x04\x85\x04\x04\x0b\n\r\n\x05\x04\0\
    \x02\x08\x01\x12\x04\x85\x04\x0c\x14\n\r\n\x05\x04\0\x02\x08\x03\x12\x04\
    \x85\x04\x17\x18\n\x0c\n\x04\x04\0\x02\t\x12\x04\x86\x04\x04\x1c\n\r\n\
    \x05\x04\0\x02\t\x06\x12\x04\x86\x04\x04\x0c\n\r\n\x05\x04\0\x02\t\x01\
    \x12\x04\x86\x04\r\x16\n\r\n\x05\x04\0\x02\t\x03\x12\x04\x86\x04\x19\x1b\
    \n\x0c\n\x04\x04\0\x02\n\x12\x04\x87\x04\x04\x1e\n\r\n\x05\x04\0\x02\n\
    \x06\x12\x04\x87\x04\x04\r\n\r\n\x05\x04\0\x02\n\x01\x12\x04\x87\x04\x0e\
    \x18\n\r\n\x05\x04\0\x02\n\x03\x12\x04\x87\x04\x1b\x1d\n\x0c\n\x04\x04\0\
    \x02\x0b\x12\x04\x88\x04\x04\x20\n\r\n\x05\x04\0\x02\x0b\x06\x12\x04\x88\
    \x04\x04\x0e\n\r\n\x05\x04\0\x02\x0b\x01\x12\x04\x88\x04\x0f\x1a\n\r\n\
    \x05\x04\0\x02\x0b\x03\x12\x04\x88\x04\x1d\x1f\n\x0c\n\x04\x04\0\x02\x0c\
    \x12\x04\x89\x04\x04&\n\r\n\x05\x04\0\x02\x0c\x06\x12\x04\x89\x04\x04\
    \x11\n\r\n\x05\x04\0\x02\x0c\x01\x12\x04\x89\x04\x12\x20\n\r\n\x05\x04\0\
    \x02\x0c\x03\x12\x04\x89\x04#%\n\x0c\n\x02\x04\x01\x12\x06\x8d\x04\0\x90\
    \x04\x01\n\x0b\n\x03\x04\x01\x01\x12\x04\x8d\x04\x08\x15\n\x0c\n\x04\x04\
    \x01\x02\0\x12\x04\x8e\x04\x02\x18\n\r\n\x05\x04\x01\x02\0\x05\x12\x04\
    \x8e\x04\x02\x08\n\r\n\x05\x04\x01\x02\0\x01\x12\x04\x8e\x04\t\x13\n\r\n\
    \x05\x04\x01\x02\0\x03\x12\x04\x8e\x04\x16\x17\n\x0c\n\x04\x04\x01\x02\
    \x01\x12\x04\x8f\x04\x02\x1a\n\r\n\x05\x04\x01\x02\x01\x04\x12\x04\x8f\
    \x04\x02\n\n\r\n\x05\x04\x01\x02\x01\x05\x12\x04\x8f\x04\x0b\x10\n\r\n\
    \x05\x04\x01\x02\x01\x01\x12\x04\x8f\x04\x11\x15\n\r\n\x05\x04\x01\x02\
    \x01\x03\x12\x04\x8f\x04\x18\x19\n\x0c\n\x02\x04\x02\x12\x06\x92\x04\0\
    \x94\x04\x01\n\x0b\n\x03\x04\x02\x01\x12\x04\x92\x04\x08\x12\n\x0c\n\x04\
    \x04\x02\x02\0\x12\x04\x93\x04\x02\x1d\n\r\n\x05\x04\x02\x02\0\x04\x12\
    \x04\x93\x04\x02\n\n\r\n\x05\x04\x02\x02\0\x05\x12\x04\x93\x04\x0b\x11\n\
    \r\n\x05\x04\x02\x02\0\x01\x12\x04\x93\x04\x12\x18\n\r\n\x05\x04\x02\x02\
    \0\x03\x12\x04\x93\x04\x1b\x1c\n\x0c\n\x02\x04\x03\x12\x06\x96\x04\0\x98\
    \x04\x01\n\x0b\n\x03\x04\x03\x01\x12\x04\x96\x04\x08\x10\n\x0c\n\x04\x04\
    \x03\x02\0\x12\x04\x97\x04\x02\x1b\n\r\n\x05\x04\x03\x02\0\x04\x12\x04\
    \x97\x04\x02\n\n\r\n\x05\x04\x03\x02\0\x05\x12\x04\x97\x04\x0b\x0f\n\r\n\
    \x05\x04\x03\x02\0\x01\x12\x04\x97\x04\x10\x16\n\r\n\x05\x04\x03\x02\0\
    \x03\x12\x04\x97\x04\x19\x1a\n\x0c\n\x02\x04\x04\x12\x06\x9a\x04\0\x9c\
    \x04\x01\n\x0b\n\x03\x04\x04\x01\x12\x04\x9a\x04\x08\x0f\n\x0c\n\x04\x04\
    \x04\x02\0\x12\x04\x9b\x04\x02\x1c\n\r\n\x05\x04\x04\x02\0\x04\x12\x04\
    \x9b\x04\x02\n\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\x9b\x04\x0b\x10\n\r\n\
    \x05\x04\x04\x02\0\x01\x12\x04\x9b\x04\x11\x17\n\r\n\x05\x04\x04\x02\0\
    \x03\x12\x04\x9b\x04\x1a\x1b\n\x0c\n\x02\x04\x05\x12\x06\x9e\x04\0\xa0\
    \x04\x01\n\x0b\n\x03\x04\x05\x01\x12\x04\x9e\x04\x08\x10\n\x0c\n\x04\x04\
    \x05\x02\0\x12\x04\x9f\x04\x02\x1c\n\r\n\x05\x04\x05\x02\0\x04\x12\x04\
    \x9f\x04\x02\n\n\r\n\x05\x04\x05\x02\0\x05\x12\x04\x9f\x04\x0b\x10\n\r\n\
    \x05\x04\x05\x02\0\x01\x12\x04\x9f\x04\x11\x17\n\r\n\x05\x04\x05\x02\0\
    \x03\x12\x04\x9f\x04\x1a\x1b\n\x0c\n\x02\x04\x06\x12\x06\xa2\x04\0\xa4\
    \x04\x01\n\x0b\n\x03\x04\x06\x01\x12\x04\xa2\x04\x08\x11\n\x0c\n\x04\x04\
    \x06\x02\0\x12\x04\xa3\x04\x02\x1c\n\r\n\x05\x04\x06\x02\0\x04\x12\x04\
    \xa3\x04\x02\n\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\xa3\x04\x0b\x10\n\r\n\
    \x05\x04\x06\x02\0\x01\x12\x04\xa3\x04\x11\x17\n\r\n\x05\x04\x06\x02\0\
    \x03\x12\x04\xa3\x04\x1a\x1b\n\x0c\n\x02\x04\x07\x12\x06\xa6\x04\0\xa8\
    \x04\x01\n\x0b\n\x03\x04\x07\x01\x12\x04\xa6\x04\x08\x12\n\x0c\n\x04\x04\
    \x07\x02\0\x12\x04\xa7\x04\x02\x1d\n\r\n\x05\x04\x07\x02\0\x04\x12\x04\
    \xa7\x04\x02\n\n\r\n\x05\x04\x07\x02\0\x05\x12\x04\xa7\x04\x0b\x11\n\r\n\
    \x05\x04\x07\x02\0\x01\x12\x04\xa7\x04\x12\x18\n\r\n\x05\x04\x07\x02\0\
    \x03\x12\x04\xa7\x04\x1b\x1c\n\xdf\x06\n\x02\x04\x08\x12\x06\xc4\x04\0\
    \xb0\x05\x01\x1a\xd0\x06*\n\x20This\x20is\x20the\x20CORE\x20structure\
    \x20that\x20represents\x20a\x20Code\x20Property\x20Graph\x20for\x20the\
    \x20given\x20language\n\x20This\x20structure\x20must\x20be\x20serialized\
    \x20as\x20bytes\x20and\x20stored\x20in\x20a\x20zip\x20file\x20(such\x20a\
    s\x20app.atom)\x20with\x20the\x20name\x20\"cpg.proto\"\n\n\x20Example\
    \x20code\x20snippet\x20in\x20Python\n\x20```python\n\x20atom_struct\x20=\
    \x20atom.CpgStruct(node=[method])\n\x20with\x20ZipFile(file_name,\x20\"w\
    \")\x20as\x20zip_file:\n\x20\x20\x20\x20\x20zip_file.writestr(\"cpg.prot\
    o\",\x20bytes(atom_struct))\n\x20```\n\n\x20Example\x20code\x20snippet\
    \x20in\x20TypeScript\n\x20```typescript\n\x20const\x20methodFullName\x20\
    =\x20new\x20atom.CpgStruct.Node.Property({\n\x20\x20name:\x20atom.NodePr\
    opertyName.FULL_NAME,\n\x20\x20value:\x20new\x20atom.PropertyValue({\x20\
    string_value:\x20\"main\"\x20}),\n\x20});\n\x20const\x20method\x20=\x20n\
    ew\x20atom.CpgStruct.Node({\n\x20\x20\x20key:\x201,\n\x20\x20\x20type:\
    \x20atom.NodeType.METHOD,\n\x20\x20\x20property:\x20[methodFullName],\n\
    \x20});\n\x20const\x20atomStruct\x20=\x20new\x20atom.CpgStruct({\x20node\
    :\x20[method]\x20});\n\x20const\x20serializedBytes\x20=\x20atomStruct.se\
    rialize();\n\x20```\n\n\x0b\n\x03\x04\x08\x01\x12\x04\xc4\x04\x08\x11\n\
    \x0e\n\x04\x04\x08\x03\0\x12\x06\xc5\x04\x02\xcf\x04\x03\n\r\n\x05\x04\
    \x08\x03\0\x01\x12\x04\xc5\x04\n\x0e\n\x0e\n\x06\x04\x08\x03\0\x02\0\x12\
    \x04\xc6\x04\x04\x12\n\x0f\n\x07\x04\x08\x03\0\x02\0\x05\x12\x04\xc6\x04\
    \x04\t\n\x0f\n\x07\x04\x08\x03\0\x02\0\x01\x12\x04\xc6\x04\n\r\n\x0f\n\
    \x07\x04\x08\x03\0\x02\0\x03\x12\x04\xc6\x04\x10\x11\n\x0e\n\x06\x04\x08\
    \x03\0\x02\x01\x12\x04\xc7\x04\x04\x16\n\x0f\n\x07\x04\x08\x03\0\x02\x01\
    \x06\x12\x04\xc7\x04\x04\x0c\n\x0f\n\x07\x04\x08\x03\0\x02\x01\x01\x12\
    \x04\xc7\x04\r\x11\n\x0f\n\x07\x04\x08\x03\0\x02\x01\x03\x12\x04\xc7\x04\
    \x14\x15\n$\n\x06\x04\x08\x03\0\x03\0\x12\x06\xca\x04\x04\xcd\x04\x05\
    \x1a\x12\x20Node\x20properties.\n\n\x0f\n\x07\x04\x08\x03\0\x03\0\x01\
    \x12\x04\xca\x04\x0c\x14\n\x10\n\x08\x04\x08\x03\0\x03\0\x02\0\x12\x04\
    \xcb\x04\x06\x20\n\x11\n\t\x04\x08\x03\0\x03\0\x02\0\x06\x12\x04\xcb\x04\
    \x06\x16\n\x11\n\t\x04\x08\x03\0\x03\0\x02\0\x01\x12\x04\xcb\x04\x17\x1b\
    \n\x11\n\t\x04\x08\x03\0\x03\0\x02\0\x03\x12\x04\xcb\x04\x1e\x1f\n\x10\n\
    \x08\x04\x08\x03\0\x03\0\x02\x01\x12\x04\xcc\x04\x06\x1e\n\x11\n\t\x04\
    \x08\x03\0\x03\0\x02\x01\x06\x12\x04\xcc\x04\x06\x13\n\x11\n\t\x04\x08\
    \x03\0\x03\0\x02\x01\x01\x12\x04\xcc\x04\x14\x19\n\x11\n\t\x04\x08\x03\0\
    \x03\0\x02\x01\x03\x12\x04\xcc\x04\x1c\x1d\n\x0e\n\x06\x04\x08\x03\0\x02\
    \x02\x12\x04\xce\x04\x02!\n\x0f\n\x07\x04\x08\x03\0\x02\x02\x04\x12\x04\
    \xce\x04\x02\n\n\x0f\n\x07\x04\x08\x03\0\x02\x02\x06\x12\x04\xce\x04\x0b\
    \x13\n\x0f\n\x07\x04\x08\x03\0\x02\x02\x01\x12\x04\xce\x04\x14\x1c\n\x0f\
    \n\x07\x04\x08\x03\0\x02\x02\x03\x12\x04\xce\x04\x1f\x20\n\x0c\n\x04\x04\
    \x08\x02\0\x12\x04\xd0\x04\x02\x19\n\r\n\x05\x04\x08\x02\0\x04\x12\x04\
    \xd0\x04\x02\n\n\r\n\x05\x04\x08\x02\0\x06\x12\x04\xd0\x04\x0b\x0f\n\r\n\
    \x05\x04\x08\x02\0\x01\x12\x04\xd0\x04\x10\x14\n\r\n\x05\x04\x08\x02\0\
    \x03\x12\x04\xd0\x04\x17\x18\n7\n\x04\x04\x08\x03\x01\x12\x06\xd3\x04\
    \x02\xae\x05\x03\x1a'\x20Represents\x20a\x20directed\x20edge\x20of\x20a\
    \x20graph\n\n\r\n\x05\x04\x08\x03\x01\x01\x12\x04\xd3\x04\n\x0e\n\r\n\
    \x05\x04\x08\x03\x01\t\x12\x04\xd4\x04\x04\x0f\n\x0e\n\x06\x04\x08\x03\
    \x01\t\0\x12\x04\xd4\x04\r\x0e\n\x0f\n\x07\x04\x08\x03\x01\t\0\x01\x12\
    \x04\xd4\x04\r\x0e\n\x0f\n\x07\x04\x08\x03\x01\t\0\x02\x12\x04\xd4\x04\r\
    \x0e\n\r\n\x05\x04\x08\x03\x01\n\x12\x04\xd5\x04\x04\x13\n\x0e\n\x06\x04\
    \x08\x03\x01\n\0\x12\x04\xd5\x04\r\x12\n\x1e\n\x06\x04\x08\x03\x01\x02\0\
    \x12\x04\xd7\x04\x04\x12\x1a\x0e\x20Source\x20node.\n\n\x0f\n\x07\x04\
    \x08\x03\x01\x02\0\x05\x12\x04\xd7\x04\x04\t\n\x0f\n\x07\x04\x08\x03\x01\
    \x02\0\x01\x12\x04\xd7\x04\n\r\n\x0f\n\x07\x04\x08\x03\x01\x02\0\x03\x12\
    \x04\xd7\x04\x10\x11\n#\n\x06\x04\x08\x03\x01\x02\x01\x12\x04\xd9\x04\
    \x04\x12\x1a\x13\x20Destination\x20node.\n\n\x0f\n\x07\x04\x08\x03\x01\
    \x02\x01\x05\x12\x04\xd9\x04\x04\t\n\x0f\n\x07\x04\x08\x03\x01\x02\x01\
    \x01\x12\x04\xd9\x04\n\r\n\x0f\n\x07\x04\x08\x03\x01\x02\x01\x03\x12\x04\
    \xd9\x04\x10\x11\n\x1e\n\x06\x04\x08\x03\x01\x04\0\x12\x06\xdb\x04\x04\
    \xa5\x05\x05\x1a\x0c\x20Edge\x20type.\n\n\x0f\n\x07\x04\x08\x03\x01\x04\
    \0\x01\x12\x04\xdb\x04\t\x11\n\x10\n\x08\x04\x08\x03\x01\x04\0\x02\0\x12\
    \x04\xdc\x04\x06\x1c\n\x11\n\t\x04\x08\x03\x01\x04\0\x02\0\x01\x12\x04\
    \xdc\x04\x06\x17\n\x11\n\t\x04\x08\x03\x01\x04\0\x02\0\x02\x12\x04\xdc\
    \x04\x1a\x1b\nU\n\x08\x04\x08\x03\x01\x04\0\x02\x01\x12\x04\xde\x04\x06\
    \x0e\x1aC\x20This\x20edge\x20connects\x20a\x20parent\x20node\x20to\x20it\
    s\x20child\x20in\x20the\x20syntax\x20tree.\n\n\x11\n\t\x04\x08\x03\x01\
    \x04\0\x02\x01\x01\x12\x04\xde\x04\x06\t\n\x11\n\t\x04\x08\x03\x01\x04\0\
    \x02\x01\x02\x12\x04\xde\x04\x0c\r\n\xe3\x02\n\x08\x04\x08\x03\x01\x04\0\
    \x02\x02\x12\x04\xe1\x04\x06\x0f\x1a\xd0\x02\x20This\x20edge\x20connects\
    \x20call\x20sites,\x20i.e.,\x20nodes\x20with\x20the\x20type\x20`CALL`,\
    \x20to\x20the\x20method\x20node\x20that\x20represent\x20the\x20method\
    \x20they\x20invoke.\x20The\x20frontend\x20MAY\x20create\x20`CALL`\x20edg\
    es\x20but\x20is\x20not\x20required\x20to\x20do\x20so.\x20Instead,\x20of\
    \x20the\x20`METHOD_FULL_NAME`\x20field\x20of\x20the\x20`CALL`\x20node\
    \x20is\x20set\x20correctly,\x20`CALL`\x20edges\x20are\x20created\x20auto\
    matically\x20as\x20the\x20CPG\x20is\x20first\x20loaded.\n\n\x11\n\t\x04\
    \x08\x03\x01\x04\0\x02\x02\x01\x12\x04\xe1\x04\x06\n\n\x11\n\t\x04\x08\
    \x03\x01\x04\0\x02\x02\x02\x12\x04\xe1\x04\r\x0e\n\xb6\x01\n\x08\x04\x08\
    \x03\x01\x04\0\x02\x03\x12\x04\xe4\x04\x06\x0f\x1a\xa3\x01\x20This\x20ed\
    ge\x20indicates\x20that\x20the\x20source\x20node\x20is\x20an\x20identifi\
    er\x20that\x20denotes\x20access\x20to\x20the\x20destination\x20node.\x20\
    For\x20example,\x20an\x20identifier\x20may\x20reference\x20a\x20local\
    \x20variable.\n\n\x11\n\t\x04\x08\x03\x01\x04\0\x02\x03\x01\x12\x04\xe4\
    \x04\x06\t\n\x11\n\t\x04\x08\x03\x01\x04\0\x02\x03\x02\x12\x04\xe4\x04\
    \x0c\x0e\nD\n\x08\x04\x08\x03\x01\x04\0\x02\x04\x12\x04\xe7\x04\x06\x15\
    \x1a2\x20Edges\x20from\x20nodes\x20to\x20the\x20tags\x20they\x20are\x20t\
    agged\x20by.\n\n\x11\n\t\x04\x08\x03\x01\x04\0\x02\x04\x01\x12\x04\xe7\
    \x04\x06\x0f\n\x11\n\t\x04\x08\x03\x01\x04\0\x02\x04\x02\x12\x04\xe7\x04\
    \x12\x14\nm\n\x08\x04\x08\x03\x01\x04\0\x02\x05\x12\x04\xea\x04\x06\x1a\
    \x1a[\x20This\x20edge\x20connects\x20a\x20method\x20input\x20parameter\
    \x20to\x20the\x20corresponding\x20method\x20output\x20parameter.\n\n\x11\
    \n\t\x04\x08\x03\x01\x04\0\x02\x05\x01\x12\x04\xea\x04\x06\x14\n\x11\n\t\
    \x04\x08\x03\x01\x04\0\x02\x05\x02\x12\x04\xea\x04\x17\x19\n]\n\x08\x04\
    \x08\x03\x01\x04\0\x02\x06\x12\x04\xed\x04\x06\x0f\x1aK\x20This\x20edge\
    \x20indicates\x20control\x20flow\x20from\x20the\x20source\x20to\x20the\
    \x20destination\x20node.\n\n\x11\n\t\x04\x08\x03\x01\x04\0\x02\x06\x01\
    \x12\x04\xed\x04\x06\t\n\x11\n\t\x04\x08\x03\x01\x04\0\x02\x06\x02\x12\
    \x04\xed\x04\x0c\x0e\nE\n\x08\x04\x08\x03\x01\x04\0\x02\x07\x12\x04\xf0\
    \x04\x06\x15\x1a3\x20This\x20edge\x20connects\x20a\x20node\x20to\x20its\
    \x20evaluation\x20type.\n\n\x11\n\t\x04\x08\x03\x01\x04\0\x02\x07\x01\
    \x12\x04\xf0\x04\x06\x0f\n\x11\n\t\x04\x08\x03\x01\x04\0\x02\x07\x02\x12\
    \x04\xf0\x04\x12\x14\n\x97\x01\n\x08\x04\x08\x03\x01\x04\0\x02\x08\x12\
    \x04\xf3\x04\x06\x14\x1a\x84\x01\x20This\x20edge\x20connects\x20type\x20\
    arguments\x20to\x20type\x20parameters\x20to\x20indicate\x20that\x20the\
    \x20type\x20argument\x20is\x20used\x20to\x20instantiate\x20the\x20type\
    \x20parameter.\n\n\x11\n\t\x04\x08\x03\x01\x04\0\x02\x08\x01\x12\x04\xf3\
    \x04\x06\x0e\n\x11\n\t\x04\x08\x03\x01\x04\0\x02\x08\x02\x12\x04\xf3\x04\
    \x11\x13\n\xef\x01\n\x08\x04\x08\x03\x01\x04\0\x02\t\x12\x04\xf6\x04\x06\
    \x19\x1a\xdc\x01\x20Inheritance\x20relation\x20between\x20a\x20type\x20d\
    eclaration\x20and\x20a\x20type.\x20This\x20edge\x20MUST\x20NOT\x20be\x20\
    created\x20by\x20the\x20language\x20frontend\x20as\x20it\x20is\x20automa\
    tically\x20created\x20from\x20`INHERITS_FROM_TYPE_FULL_NAME`\x20fields\
    \x20then\x20the\x20CPG\x20is\x20first\x20loaded.\n\n\x11\n\t\x04\x08\x03\
    \x01\x04\0\x02\t\x01\x12\x04\xf6\x04\x06\x13\n\x11\n\t\x04\x08\x03\x01\
    \x04\0\x02\t\x02\x12\x04\xf6\x04\x16\x18\nM\n\x08\x04\x08\x03\x01\x04\0\
    \x02\n\x12\x04\xf9\x04\x06\x14\x1a;\x20This\x20edge\x20connects\x20a\x20\
    node\x20to\x20the\x20method\x20that\x20contains\x20it.\n\n\x11\n\t\x04\
    \x08\x03\x01\x04\0\x02\n\x01\x12\x04\xf9\x04\x06\x0e\n\x11\n\t\x04\x08\
    \x03\x01\x04\0\x02\n\x02\x12\x04\xf9\x04\x11\x13\nI\n\x08\x04\x08\x03\
    \x01\x04\0\x02\x0b\x12\x04\xfc\x04\x06\x13\x1a7\x20Represents\x20the\x20\
    capturing\x20of\x20a\x20variable\x20into\x20a\x20closure\n\n\x11\n\t\x04\
    \x08\x03\x01\x04\0\x02\x0b\x01\x12\x04\xfc\x04\x06\r\n\x11\n\t\x04\x08\
    \x03\x01\x04\0\x02\x0b\x02\x12\x04\xfc\x04\x10\x12\n]\n\x08\x04\x08\x03\
    \x01\x04\0\x02\x0c\x12\x04\xff\x04\x06\x17\x1aK\x20Connection\x20between\
    \x20a\x20captured\x20LOCAL\x20and\x20the\x20corresponding\x20CLOSURE_BIN\
    DING\n\n\x11\n\t\x04\x08\x03\x01\x04\0\x02\x0c\x01\x12\x04\xff\x04\x06\
    \x11\n\x11\n\t\x04\x08\x03\x01\x04\0\x02\x0c\x02\x12\x04\xff\x04\x14\x16\
    \n\x9e\x02\n\x08\x04\x08\x03\x01\x04\0\x02\r\x12\x04\x82\x05\x06\x14\x1a\
    \x8b\x02\x20Similar\x20to\x20`ARGUMENT`\x20edges,\x20`RECEIVER`\x20edges\
    \x20connect\x20call\x20sites\x20to\x20their\x20receiver\x20arguments.\
    \x20A\x20receiver\x20argument\x20is\x20the\x20object\x20on\x20which\x20a\
    \x20method\x20operates,\x20that\x20is,\x20it\x20is\x20the\x20expression\
    \x20that\x20is\x20assigned\x20to\x20the\x20`this`\x20pointer\x20as\x20co\
    ntrol\x20is\x20transferred\x20to\x20the\x20method.\n\n\x11\n\t\x04\x08\
    \x03\x01\x04\0\x02\r\x01\x12\x04\x82\x05\x06\x0e\n\x11\n\t\x04\x08\x03\
    \x01\x04\0\x02\r\x02\x12\x04\x82\x05\x11\x13\nm\n\x08\x04\x08\x03\x01\
    \x04\0\x02\x0e\x12\x04\x85\x05\x06\x15\x1a[\x20The\x20edge\x20connects\
    \x20control\x20structure\x20nodes\x20to\x20the\x20expressions\x20that\
    \x20holds\x20their\x20conditions.\n\n\x11\n\t\x04\x08\x03\x01\x04\0\x02\
    \x0e\x01\x12\x04\x85\x05\x06\x0f\n\x11\n\t\x04\x08\x03\x01\x04\0\x02\x0e\
    \x02\x12\x04\x85\x05\x12\x14\n\xe7\x01\n\x08\x04\x08\x03\x01\x04\0\x02\
    \x0f\x12\x04\x88\x05\x06\x19\x1a\xd4\x01\x20A\x20reaching\x20definition\
    \x20edge\x20indicates\x20that\x20a\x20variable\x20produced\x20at\x20the\
    \x20source\x20node\x20reaches\x20the\x20destination\x20node\x20without\
    \x20being\x20reassigned\x20on\x20the\x20way.\x20The\x20`VARIABLE`\x20pro\
    perty\x20indicates\x20which\x20variable\x20is\x20propagated.\n\n\x11\n\t\
    \x04\x08\x03\x01\x04\0\x02\x0f\x01\x12\x04\x88\x05\x06\x12\n\x11\n\t\x04\
    \x08\x03\x01\x04\0\x02\x0f\x02\x12\x04\x88\x05\x15\x18\n\x80\x02\n\x08\
    \x04\x08\x03\x01\x04\0\x02\x10\x12\x04\x8b\x05\x06\x15\x1a\xed\x01\x20Th\
    is\x20edge\x20represents\x20an\x20alias\x20relation\x20between\x20a\x20t\
    ype\x20declaration\x20and\x20a\x20type.\x20The\x20language\x20frontend\
    \x20MUST\x20NOT\x20create\x20`ALIAS_OF`\x20edges\x20as\x20they\x20are\
    \x20created\x20automatically\x20based\x20on\x20`ALIAS_TYPE_FULL_NAME`\
    \x20fields\x20when\x20the\x20CPG\x20is\x20first\x20loaded.\n\n\x11\n\t\
    \x04\x08\x03\x01\x04\0\x02\x10\x01\x12\x04\x8b\x05\x06\x0e\n\x11\n\t\x04\
    \x08\x03\x01\x04\0\x02\x10\x02\x12\x04\x8b\x05\x11\x14\n\xc0\x02\n\x08\
    \x04\x08\x03\x01\x04\0\x02\x11\x12\x04\x8e\x05\x06\x12\x1a\xad\x02\x20Th\
    is\x20edge\x20connects\x20a\x20type\x20declaration\x20(`TYPE_DECL`)\x20w\
    ith\x20a\x20binding\x20node\x20(`BINDING`)\x20and\x20indicates\x20that\
    \x20the\x20type\x20declaration\x20has\x20the\x20binding\x20represented\
    \x20by\x20the\x20binding\x20node,\x20in\x20other\x20words,\x20there\x20i\
    s\x20a\x20(name,\x20signature)\x20pair\x20that\x20can\x20be\x20resolved\
    \x20for\x20the\x20type\x20declaration\x20as\x20stored\x20in\x20the\x20bi\
    nding\x20node.\n\n\x11\n\t\x04\x08\x03\x01\x04\0\x02\x11\x01\x12\x04\x8e\
    \x05\x06\x0b\n\x11\n\t\x04\x08\x03\x01\x04\0\x02\x11\x02\x12\x04\x8e\x05\
    \x0e\x11\n\xaf\x01\n\x08\x04\x08\x03\x01\x04\0\x02\x12\x12\x04\x91\x05\
    \x06\x15\x1a\x9c\x01\x20Argument\x20edges\x20connect\x20call\x20sites\
    \x20(node\x20type\x20`CALL`)\x20to\x20their\x20arguments\x20(node\x20typ\
    e\x20`EXPRESSION`)\x20as\x20well\x20as\x20`RETURN`\x20nodes\x20to\x20the\
    \x20expressions\x20that\x20return.\n\n\x11\n\t\x04\x08\x03\x01\x04\0\x02\
    \x12\x01\x12\x04\x91\x05\x06\x0e\n\x11\n\t\x04\x08\x03\x01\x04\0\x02\x12\
    \x02\x12\x04\x91\x05\x11\x14\n\xce\x01\n\x08\x04\x08\x03\x01\x04\0\x02\
    \x13\x12\x04\x94\x05\x06\x18\x1a\xbb\x01\x20This\x20edge\x20connects\x20\
    a\x20node\x20to\x20the\x20node\x20that\x20represents\x20its\x20source\
    \x20file.\x20These\x20edges\x20MUST\x20not\x20be\x20created\x20by\x20the\
    \x20language\x20frontend\x20but\x20are\x20automatically\x20created\x20ba\
    sed\x20on\x20`FILENAME`\x20fields.\n\n\x11\n\t\x04\x08\x03\x01\x04\0\x02\
    \x13\x01\x12\x04\x94\x05\x06\x11\n\x11\n\t\x04\x08\x03\x01\x04\0\x02\x13\
    \x02\x12\x04\x94\x05\x14\x17\nh\n\x08\x04\x08\x03\x01\x04\0\x02\x14\x12\
    \x04\x97\x05\x06\x15\x1aV\x20This\x20edge\x20indicates\x20that\x20the\
    \x20source\x20node\x20immediately\x20dominates\x20the\x20destination\x20\
    node.\n\n\x11\n\t\x04\x08\x03\x01\x04\0\x02\x14\x01\x12\x04\x97\x05\x06\
    \x0e\n\x11\n\t\x04\x08\x03\x01\x04\0\x02\x14\x02\x12\x04\x97\x05\x11\x14\
    \nm\n\x08\x04\x08\x03\x01\x04\0\x02\x15\x12\x04\x9a\x05\x06\x1a\x1a[\x20\
    This\x20edge\x20indicates\x20that\x20the\x20source\x20node\x20immediatel\
    y\x20post\x20dominates\x20the\x20destination\x20node.\n\n\x11\n\t\x04\
    \x08\x03\x01\x04\0\x02\x15\x01\x12\x04\x9a\x05\x06\x13\n\x11\n\t\x04\x08\
    \x03\x01\x04\0\x02\x15\x02\x12\x04\x9a\x05\x16\x19\nk\n\x08\x04\x08\x03\
    \x01\x04\0\x02\x16\x12\x04\x9d\x05\x06\x10\x1aY\x20A\x20CDG\x20edge\x20e\
    xpresses\x20that\x20the\x20destination\x20node\x20is\x20control\x20depen\
    dent\x20on\x20the\x20source\x20node.\n\n\x11\n\t\x04\x08\x03\x01\x04\0\
    \x02\x16\x01\x12\x04\x9d\x05\x06\t\n\x11\n\t\x04\x08\x03\x01\x04\0\x02\
    \x16\x02\x12\x04\x9d\x05\x0c\x0f\n5\n\x08\x04\x08\x03\x01\x04\0\x02\x17\
    \x12\x04\xa0\x05\x06\x16\x1a#\x20Edge\x20from\x20imports\x20to\x20depend\
    encies\n\n\x11\n\t\x04\x08\x03\x01\x04\0\x02\x17\x01\x12\x04\xa0\x05\x06\
    \r\n\x11\n\t\x04\x08\x03\x01\x04\0\x02\x17\x02\x12\x04\xa0\x05\x10\x15\n\
    \xc4\x01\n\x08\x04\x08\x03\x01\x04\0\x02\x18\x12\x04\xa3\x05\x06!\x1a\
    \xb1\x01\x20Edge\x20from\x20CALL\x20statement\x20in\x20the\x20AST\x20to\
    \x20the\x20IMPORT.\x20We\x20use\x20this\x20edge\x20to\x20traverse\x20fro\
    m\x20the\x20logical\x20representation\x20of\x20the\x20IMPORT\x20to\x20th\
    e\x20corresponding\x20import\x20statement\x20in\x20the\x20AST.\n\n\x11\n\
    \t\x04\x08\x03\x01\x04\0\x02\x18\x01\x12\x04\xa3\x05\x06\x18\n\x11\n\t\
    \x04\x08\x03\x01\x04\0\x02\x18\x02\x12\x04\xa3\x05\x1b\x20\n\x0e\n\x06\
    \x04\x08\x03\x01\x02\x02\x12\x04\xa6\x05\x04\x16\n\x0f\n\x07\x04\x08\x03\
    \x01\x02\x02\x06\x12\x04\xa6\x05\x04\x0c\n\x0f\n\x07\x04\x08\x03\x01\x02\
    \x02\x01\x12\x04\xa6\x05\r\x11\n\x0f\n\x07\x04\x08\x03\x01\x02\x02\x03\
    \x12\x04\xa6\x05\x14\x15\n$\n\x06\x04\x08\x03\x01\x03\0\x12\x06\xa9\x05\
    \x04\xac\x05\x05\x1a\x12\x20Edge\x20properties.\n\n\x0f\n\x07\x04\x08\
    \x03\x01\x03\0\x01\x12\x04\xa9\x05\x0c\x14\n\x10\n\x08\x04\x08\x03\x01\
    \x03\0\x02\0\x12\x04\xaa\x05\x06\x20\n\x11\n\t\x04\x08\x03\x01\x03\0\x02\
    \0\x06\x12\x04\xaa\x05\x06\x16\n\x11\n\t\x04\x08\x03\x01\x03\0\x02\0\x01\
    \x12\x04\xaa\x05\x17\x1b\n\x11\n\t\x04\x08\x03\x01\x03\0\x02\0\x03\x12\
    \x04\xaa\x05\x1e\x1f\n\x10\n\x08\x04\x08\x03\x01\x03\0\x02\x01\x12\x04\
    \xab\x05\x06\x1e\n\x11\n\t\x04\x08\x03\x01\x03\0\x02\x01\x06\x12\x04\xab\
    \x05\x06\x13\n\x11\n\t\x04\x08\x03\x01\x03\0\x02\x01\x01\x12\x04\xab\x05\
    \x14\x19\n\x11\n\t\x04\x08\x03\x01\x03\0\x02\x01\x03\x12\x04\xab\x05\x1c\
    \x1d\n\x0e\n\x06\x04\x08\x03\x01\x02\x03\x12\x04\xad\x05\x02!\n\x0f\n\
    \x07\x04\x08\x03\x01\x02\x03\x04\x12\x04\xad\x05\x02\n\n\x0f\n\x07\x04\
    \x08\x03\x01\x02\x03\x06\x12\x04\xad\x05\x0b\x13\n\x0f\n\x07\x04\x08\x03\
    \x01\x02\x03\x01\x12\x04\xad\x05\x14\x1c\n\x0f\n\x07\x04\x08\x03\x01\x02\
    \x03\x03\x12\x04\xad\x05\x1f\x20\n\x0c\n\x04\x04\x08\x02\x01\x12\x04\xaf\
    \x05\x02\x19\n\r\n\x05\x04\x08\x02\x01\x04\x12\x04\xaf\x05\x02\n\n\r\n\
    \x05\x04\x08\x02\x01\x06\x12\x04\xaf\x05\x0b\x0f\n\r\n\x05\x04\x08\x02\
    \x01\x01\x12\x04\xaf\x05\x10\x14\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\
    \xaf\x05\x17\x18\n\x0c\n\x02\x04\t\x12\x06\xb2\x05\0\xb5\x05\x01\n\x0b\n\
    \x03\x04\t\x01\x12\x04\xb2\x05\x08\x1e\n\x0c\n\x04\x04\t\x02\0\x12\x04\
    \xb3\x05\x02\x14\n\r\n\x05\x04\t\x02\0\x05\x12\x04\xb3\x05\x02\x07\n\r\n\
    \x05\x04\t\x02\0\x01\x12\x04\xb3\x05\x08\x0f\n\r\n\x05\x04\t\x02\0\x03\
    \x12\x04\xb3\x05\x12\x13\n\x0c\n\x04\x04\t\x02\x01\x12\x04\xb4\x05\x02'\
    \n\r\n\x05\x04\t\x02\x01\x06\x12\x04\xb4\x05\x02\x19\n\r\n\x05\x04\t\x02\
    \x01\x01\x12\x04\xb4\x05\x1a\"\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xb4\
    \x05%&\n\x0c\n\x02\x04\n\x12\x06\xb7\x05\0\xbd\x05\x01\n\x0b\n\x03\x04\n\
    \x01\x12\x04\xb7\x05\x08\x1e\n\x0c\n\x04\x04\n\x02\0\x12\x04\xb8\x05\x02\
    \x14\n\r\n\x05\x04\n\x02\0\x05\x12\x04\xb8\x05\x02\x07\n\r\n\x05\x04\n\
    \x02\0\x01\x12\x04\xb8\x05\x08\x0f\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xb8\
    \x05\x12\x13\n\x0c\n\x04\x04\n\x02\x01\x12\x04\xb9\x05\x02'\n\r\n\x05\
    \x04\n\x02\x01\x06\x12\x04\xb9\x05\x02\x19\n\r\n\x05\x04\n\x02\x01\x01\
    \x12\x04\xb9\x05\x1a\"\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\xb9\x05%&\n\
    \x0c\n\x04\x04\n\x02\x02\x12\x04\xba\x05\x02\x19\n\r\n\x05\x04\n\x02\x02\
    \x05\x12\x04\xba\x05\x02\x07\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\xba\x05\
    \x08\x14\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\xba\x05\x17\x18\n\x0c\n\x04\
    \x04\n\x02\x03\x12\x04\xbb\x05\x02\x18\n\r\n\x05\x04\n\x02\x03\x05\x12\
    \x04\xbb\x05\x02\x07\n\r\n\x05\x04\n\x02\x03\x01\x12\x04\xbb\x05\x08\x13\
    \n\r\n\x05\x04\n\x02\x03\x03\x12\x04\xbb\x05\x16\x17\n\x0c\n\x04\x04\n\
    \x02\x04\x12\x04\xbc\x05\x02(\n\r\n\x05\x04\n\x02\x04\x06\x12\x04\xbc\
    \x05\x02\x19\n\r\n\x05\x04\n\x02\x04\x01\x12\x04\xbc\x05\x1a#\n\r\n\x05\
    \x04\n\x02\x04\x03\x12\x04\xbc\x05&'\ni\n\x02\x04\x0b\x12\x06\xc0\x05\0\
    \xc5\x05\x01\x1a[\x20Overlays\x20can\x20be\x20stacked\x20onto\x20each\
    \x20other,\x20therefor\x20their\x20node\x20ids\x20must\x20be\x20globally\
    \x20unique.\n\n\x0b\n\x03\x04\x0b\x01\x12\x04\xc0\x05\x08\x12\n\x0c\n\
    \x04\x04\x0b\x02\0\x12\x04\xc1\x05\x02#\n\r\n\x05\x04\x0b\x02\0\x04\x12\
    \x04\xc1\x05\x02\n\n\r\n\x05\x04\x0b\x02\0\x06\x12\x04\xc1\x05\x0b\x19\n\
    \r\n\x05\x04\x0b\x02\0\x01\x12\x04\xc1\x05\x1a\x1e\n\r\n\x05\x04\x0b\x02\
    \0\x03\x12\x04\xc1\x05!\"\n\x0c\n\x04\x04\x0b\x02\x01\x12\x04\xc2\x05\
    \x02#\n\r\n\x05\x04\x0b\x02\x01\x04\x12\x04\xc2\x05\x02\n\n\r\n\x05\x04\
    \x0b\x02\x01\x06\x12\x04\xc2\x05\x0b\x19\n\r\n\x05\x04\x0b\x02\x01\x01\
    \x12\x04\xc2\x05\x1a\x1e\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\xc2\x05!\
    \"\n\x0c\n\x04\x04\x0b\x02\x02\x12\x04\xc3\x05\x024\n\r\n\x05\x04\x0b\
    \x02\x02\x04\x12\x04\xc3\x05\x02\n\n\r\n\x05\x04\x0b\x02\x02\x06\x12\x04\
    \xc3\x05\x0b!\n\r\n\x05\x04\x0b\x02\x02\x01\x12\x04\xc3\x05\"/\n\r\n\x05\
    \x04\x0b\x02\x02\x03\x12\x04\xc3\x0523\n\x0c\n\x04\x04\x0b\x02\x03\x12\
    \x04\xc4\x05\x024\n\r\n\x05\x04\x0b\x02\x03\x04\x12\x04\xc4\x05\x02\n\n\
    \r\n\x05\x04\x0b\x02\x03\x06\x12\x04\xc4\x05\x0b!\n\r\n\x05\x04\x0b\x02\
    \x03\x01\x12\x04\xc4\x05\"/\n\r\n\x05\x04\x0b\x02\x03\x03\x12\x04\xc4\
    \x0523\n\xf2\x01\n\x02\x04\x0c\x12\x06\xca\x05\0\xf2\x05\x01\x1a\xe3\x01\
    \x20DiffGraphs\x20can\x20be\x20created\x20independently\x20of\x20each\
    \x20other\x20and\x20therefor\x20when\x20_adding_\x20nodes|edges,\n\x20ea\
    ch\x20DiffGraph\x20has\x20its\x20own\x20ID\x20space.\x20However,\x20when\
    \x20removing\x20nodes|edges,\x20the\x20nodeIds\x20refer\x20to\x20the\n\
    \x20globally\x20unique\x20graph\x20id\x20space.\n\n\x0b\n\x03\x04\x0c\
    \x01\x12\x04\xca\x05\x08\x11\n\x0e\n\x04\x04\x0c\x03\0\x12\x06\xcb\x05\
    \x02\xcd\x05\x03\n\r\n\x05\x04\x0c\x03\0\x01\x12\x04\xcb\x05\n\x14\n\x0e\
    \n\x06\x04\x0c\x03\0\x02\0\x12\x04\xcc\x05\x04\x12\n\x0f\n\x07\x04\x0c\
    \x03\0\x02\0\x05\x12\x04\xcc\x05\x04\t\n\x0f\n\x07\x04\x0c\x03\0\x02\0\
    \x01\x12\x04\xcc\x05\n\r\n\x0f\n\x07\x04\x0c\x03\0\x02\0\x03\x12\x04\xcc\
    \x05\x10\x11\n\x0e\n\x04\x04\x0c\x03\x01\x12\x06\xcf\x05\x02\xd3\x05\x03\
    \n\r\n\x05\x04\x0c\x03\x01\x01\x12\x04\xcf\x05\n\x1c\n\x0e\n\x06\x04\x0c\
    \x03\x01\x02\0\x12\x04\xd0\x05\x04\x12\n\x0f\n\x07\x04\x0c\x03\x01\x02\0\
    \x05\x12\x04\xd0\x05\x04\t\n\x0f\n\x07\x04\x0c\x03\x01\x02\0\x01\x12\x04\
    \xd0\x05\n\r\n\x0f\n\x07\x04\x0c\x03\x01\x02\0\x03\x12\x04\xd0\x05\x10\
    \x11\n\x0e\n\x06\x04\x0c\x03\x01\x02\x01\x12\x04\xd1\x05\x04\x1e\n\x0f\n\
    \x07\x04\x0c\x03\x01\x02\x01\x06\x12\x04\xd1\x05\x04\x14\n\x0f\n\x07\x04\
    \x0c\x03\x01\x02\x01\x01\x12\x04\xd1\x05\x15\x19\n\x0f\n\x07\x04\x0c\x03\
    \x01\x02\x01\x03\x12\x04\xd1\x05\x1c\x1d\n\x0e\n\x06\x04\x0c\x03\x01\x02\
    \x02\x12\x04\xd2\x05\x04\x1a\n\x0f\n\x07\x04\x0c\x03\x01\x02\x02\x05\x12\
    \x04\xd2\x05\x04\n\n\x0f\n\x07\x04\x0c\x03\x01\x02\x02\x01\x12\x04\xd2\
    \x05\x0b\x15\n\x0f\n\x07\x04\x0c\x03\x01\x02\x02\x03\x12\x04\xd2\x05\x18\
    \x19\n\x0e\n\x04\x04\x0c\x03\x02\x12\x06\xd5\x05\x02\xda\x05\x03\n\r\n\
    \x05\x04\x0c\x03\x02\x01\x12\x04\xd5\x05\n\x14\n\x0e\n\x06\x04\x0c\x03\
    \x02\x02\0\x12\x04\xd6\x05\x04\x1b\n\x0f\n\x07\x04\x0c\x03\x02\x02\0\x05\
    \x12\x04\xd6\x05\x04\t\n\x0f\n\x07\x04\x0c\x03\x02\x02\0\x01\x12\x04\xd6\
    \x05\n\x16\n\x0f\n\x07\x04\x0c\x03\x02\x02\0\x03\x12\x04\xd6\x05\x19\x1a\
    \n\x0e\n\x06\x04\x0c\x03\x02\x02\x01\x12\x04\xd7\x05\x04\x1a\n\x0f\n\x07\
    \x04\x0c\x03\x02\x02\x01\x05\x12\x04\xd7\x05\x04\t\n\x0f\n\x07\x04\x0c\
    \x03\x02\x02\x01\x01\x12\x04\xd7\x05\n\x15\n\x0f\n\x07\x04\x0c\x03\x02\
    \x02\x01\x03\x12\x04\xd7\x05\x18\x19\n\x0e\n\x06\x04\x0c\x03\x02\x02\x02\
    \x12\x04\xd8\x05\x04*\n\x0f\n\x07\x04\x0c\x03\x02\x02\x02\x06\x12\x04\
    \xd8\x05\x04\x1b\n\x0f\n\x07\x04\x0c\x03\x02\x02\x02\x01\x12\x04\xd8\x05\
    \x1c%\n\x0f\n\x07\x04\x0c\x03\x02\x02\x02\x03\x12\x04\xd8\x05()\nI\n\x06\
    \x04\x0c\x03\x02\x02\x03\x12\x04\xd9\x05\x04\x1d\"9\x20used\x20to\x20ide\
    ntify\x20edges\x20(since\x20our\x20edges\x20don't\x20have\x20ids)\n\n\
    \x0f\n\x07\x04\x0c\x03\x02\x02\x03\x05\x12\x04\xd9\x05\x04\t\n\x0f\n\x07\
    \x04\x0c\x03\x02\x02\x03\x01\x12\x04\xd9\x05\n\x18\n\x0f\n\x07\x04\x0c\
    \x03\x02\x02\x03\x03\x12\x04\xd9\x05\x1b\x1c\n\x0e\n\x04\x04\x0c\x03\x03\
    \x12\x06\xdc\x05\x02\xe2\x05\x03\n\r\n\x05\x04\x0c\x03\x03\x01\x12\x04\
    \xdc\x05\n\x1c\n\x0e\n\x06\x04\x0c\x03\x03\x02\0\x12\x04\xdd\x05\x04\x1b\
    \n\x0f\n\x07\x04\x0c\x03\x03\x02\0\x05\x12\x04\xdd\x05\x04\t\n\x0f\n\x07\
    \x04\x0c\x03\x03\x02\0\x01\x12\x04\xdd\x05\n\x16\n\x0f\n\x07\x04\x0c\x03\
    \x03\x02\0\x03\x12\x04\xdd\x05\x19\x1a\n\x0e\n\x06\x04\x0c\x03\x03\x02\
    \x01\x12\x04\xde\x05\x04\x1a\n\x0f\n\x07\x04\x0c\x03\x03\x02\x01\x05\x12\
    \x04\xde\x05\x04\t\n\x0f\n\x07\x04\x0c\x03\x03\x02\x01\x01\x12\x04\xde\
    \x05\n\x15\n\x0f\n\x07\x04\x0c\x03\x03\x02\x01\x03\x12\x04\xde\x05\x18\
    \x19\n\x0e\n\x06\x04\x0c\x03\x03\x02\x02\x12\x04\xdf\x05\x04*\n\x0f\n\
    \x07\x04\x0c\x03\x03\x02\x02\x06\x12\x04\xdf\x05\x04\x1b\n\x0f\n\x07\x04\
    \x0c\x03\x03\x02\x02\x01\x12\x04\xdf\x05\x1c%\n\x0f\n\x07\x04\x0c\x03\
    \x03\x02\x02\x03\x12\x04\xdf\x05()\nI\n\x06\x04\x0c\x03\x03\x02\x03\x12\
    \x04\xe0\x05\x04\x1d\"9\x20used\x20to\x20identify\x20edges\x20(since\x20\
    our\x20edges\x20don't\x20have\x20ids)\n\n\x0f\n\x07\x04\x0c\x03\x03\x02\
    \x03\x05\x12\x04\xe0\x05\x04\t\n\x0f\n\x07\x04\x0c\x03\x03\x02\x03\x01\
    \x12\x04\xe0\x05\n\x18\n\x0f\n\x07\x04\x0c\x03\x03\x02\x03\x03\x12\x04\
    \xe0\x05\x1b\x1c\n\x0e\n\x06\x04\x0c\x03\x03\x02\x04\x12\x04\xe1\x05\x04\
    '\n\x0f\n\x07\x04\x0c\x03\x03\x02\x04\x06\x12\x04\xe1\x05\x04\x14\n\x0f\
    \n\x07\x04\x0c\x03\x03\x02\x04\x01\x12\x04\xe1\x05\x15\"\n\x0f\n\x07\x04\
    \x0c\x03\x03\x02\x04\x03\x12\x04\xe1\x05%&\n\x0e\n\x04\x04\x0c\x03\x04\
    \x12\x06\xe4\x05\x02\xef\x05\x03\n\r\n\x05\x04\x0c\x03\x04\x01\x12\x04\
    \xe4\x05\n\x0f\n\x10\n\x06\x04\x0c\x03\x04\x08\0\x12\x06\xe5\x05\x04\xee\
    \x05\x05\n\x0f\n\x07\x04\x0c\x03\x04\x08\0\x01\x12\x04\xe5\x05\n\x0f\n\
    \x0e\n\x06\x04\x0c\x03\x04\x02\0\x12\x04\xe6\x05\x06\x1e\n\x0f\n\x07\x04\
    \x0c\x03\x04\x02\0\x06\x12\x04\xe6\x05\x06\x14\n\x0f\n\x07\x04\x0c\x03\
    \x04\x02\0\x01\x12\x04\xe6\x05\x15\x19\n\x0f\n\x07\x04\x0c\x03\x04\x02\0\
    \x03\x12\x04\xe6\x05\x1c\x1d\n\x0e\n\x06\x04\x0c\x03\x04\x02\x01\x12\x04\
    \xe7\x05\x06\x1e\n\x0f\n\x07\x04\x0c\x03\x04\x02\x01\x06\x12\x04\xe7\x05\
    \x06\x14\n\x0f\n\x07\x04\x0c\x03\x04\x02\x01\x01\x12\x04\xe7\x05\x15\x19\
    \n\x0f\n\x07\x04\x0c\x03\x04\x02\x01\x03\x12\x04\xe7\x05\x1c\x1d\n\x0e\n\
    \x06\x04\x0c\x03\x04\x02\x02\x12\x04\xe8\x05\x06/\n\x0f\n\x07\x04\x0c\
    \x03\x04\x02\x02\x06\x12\x04\xe8\x05\x06\x1c\n\x0f\n\x07\x04\x0c\x03\x04\
    \x02\x02\x01\x12\x04\xe8\x05\x1d*\n\x0f\n\x07\x04\x0c\x03\x04\x02\x02\
    \x03\x12\x04\xe8\x05-.\n\x0e\n\x06\x04\x0c\x03\x04\x02\x03\x12\x04\xe9\
    \x05\x06/\n\x0f\n\x07\x04\x0c\x03\x04\x02\x03\x06\x12\x04\xe9\x05\x06\
    \x1c\n\x0f\n\x07\x04\x0c\x03\x04\x02\x03\x01\x12\x04\xe9\x05\x1d*\n\x0f\
    \n\x07\x04\x0c\x03\x04\x02\x03\x03\x12\x04\xe9\x05-.\n\x0e\n\x06\x04\x0c\
    \x03\x04\x02\x04\x12\x04\xea\x05\x06!\n\x0f\n\x07\x04\x0c\x03\x04\x02\
    \x04\x06\x12\x04\xea\x05\x06\x10\n\x0f\n\x07\x04\x0c\x03\x04\x02\x04\x01\
    \x12\x04\xea\x05\x11\x1c\n\x0f\n\x07\x04\x0c\x03\x04\x02\x04\x03\x12\x04\
    \xea\x05\x1f\x20\n\x0e\n\x06\x04\x0c\x03\x04\x02\x05\x12\x04\xeb\x05\x06\
    2\n\x0f\n\x07\x04\x0c\x03\x04\x02\x05\x06\x12\x04\xeb\x05\x06\x18\n\x0f\
    \n\x07\x04\x0c\x03\x04\x02\x05\x01\x12\x04\xeb\x05\x19-\n\x0f\n\x07\x04\
    \x0c\x03\x04\x02\x05\x03\x12\x04\xeb\x0501\n\x0e\n\x06\x04\x0c\x03\x04\
    \x02\x06\x12\x04\xec\x05\x06!\n\x0f\n\x07\x04\x0c\x03\x04\x02\x06\x06\
    \x12\x04\xec\x05\x06\x10\n\x0f\n\x07\x04\x0c\x03\x04\x02\x06\x01\x12\x04\
    \xec\x05\x11\x1c\n\x0f\n\x07\x04\x0c\x03\x04\x02\x06\x03\x12\x04\xec\x05\
    \x1f\x20\n\x0e\n\x06\x04\x0c\x03\x04\x02\x07\x12\x04\xed\x05\x062\n\x0f\
    \n\x07\x04\x0c\x03\x04\x02\x07\x06\x12\x04\xed\x05\x06\x18\n\x0f\n\x07\
    \x04\x0c\x03\x04\x02\x07\x01\x12\x04\xed\x05\x19-\n\x0f\n\x07\x04\x0c\
    \x03\x04\x02\x07\x03\x12\x04\xed\x0501\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\
    \xf1\x05\x02\x1d\n\r\n\x05\x04\x0c\x02\0\x04\x12\x04\xf1\x05\x02\n\n\r\n\
    \x05\x04\x0c\x02\0\x06\x12\x04\xf1\x05\x0b\x10\n\r\n\x05\x04\x0c\x02\0\
    \x01\x12\x04\xf1\x05\x11\x18\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xf1\x05\
    \x1b\x1c\n\xf6\x03\n\x02\x04\r\x12\x06\xfa\x05\0\x9c\x07\x01\x1a\xe7\x03\
    *\n\x20The\x20usages\x20slice\x20describes\x20how\x20a\x20variable\x20in\
    teracts\x20within\x20its\x20procedure.\x20This\x20is\x20perhaps\x20a\x20\
    more\x20\"descriptive\"\x20slice\x20in\x20some\x20ways.\x20The\x20variab\
    les\x20are\x20locals\x20and\x20parameters\x20and\x20the\x20referencing\
    \x20identifiers\x20are\x20tracked\x20to\x20find\x20what\x20the\x20variab\
    le\x20calls\x20and\x20what\x20calls\x20it\x20forms\x20an\x20argument\x20\
    of.\n\x20There\x20are\x20two\x20lists.\x20There\x20is\x20a\x20list\x20of\
    \x20MethodUsageSlice\x20with\x20key\x20\"objectSlices\"\x20and\x20a\x20l\
    ist\x20of\x20UserDefinedTypes\x20with\x20key\x20\"userDefinedTypes\"\n\n\
    \x20![Usage\x20slices\x20overview](./docs/Library%20Usages.png)\n\n\x0b\
    \n\x03\x04\r\x01\x12\x04\xfa\x05\x08\x12\n\x1d\n\x04\x04\r\x04\0\x12\x06\
    \xfc\x05\x04\x8d\x06\x05\x1a\r\x20Label\x20type.\n\n\r\n\x05\x04\r\x04\0\
    \x01\x12\x04\xfc\x05\t\x12\n>\n\x06\x04\r\x04\0\x02\0\x12\x04\xfe\x05\
    \x06\x0e\x1a.\x20Any\x20is\x20used\x20to\x20represent\x20multiple\x20mec\
    hanisms\n\n\x0f\n\x07\x04\r\x04\0\x02\0\x01\x12\x04\xfe\x05\x06\t\n\x0f\
    \n\x07\x04\r\x04\0\x02\0\x02\x12\x04\xfe\x05\x0c\r\ng\n\x06\x04\r\x04\0\
    \x02\x01\x12\x04\x80\x06\x06\x10\x1aW\x20Represents\x20a\x20local\x20tra\
    nsfer\x20of\x20data\x20via\x20aliasing.\x20The\x20data\x20defined\x20is\
    \x20via\x20some\x20alias.\n\n\x0f\n\x07\x04\r\x04\0\x02\x01\x01\x12\x04\
    \x80\x06\x06\x0b\n\x0f\n\x07\x04\r\x04\0\x02\x01\x02\x12\x04\x80\x06\x0e\
    \x0f\n'\n\x06\x04\r\x04\0\x02\x02\x12\x04\x82\x06\x06\x12\x1a\x17\x20Rep\
    resents\x20a\x20literal.\n\n\x0f\n\x07\x04\r\x04\0\x02\x02\x01\x12\x04\
    \x82\x06\x06\r\n\x0f\n\x07\x04\r\x04\0\x02\x02\x02\x12\x04\x82\x06\x10\
    \x11\n=\n\x06\x04\r\x04\0\x02\x03\x12\x04\x84\x06\x06\x10\x1a-\x20Repres\
    ents\x20data\x20introduced\x20via\x20a\x20parameter.\n\n\x0f\n\x07\x04\r\
    \x04\0\x02\x03\x01\x12\x04\x84\x06\x06\x0b\n\x0f\n\x07\x04\r\x04\0\x02\
    \x03\x02\x12\x04\x84\x06\x0e\x0f\nK\n\x06\x04\r\x04\0\x02\x04\x12\x04\
    \x86\x06\x06\x0f\x1a;\x20Represents\x20data\x20introduced\x20by\x20the\
    \x20return\x20value\x20of\x20a\x20call.\n\n\x0f\n\x07\x04\r\x04\0\x02\
    \x04\x01\x12\x04\x86\x06\x06\n\n\x0f\n\x07\x04\r\x04\0\x02\x04\x02\x12\
    \x04\x86\x06\r\x0e\n\x1c\n\x06\x04\r\x04\0\x02\x05\x12\x04\x88\x06\x06\
    \x15\x1a\x0c\x20Identifier\n\n\x0f\n\x07\x04\r\x04\0\x02\x05\x01\x12\x04\
    \x88\x06\x06\x10\n\x0f\n\x07\x04\r\x04\0\x02\x05\x02\x12\x04\x88\x06\x13\
    \x14\n\x1a\n\x06\x04\r\x04\0\x02\x06\x12\x04\x8a\x06\x06\x13\x1a\n\x20Ty\
    pe\x20ref\n\n\x0f\n\x07\x04\r\x04\0\x02\x06\x01\x12\x04\x8a\x06\x06\x0e\
    \n\x0f\n\x07\x04\r\x04\0\x02\x06\x02\x12\x04\x8a\x06\x11\x12\nL\n\x06\
    \x04\r\x04\0\x02\x07\x12\x04\x8c\x06\x06\x13\x1a<\x20Represents\x20data\
    \x20introduced\x20by\x20an\x20unhandled\x20data\x20structure.\n\n\x0f\n\
    \x07\x04\r\x04\0\x02\x07\x01\x12\x04\x8c\x06\x06\r\n\x0f\n\x07\x04\r\x04\
    \0\x02\x07\x02\x12\x04\x8c\x06\x10\x12\n\x93\x01\n\x04\x04\r\x03\0\x12\
    \x06\x90\x06\x04\x9f\x06\x05\x1a\x82\x01\x20Represents\x20a\x20source\
    \x20of\x20data-generation,\x20i.e.,\x20where\x20data\x20is\x20defined\
    \x20and\x20can\x20be\x20assigned\x20to\x20some\x20variable\x20or\x20used\
    \x20in\x20an\x20argument.\n\n\r\n\x05\x04\r\x03\0\x01\x12\x04\x90\x06\
    \x0c\x15\n,\n\x06\x04\r\x03\0\x02\0\x12\x04\x92\x06\x08\x18\x1a\x1c\x20v\
    ariable\x20or\x20parameter\x20name\n\n\x0f\n\x07\x04\r\x03\0\x02\0\x05\
    \x12\x04\x92\x06\x08\x0e\n\x0f\n\x07\x04\r\x03\0\x02\0\x01\x12\x04\x92\
    \x06\x0f\x13\n\x0f\n\x07\x04\r\x03\0\x02\0\x03\x12\x04\x92\x06\x16\x17\n\
    +\n\x06\x04\r\x03\0\x02\x01\x12\x04\x94\x06\x08\x20\x1a\x1b\x20Fullname\
    \x20of\x20the\x20data\x20type\n\n\x0f\n\x07\x04\r\x03\0\x02\x01\x05\x12\
    \x04\x94\x06\x08\x0e\n\x0f\n\x07\x04\r\x03\0\x02\x01\x01\x12\x04\x94\x06\
    \x0f\x1b\n\x0f\n\x07\x04\r\x03\0\x02\x01\x03\x12\x04\x94\x06\x1e\x1f\n7\
    \n\x06\x04\r\x03\0\x02\x02\x12\x04\x96\x06\x08\x1c\x1a'\x20Position\x20o\
    f\x20the\x20parameter\x20or\x20argument\n\n\x0f\n\x07\x04\r\x03\0\x02\
    \x02\x05\x12\x04\x96\x06\x08\x0e\n\x0f\n\x07\x04\r\x03\0\x02\x02\x01\x12\
    \x04\x96\x06\x0f\x17\n\x0f\n\x07\x04\r\x03\0\x02\x02\x03\x12\x04\x96\x06\
    \x1a\x1b\n[\n\x06\x04\r\x03\0\x02\x03\x12\x04\x98\x06\x08\x1c\x1aK\x20Bo\
    olean\x20to\x20indicate\x20if\x20the\x20call\x20belongs\x20to\x20an\x20e\
    xternal\x20method.\x20label=CALL\n\n\x0f\n\x07\x04\r\x03\0\x02\x03\x05\
    \x12\x04\x98\x06\x08\x0c\n\x0f\n\x07\x04\r\x03\0\x02\x03\x01\x12\x04\x98\
    \x06\r\x17\n\x0f\n\x07\x04\r\x03\0\x02\x03\x03\x12\x04\x98\x06\x1a\x1b\n\
    )\n\x06\x04\r\x03\0\x02\x04\x12\x04\x9a\x06\x08\x1e\x1a\x19\x20Line\x20n\
    umber\x20in\x20the\x20file\n\n\x0f\n\x07\x04\r\x03\0\x02\x04\x05\x12\x04\
    \x9a\x06\x08\x0e\n\x0f\n\x07\x04\r\x03\0\x02\x04\x01\x12\x04\x9a\x06\x0f\
    \x19\n\x0f\n\x07\x04\r\x03\0\x02\x04\x03\x12\x04\x9a\x06\x1c\x1d\n\x1f\n\
    \x06\x04\r\x03\0\x02\x05\x12\x04\x9c\x06\x08\x20\x1a\x0f\x20Column\x20nu\
    mber\n\n\x0f\n\x07\x04\r\x03\0\x02\x05\x05\x12\x04\x9c\x06\x08\x0e\n\x0f\
    \n\x07\x04\r\x03\0\x02\x05\x01\x12\x04\x9c\x06\x0f\x1b\n\x0f\n\x07\x04\r\
    \x03\0\x02\x05\x03\x12\x04\x9c\x06\x1e\x1f\n\x0e\n\x06\x04\r\x03\0\x02\
    \x06\x12\x04\x9e\x06\x08\x1c\n\x0f\n\x07\x04\r\x03\0\x02\x06\x06\x12\x04\
    \x9e\x06\x08\x11\n\x0f\n\x07\x04\r\x03\0\x02\x06\x01\x12\x04\x9e\x06\x12\
    \x17\n\x0f\n\x07\x04\r\x03\0\x02\x06\x03\x12\x04\x9e\x06\x1a\x1b\n:\n\
    \x04\x04\r\x03\x01\x12\x06\xa1\x06\x04\xb2\x06\x05\x1a*\x20Places\x20whe\
    re\x20the\x20given\x20symbol\x20is\x20defined\n\n\r\n\x05\x04\r\x03\x01\
    \x01\x12\x04\xa1\x06\x0c\x15\n,\n\x06\x04\r\x03\x01\x02\0\x12\x04\xa3\
    \x06\x08\x18\x1a\x1c\x20variable\x20or\x20parameter\x20name\n\n\x0f\n\
    \x07\x04\r\x03\x01\x02\0\x05\x12\x04\xa3\x06\x08\x0e\n\x0f\n\x07\x04\r\
    \x03\x01\x02\0\x01\x12\x04\xa3\x06\x0f\x13\n\x0f\n\x07\x04\r\x03\x01\x02\
    \0\x03\x12\x04\xa3\x06\x16\x17\n+\n\x06\x04\r\x03\x01\x02\x01\x12\x04\
    \xa5\x06\x08\x20\x1a\x1b\x20Fullname\x20of\x20the\x20data\x20type\n\n\
    \x0f\n\x07\x04\r\x03\x01\x02\x01\x05\x12\x04\xa5\x06\x08\x0e\n\x0f\n\x07\
    \x04\r\x03\x01\x02\x01\x01\x12\x04\xa5\x06\x0f\x1b\n\x0f\n\x07\x04\r\x03\
    \x01\x02\x01\x03\x12\x04\xa5\x06\x1e\x1f\n\x1d\n\x06\x04\r\x03\x01\x02\
    \x02\x12\x04\xa7\x06\x08\"\x1a\r\x20Method\x20name\n\n\x0f\n\x07\x04\r\
    \x03\x01\x02\x02\x05\x12\x04\xa7\x06\x08\x0e\n\x0f\n\x07\x04\r\x03\x01\
    \x02\x02\x01\x12\x04\xa7\x06\x0f\x1d\n\x0f\n\x07\x04\r\x03\x01\x02\x02\
    \x03\x12\x04\xa7\x06\x20!\n\x1a\n\x06\x04\r\x03\x01\x02\x03\x12\x04\xa9\
    \x06\x08\x1c\x1a\n\x20Position\n\n\x0f\n\x07\x04\r\x03\x01\x02\x03\x05\
    \x12\x04\xa9\x06\x08\x0e\n\x0f\n\x07\x04\r\x03\x01\x02\x03\x01\x12\x04\
    \xa9\x06\x0f\x17\n\x0f\n\x07\x04\r\x03\x01\x02\x03\x03\x12\x04\xa9\x06\
    \x1a\x1b\n[\n\x06\x04\r\x03\x01\x02\x04\x12\x04\xab\x06\x08\x1c\x1aK\x20\
    Boolean\x20to\x20indicate\x20if\x20the\x20call\x20belongs\x20to\x20an\
    \x20external\x20method.\x20label=CALL\n\n\x0f\n\x07\x04\r\x03\x01\x02\
    \x04\x05\x12\x04\xab\x06\x08\x0c\n\x0f\n\x07\x04\r\x03\x01\x02\x04\x01\
    \x12\x04\xab\x06\r\x17\n\x0f\n\x07\x04\r\x03\x01\x02\x04\x03\x12\x04\xab\
    \x06\x1a\x1b\n\x1d\n\x06\x04\r\x03\x01\x02\x05\x12\x04\xad\x06\x08\x1e\
    \x1a\r\x20Line\x20number\n\n\x0f\n\x07\x04\r\x03\x01\x02\x05\x05\x12\x04\
    \xad\x06\x08\x0e\n\x0f\n\x07\x04\r\x03\x01\x02\x05\x01\x12\x04\xad\x06\
    \x0f\x19\n\x0f\n\x07\x04\r\x03\x01\x02\x05\x03\x12\x04\xad\x06\x1c\x1d\n\
    \x1f\n\x06\x04\r\x03\x01\x02\x06\x12\x04\xaf\x06\x08\x20\x1a\x0f\x20Colu\
    mn\x20number\n\n\x0f\n\x07\x04\r\x03\x01\x02\x06\x05\x12\x04\xaf\x06\x08\
    \x0e\n\x0f\n\x07\x04\r\x03\x01\x02\x06\x01\x12\x04\xaf\x06\x0f\x1b\n\x0f\
    \n\x07\x04\r\x03\x01\x02\x06\x03\x12\x04\xaf\x06\x1e\x1f\nB\n\x06\x04\r\
    \x03\x01\x02\x07\x12\x04\xb1\x06\x08\x19\x1a2\x20Label\x20describing\x20\
    the\x20resolved\x20method\x20or\x20position\n\n\x0f\n\x07\x04\r\x03\x01\
    \x02\x07\x05\x12\x04\xb1\x06\x08\x0e\n\x0f\n\x07\x04\r\x03\x01\x02\x07\
    \x01\x12\x04\xb1\x06\x0f\x14\n\x0f\n\x07\x04\r\x03\x01\x02\x07\x03\x12\
    \x04\xb1\x06\x17\x18\n<\n\x04\x04\r\x03\x02\x12\x06\xb4\x06\x04\xc3\x06\
    \x05\x1a,\x20The\x20calls\x20this\x20object\x20is\x20observed\x20to\x20c\
    all.\n\n\r\n\x05\x04\r\x03\x02\x01\x12\x04\xb4\x06\x0c\x18\n\"\n\x06\x04\
    \r\x03\x02\x02\0\x12\x04\xb6\x06\x08\x1c\x1a\x12\x20Call\x20method\x20na\
    me\n\n\x0f\n\x07\x04\r\x03\x02\x02\0\x05\x12\x04\xb6\x06\x08\x0e\n\x0f\n\
    \x07\x04\r\x03\x02\x02\0\x01\x12\x04\xb6\x06\x0f\x17\n\x0f\n\x07\x04\r\
    \x03\x02\x02\0\x03\x12\x04\xb6\x06\x1a\x1b\n2\n\x06\x04\r\x03\x02\x02\
    \x01\x12\x04\xb8\x06\x08\"\x1a\"\x20Full\x20name\x20of\x20the\x20resolve\
    d\x20method\n\n\x0f\n\x07\x04\r\x03\x02\x02\x01\x05\x12\x04\xb8\x06\x08\
    \x0e\n\x0f\n\x07\x04\r\x03\x02\x02\x01\x01\x12\x04\xb8\x06\x0f\x1d\n\x0f\
    \n\x07\x04\r\x03\x02\x02\x01\x03\x12\x04\xb8\x06\x20!\n)\n\x06\x04\r\x03\
    \x02\x02\x02\x12\x04\xba\x06\x08'\x1a\x19\x20Types\x20of\x20the\x20param\
    eters\n\n\x0f\n\x07\x04\r\x03\x02\x02\x02\x04\x12\x04\xba\x06\x08\x10\n\
    \x0f\n\x07\x04\r\x03\x02\x02\x02\x05\x12\x04\xba\x06\x11\x17\n\x0f\n\x07\
    \x04\r\x03\x02\x02\x02\x01\x12\x04\xba\x06\x18\"\n\x0f\n\x07\x04\r\x03\
    \x02\x02\x02\x03\x12\x04\xba\x06%&\n\x1d\n\x06\x04\r\x03\x02\x02\x03\x12\
    \x04\xbc\x06\x08\x1e\x1a\r\x20Return\x20type\n\n\x0f\n\x07\x04\r\x03\x02\
    \x02\x03\x05\x12\x04\xbc\x06\x08\x0e\n\x0f\n\x07\x04\r\x03\x02\x02\x03\
    \x01\x12\x04\xbc\x06\x0f\x19\n\x0f\n\x07\x04\r\x03\x02\x02\x03\x03\x12\
    \x04\xbc\x06\x1c\x1d\nO\n\x06\x04\r\x03\x02\x02\x04\x12\x04\xbe\x06\x08\
    \x1c\x1a?\x20Boolean\x20to\x20indicate\x20if\x20the\x20call\x20belongs\
    \x20to\x20an\x20external\x20method\n\n\x0f\n\x07\x04\r\x03\x02\x02\x04\
    \x05\x12\x04\xbe\x06\x08\x0c\n\x0f\n\x07\x04\r\x03\x02\x02\x04\x01\x12\
    \x04\xbe\x06\r\x17\n\x0f\n\x07\x04\r\x03\x02\x02\x04\x03\x12\x04\xbe\x06\
    \x1a\x1b\n\x1d\n\x06\x04\r\x03\x02\x02\x05\x12\x04\xc0\x06\x08\x1e\x1a\r\
    \x20Line\x20number\n\n\x0f\n\x07\x04\r\x03\x02\x02\x05\x05\x12\x04\xc0\
    \x06\x08\x0e\n\x0f\n\x07\x04\r\x03\x02\x02\x05\x01\x12\x04\xc0\x06\x0f\
    \x19\n\x0f\n\x07\x04\r\x03\x02\x02\x05\x03\x12\x04\xc0\x06\x1c\x1d\n\x1f\
    \n\x06\x04\r\x03\x02\x02\x06\x12\x04\xc2\x06\x08\x20\x1a\x0f\x20Column\
    \x20number\n\n\x0f\n\x07\x04\r\x03\x02\x02\x06\x05\x12\x04\xc2\x06\x08\
    \x0e\n\x0f\n\x07\x04\r\x03\x02\x02\x06\x01\x12\x04\xc2\x06\x0f\x1b\n\x0f\
    \n\x07\x04\r\x03\x02\x02\x06\x03\x12\x04\xc2\x06\x1e\x1f\nI\n\x04\x04\r\
    \x03\x03\x12\x06\xc5\x06\x04\xd6\x06\x05\x1a9\x20The\x20calls\x20this\
    \x20object\x20is\x20observed\x20to\x20be\x20an\x20argument\x20of.\n\n\r\
    \n\x05\x04\r\x03\x03\x01\x12\x04\xc5\x06\x0c\x16\n\"\n\x06\x04\r\x03\x03\
    \x02\0\x12\x04\xc7\x06\x08\x1c\x1a\x12\x20Call\x20method\x20name\n\n\x0f\
    \n\x07\x04\r\x03\x03\x02\0\x05\x12\x04\xc7\x06\x08\x0e\n\x0f\n\x07\x04\r\
    \x03\x03\x02\0\x01\x12\x04\xc7\x06\x0f\x17\n\x0f\n\x07\x04\r\x03\x03\x02\
    \0\x03\x12\x04\xc7\x06\x1a\x1b\n2\n\x06\x04\r\x03\x03\x02\x01\x12\x04\
    \xc9\x06\x08\"\x1a\"\x20Full\x20name\x20of\x20the\x20resolved\x20method\
    \n\n\x0f\n\x07\x04\r\x03\x03\x02\x01\x05\x12\x04\xc9\x06\x08\x0e\n\x0f\n\
    \x07\x04\r\x03\x03\x02\x01\x01\x12\x04\xc9\x06\x0f\x1d\n\x0f\n\x07\x04\r\
    \x03\x03\x02\x01\x03\x12\x04\xc9\x06\x20!\n)\n\x06\x04\r\x03\x03\x02\x02\
    \x12\x04\xcb\x06\x08'\x1a\x19\x20Types\x20of\x20the\x20parameters\n\n\
    \x0f\n\x07\x04\r\x03\x03\x02\x02\x04\x12\x04\xcb\x06\x08\x10\n\x0f\n\x07\
    \x04\r\x03\x03\x02\x02\x05\x12\x04\xcb\x06\x11\x17\n\x0f\n\x07\x04\r\x03\
    \x03\x02\x02\x01\x12\x04\xcb\x06\x18\"\n\x0f\n\x07\x04\r\x03\x03\x02\x02\
    \x03\x12\x04\xcb\x06%&\n\x1d\n\x06\x04\r\x03\x03\x02\x03\x12\x04\xcd\x06\
    \x08\x1e\x1a\r\x20Return\x20type\n\n\x0f\n\x07\x04\r\x03\x03\x02\x03\x05\
    \x12\x04\xcd\x06\x08\x0e\n\x0f\n\x07\x04\r\x03\x03\x02\x03\x01\x12\x04\
    \xcd\x06\x0f\x19\n\x0f\n\x07\x04\r\x03\x03\x02\x03\x03\x12\x04\xcd\x06\
    \x1c\x1d\n#\n\x06\x04\r\x03\x03\x02\x04\x12\x04\xcf\x06\x08\x1c\x1a\x13\
    \x20Argument\x20position\n\n\x0f\n\x07\x04\r\x03\x03\x02\x04\x05\x12\x04\
    \xcf\x06\x08\x0e\n\x0f\n\x07\x04\r\x03\x03\x02\x04\x01\x12\x04\xcf\x06\
    \x0f\x17\n\x0f\n\x07\x04\r\x03\x03\x02\x04\x03\x12\x04\xcf\x06\x1a\x1b\n\
    O\n\x06\x04\r\x03\x03\x02\x05\x12\x04\xd1\x06\x08\x1c\x1a?\x20Boolean\
    \x20to\x20indicate\x20if\x20the\x20call\x20belongs\x20to\x20an\x20extern\
    al\x20method\n\n\x0f\n\x07\x04\r\x03\x03\x02\x05\x05\x12\x04\xd1\x06\x08\
    \x0c\n\x0f\n\x07\x04\r\x03\x03\x02\x05\x01\x12\x04\xd1\x06\r\x17\n\x0f\n\
    \x07\x04\r\x03\x03\x02\x05\x03\x12\x04\xd1\x06\x1a\x1b\n\x1d\n\x06\x04\r\
    \x03\x03\x02\x06\x12\x04\xd3\x06\x08\x1e\x1a\r\x20Line\x20number\n\n\x0f\
    \n\x07\x04\r\x03\x03\x02\x06\x05\x12\x04\xd3\x06\x08\x0e\n\x0f\n\x07\x04\
    \r\x03\x03\x02\x06\x01\x12\x04\xd3\x06\x0f\x19\n\x0f\n\x07\x04\r\x03\x03\
    \x02\x06\x03\x12\x04\xd3\x06\x1c\x1d\n\x1f\n\x06\x04\r\x03\x03\x02\x07\
    \x12\x04\xd5\x06\x08\x20\x1a\x0f\x20Column\x20number\n\n\x0f\n\x07\x04\r\
    \x03\x03\x02\x07\x05\x12\x04\xd5\x06\x08\x0e\n\x0f\n\x07\x04\r\x03\x03\
    \x02\x07\x01\x12\x04\xd5\x06\x0f\x1b\n\x0f\n\x07\x04\r\x03\x03\x02\x07\
    \x03\x12\x04\xd5\x06\x1e\x1f\nP\n\x04\x04\r\x03\x04\x12\x06\xd8\x06\x04\
    \xdd\x06\x05\x1a@\x20Describes\x20where\x20and\x20how\x20the\x20given\
    \x20external\x20object/type\x20is\x20used\n\n\r\n\x05\x04\r\x03\x04\x01\
    \x12\x04\xd8\x06\x0c\x1c\n\x0e\n\x06\x04\r\x03\x04\x02\0\x12\x04\xd9\x06\
    \x08\x20\n\x0f\n\x07\x04\r\x03\x04\x02\0\x06\x12\x04\xd9\x06\x08\x11\n\
    \x0f\n\x07\x04\r\x03\x04\x02\0\x01\x12\x04\xd9\x06\x12\x1b\n\x0f\n\x07\
    \x04\r\x03\x04\x02\0\x03\x12\x04\xd9\x06\x1e\x1f\n\x0e\n\x06\x04\r\x03\
    \x04\x02\x01\x12\x04\xda\x06\x08\x20\n\x0f\n\x07\x04\r\x03\x04\x02\x01\
    \x06\x12\x04\xda\x06\x08\x11\n\x0f\n\x07\x04\r\x03\x04\x02\x01\x01\x12\
    \x04\xda\x06\x12\x1b\n\x0f\n\x07\x04\r\x03\x04\x02\x01\x03\x12\x04\xda\
    \x06\x1e\x1f\n\x0e\n\x06\x04\r\x03\x04\x02\x02\x12\x04\xdb\x06\x08/\n\
    \x0f\n\x07\x04\r\x03\x04\x02\x02\x04\x12\x04\xdb\x06\x08\x10\n\x0f\n\x07\
    \x04\r\x03\x04\x02\x02\x06\x12\x04\xdb\x06\x11\x1d\n\x0f\n\x07\x04\r\x03\
    \x04\x02\x02\x01\x12\x04\xdb\x06\x1e*\n\x0f\n\x07\x04\r\x03\x04\x02\x02\
    \x03\x12\x04\xdb\x06-.\n\x0e\n\x06\x04\r\x03\x04\x02\x03\x12\x04\xdc\x06\
    \x08+\n\x0f\n\x07\x04\r\x03\x04\x02\x03\x04\x12\x04\xdc\x06\x08\x10\n\
    \x0f\n\x07\x04\r\x03\x04\x02\x03\x06\x12\x04\xdc\x06\x11\x1b\n\x0f\n\x07\
    \x04\r\x03\x04\x02\x03\x01\x12\x04\xdc\x06\x1c&\n\x0f\n\x07\x04\r\x03\
    \x04\x02\x03\x03\x12\x04\xdc\x06)*\nj\n\x04\x04\r\x03\x05\x12\x06\xe0\
    \x06\x04\xec\x06\x05\x1aZ\x20Packages\x20the\x20object\x20usage\x20slice\
    s\x20along\x20with\x20location\x20and\x20an\x20optional\x20method\x20sou\
    rce\x20code.\n\n\r\n\x05\x04\r\x03\x05\x01\x12\x04\xe0\x06\x0c\x1c\n/\n\
    \x06\x04\r\x03\x05\x02\0\x12\x04\xe2\x06\x08\x18\x1a\x1f\x20Raw\x20sourc\
    e\x20code\x20of\x20the\x20method\n\n\x0f\n\x07\x04\r\x03\x05\x02\0\x05\
    \x12\x04\xe2\x06\x08\x0e\n\x0f\n\x07\x04\r\x03\x05\x02\0\x01\x12\x04\xe2\
    \x06\x0f\x13\n\x0f\n\x07\x04\r\x03\x05\x02\0\x03\x12\x04\xe2\x06\x16\x17\
    \n\"\n\x06\x04\r\x03\x05\x02\x01\x12\x04\xe4\x06\x08\x1c\x1a\x12\x20Meth\
    od\x20full\x20name\n\n\x0f\n\x07\x04\r\x03\x05\x02\x01\x05\x12\x04\xe4\
    \x06\x08\x0e\n\x0f\n\x07\x04\r\x03\x05\x02\x01\x01\x12\x04\xe4\x06\x0f\
    \x17\n\x0f\n\x07\x04\r\x03\x05\x02\x01\x03\x12\x04\xe4\x06\x1a\x1b\n\x1b\
    \n\x06\x04\r\x03\x05\x02\x02\x12\x04\xe6\x06\x08\x1c\x1a\x0b\x20File\x20\
    name\n\n\x0f\n\x07\x04\r\x03\x05\x02\x02\x05\x12\x04\xe6\x06\x08\x0e\n\
    \x0f\n\x07\x04\r\x03\x05\x02\x02\x01\x12\x04\xe6\x06\x0f\x17\n\x0f\n\x07\
    \x04\r\x03\x05\x02\x02\x03\x12\x04\xe6\x06\x1a\x1b\n\x1d\n\x06\x04\r\x03\
    \x05\x02\x03\x12\x04\xe8\x06\x08\x1e\x1a\r\x20Line\x20number\n\n\x0f\n\
    \x07\x04\r\x03\x05\x02\x03\x05\x12\x04\xe8\x06\x08\x0e\n\x0f\n\x07\x04\r\
    \x03\x05\x02\x03\x01\x12\x04\xe8\x06\x0f\x19\n\x0f\n\x07\x04\r\x03\x05\
    \x02\x03\x03\x12\x04\xe8\x06\x1c\x1d\n\x1f\n\x06\x04\r\x03\x05\x02\x04\
    \x12\x04\xea\x06\x08\x20\x1a\x0f\x20Column\x20number\n\n\x0f\n\x07\x04\r\
    \x03\x05\x02\x04\x05\x12\x04\xea\x06\x08\x0e\n\x0f\n\x07\x04\r\x03\x05\
    \x02\x04\x01\x12\x04\xea\x06\x0f\x1b\n\x0f\n\x07\x04\r\x03\x05\x02\x04\
    \x03\x12\x04\xea\x06\x1e\x1f\n\x0e\n\x06\x04\r\x03\x05\x02\x05\x12\x04\
    \xeb\x06\x08-\n\x0f\n\x07\x04\r\x03\x05\x02\x05\x04\x12\x04\xeb\x06\x08\
    \x10\n\x0f\n\x07\x04\r\x03\x05\x02\x05\x06\x12\x04\xeb\x06\x11!\n\x0f\n\
    \x07\x04\r\x03\x05\x02\x05\x01\x12\x04\xeb\x06\"(\n\x0f\n\x07\x04\r\x03\
    \x05\x02\x05\x03\x12\x04\xeb\x06+,\ng\n\x04\x04\r\x03\x06\x12\x06\xef\
    \x06\x04\xfa\x06\x05\x1aW\x20Represents\x20a\x20local\x20transfer\x20of\
    \x20data\x20via\x20aliasing.\x20The\x20data\x20defined\x20is\x20via\x20s\
    ome\x20alias.\n\n\r\n\x05\x04\r\x03\x06\x01\x12\x04\xef\x06\x0c\x12\n,\n\
    \x06\x04\r\x03\x06\x02\0\x12\x04\xf1\x06\x08\x18\x1a\x1c\x20Name\x20of\
    \x20the\x20local\x20variable\n\n\x0f\n\x07\x04\r\x03\x06\x02\0\x05\x12\
    \x04\xf1\x06\x08\x0e\n\x0f\n\x07\x04\r\x03\x06\x02\0\x01\x12\x04\xf1\x06\
    \x0f\x13\n\x0f\n\x07\x04\r\x03\x06\x02\0\x03\x12\x04\xf1\x06\x16\x17\n'\
    \n\x06\x04\r\x03\x06\x02\x01\x12\x04\xf3\x06\x08\x20\x1a\x17\x20Full\x20\
    name\x20of\x20the\x20type\n\n\x0f\n\x07\x04\r\x03\x06\x02\x01\x05\x12\
    \x04\xf3\x06\x08\x0e\n\x0f\n\x07\x04\r\x03\x06\x02\x01\x01\x12\x04\xf3\
    \x06\x0f\x1b\n\x0f\n\x07\x04\r\x03\x06\x02\x01\x03\x12\x04\xf3\x06\x1e\
    \x1f\n\x1d\n\x06\x04\r\x03\x06\x02\x02\x12\x04\xf5\x06\x08\x1e\x1a\r\x20\
    Line\x20number\n\n\x0f\n\x07\x04\r\x03\x06\x02\x02\x05\x12\x04\xf5\x06\
    \x08\x0e\n\x0f\n\x07\x04\r\x03\x06\x02\x02\x01\x12\x04\xf5\x06\x0f\x19\n\
    \x0f\n\x07\x04\r\x03\x06\x02\x02\x03\x12\x04\xf5\x06\x1c\x1d\n\x1f\n\x06\
    \x04\r\x03\x06\x02\x03\x12\x04\xf7\x06\x08\x20\x1a\x0f\x20Column\x20numb\
    er\n\n\x0f\n\x07\x04\r\x03\x06\x02\x03\x05\x12\x04\xf7\x06\x08\x0e\n\x0f\
    \n\x07\x04\r\x03\x06\x02\x03\x01\x12\x04\xf7\x06\x0f\x1b\n\x0f\n\x07\x04\
    \r\x03\x06\x02\x03\x03\x12\x04\xf7\x06\x1e\x1f\n7\n\x06\x04\r\x03\x06\
    \x02\x04\x12\x04\xf9\x06\x08\x1c\x1a'\x20Type\x20of\x20the\x20definition\
    .\x20Usually\x20LOCAL\n\n\x0f\n\x07\x04\r\x03\x06\x02\x04\x06\x12\x04\
    \xf9\x06\x08\x11\n\x0f\n\x07\x04\r\x03\x06\x02\x04\x01\x12\x04\xf9\x06\
    \x12\x17\n\x0f\n\x07\x04\r\x03\x06\x02\x04\x03\x12\x04\xf9\x06\x1a\x1b\n\
    6\n\x04\x04\r\x03\x07\x12\x06\xfd\x06\x04\x8a\x07\x05\x1a&\x20Details\
    \x20related\x20to\x20an\x20observed\x20call.\n\n\r\n\x05\x04\r\x03\x07\
    \x01\x12\x04\xfd\x06\x0c\x16\n,\n\x06\x04\r\x03\x07\x02\0\x12\x04\xff\
    \x06\x08\x1c\x1a\x1c\x20Name\x20of\x20the\x20method\x20or\x20call\n\n\
    \x0f\n\x07\x04\r\x03\x07\x02\0\x05\x12\x04\xff\x06\x08\x0e\n\x0f\n\x07\
    \x04\r\x03\x07\x02\0\x01\x12\x04\xff\x06\x0f\x17\n\x0f\n\x07\x04\r\x03\
    \x07\x02\0\x03\x12\x04\xff\x06\x1a\x1b\n2\n\x06\x04\r\x03\x07\x02\x01\
    \x12\x04\x81\x07\x08\"\x1a\"\x20Full\x20name\x20of\x20the\x20resolved\
    \x20method\n\n\x0f\n\x07\x04\r\x03\x07\x02\x01\x05\x12\x04\x81\x07\x08\
    \x0e\n\x0f\n\x07\x04\r\x03\x07\x02\x01\x01\x12\x04\x81\x07\x0f\x1d\n\x0f\
    \n\x07\x04\r\x03\x07\x02\x01\x03\x12\x04\x81\x07\x20!\n)\n\x06\x04\r\x03\
    \x07\x02\x02\x12\x04\x83\x07\x08'\x1a\x19\x20Types\x20of\x20the\x20param\
    eters\n\n\x0f\n\x07\x04\r\x03\x07\x02\x02\x04\x12\x04\x83\x07\x08\x10\n\
    \x0f\n\x07\x04\r\x03\x07\x02\x02\x05\x12\x04\x83\x07\x11\x17\n\x0f\n\x07\
    \x04\r\x03\x07\x02\x02\x01\x12\x04\x83\x07\x18\"\n\x0f\n\x07\x04\r\x03\
    \x07\x02\x02\x03\x12\x04\x83\x07%&\n*\n\x06\x04\r\x03\x07\x02\x03\x12\
    \x04\x85\x07\x08\x1e\x1a\x1a\x20Type\x20of\x20the\x20return\x20value\n\n\
    \x0f\n\x07\x04\r\x03\x07\x02\x03\x05\x12\x04\x85\x07\x08\x0e\n\x0f\n\x07\
    \x04\r\x03\x07\x02\x03\x01\x12\x04\x85\x07\x0f\x19\n\x0f\n\x07\x04\r\x03\
    \x07\x02\x03\x03\x12\x04\x85\x07\x1c\x1d\n\x1d\n\x06\x04\r\x03\x07\x02\
    \x04\x12\x04\x87\x07\x08\x1e\x1a\r\x20Line\x20number\n\n\x0f\n\x07\x04\r\
    \x03\x07\x02\x04\x05\x12\x04\x87\x07\x08\x0e\n\x0f\n\x07\x04\r\x03\x07\
    \x02\x04\x01\x12\x04\x87\x07\x0f\x19\n\x0f\n\x07\x04\r\x03\x07\x02\x04\
    \x03\x12\x04\x87\x07\x1c\x1d\n\x1f\n\x06\x04\r\x03\x07\x02\x05\x12\x04\
    \x89\x07\x08\x20\x1a\x0f\x20Column\x20number\n\n\x0f\n\x07\x04\r\x03\x07\
    \x02\x05\x05\x12\x04\x89\x07\x08\x0e\n\x0f\n\x07\x04\r\x03\x07\x02\x05\
    \x01\x12\x04\x89\x07\x0f\x1b\n\x0f\n\x07\x04\r\x03\x07\x02\x05\x03\x12\
    \x04\x89\x07\x1e\x1f\nH\n\x04\x04\r\x03\x08\x12\x06\x8d\x07\x04\x98\x07\
    \x05\x1a8\x20Describes\x20custom\x20types\x20defined\x20within\x20the\
    \x20application.\n\n\r\n\x05\x04\r\x03\x08\x01\x12\x04\x8d\x07\x0c\x1c\n\
    \"\n\x06\x04\r\x03\x08\x02\0\x12\x04\x8f\x07\x08\x18\x1a\x12\x20Name\x20\
    of\x20the\x20type\n\n\x0f\n\x07\x04\r\x03\x08\x02\0\x05\x12\x04\x8f\x07\
    \x08\x0e\n\x0f\n\x07\x04\r\x03\x08\x02\0\x01\x12\x04\x8f\x07\x0f\x13\n\
    \x0f\n\x07\x04\r\x03\x08\x02\0\x03\x12\x04\x8f\x07\x16\x17\n\x0e\n\x06\
    \x04\r\x03\x08\x02\x01\x12\x04\x90\x07\x08#\n\x0f\n\x07\x04\r\x03\x08\
    \x02\x01\x04\x12\x04\x90\x07\x08\x10\n\x0f\n\x07\x04\r\x03\x08\x02\x01\
    \x06\x12\x04\x90\x07\x11\x17\n\x0f\n\x07\x04\r\x03\x08\x02\x01\x01\x12\
    \x04\x90\x07\x18\x1e\n\x0f\n\x07\x04\r\x03\x08\x02\x01\x03\x12\x04\x90\
    \x07!\"\n\x0e\n\x06\x04\r\x03\x08\x02\x02\x12\x04\x91\x07\x08+\n\x0f\n\
    \x07\x04\r\x03\x08\x02\x02\x04\x12\x04\x91\x07\x08\x10\n\x0f\n\x07\x04\r\
    \x03\x08\x02\x02\x06\x12\x04\x91\x07\x11\x1b\n\x0f\n\x07\x04\r\x03\x08\
    \x02\x02\x01\x12\x04\x91\x07\x1c&\n\x0f\n\x07\x04\r\x03\x08\x02\x02\x03\
    \x12\x04\x91\x07)*\n\x1b\n\x06\x04\r\x03\x08\x02\x03\x12\x04\x93\x07\x08\
    \x1c\x1a\x0b\x20File\x20name\n\n\x0f\n\x07\x04\r\x03\x08\x02\x03\x05\x12\
    \x04\x93\x07\x08\x0e\n\x0f\n\x07\x04\r\x03\x08\x02\x03\x01\x12\x04\x93\
    \x07\x0f\x17\n\x0f\n\x07\x04\r\x03\x08\x02\x03\x03\x12\x04\x93\x07\x1a\
    \x1b\n\x1d\n\x06\x04\r\x03\x08\x02\x04\x12\x04\x95\x07\x08\x1e\x1a\r\x20\
    Line\x20number\n\n\x0f\n\x07\x04\r\x03\x08\x02\x04\x05\x12\x04\x95\x07\
    \x08\x0e\n\x0f\n\x07\x04\r\x03\x08\x02\x04\x01\x12\x04\x95\x07\x0f\x19\n\
    \x0f\n\x07\x04\r\x03\x08\x02\x04\x03\x12\x04\x95\x07\x1c\x1d\n\x1f\n\x06\
    \x04\r\x03\x08\x02\x05\x12\x04\x97\x07\x08\x20\x1a\x0f\x20Column\x20numb\
    er\n\n\x0f\n\x07\x04\r\x03\x08\x02\x05\x05\x12\x04\x97\x07\x08\x0e\n\x0f\
    \n\x07\x04\r\x03\x08\x02\x05\x01\x12\x04\x97\x07\x0f\x1b\n\x0f\n\x07\x04\
    \r\x03\x08\x02\x05\x03\x12\x04\x97\x07\x1e\x1f\n\x0c\n\x04\x04\r\x02\0\
    \x12\x04\x9a\x07\x04/\n\r\n\x05\x04\r\x02\0\x04\x12\x04\x9a\x07\x04\x0c\
    \n\r\n\x05\x04\r\x02\0\x06\x12\x04\x9a\x07\r\x1d\n\r\n\x05\x04\r\x02\0\
    \x01\x12\x04\x9a\x07\x1e*\n\r\n\x05\x04\r\x02\0\x03\x12\x04\x9a\x07-.\n\
    \x0c\n\x04\x04\r\x02\x01\x12\x04\x9b\x07\x043\n\r\n\x05\x04\r\x02\x01\
    \x04\x12\x04\x9b\x07\x04\x0c\n\r\n\x05\x04\r\x02\x01\x06\x12\x04\x9b\x07\
    \r\x1d\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\x9b\x07\x1e.\n\r\n\x05\x04\r\
    \x02\x01\x03\x12\x04\x9b\x0712\n\x9f\x01\n\x02\x04\x0e\x12\x06\xa3\x07\0\
    \xde\x07\x01\x1a\x90\x01*\n\x20DataFlow\x20slices\x20offers\x20a\x20list\
    \x20of\x20nodes\x20and\x20edges\x20exported\x20from\x20data\x20dependenc\
    y\x20graph\n\n\x20![Data\x20Flow\x20slices\x20overview](./docs/Data%20Fl\
    ows.png)\n\n\x0b\n\x03\x04\x0e\x01\x12\x04\xa3\x07\x08\x15\n\x0e\n\x04\
    \x04\x0e\x03\0\x12\x06\xa5\x07\x04\xc2\x07\x05\n\r\n\x05\x04\x0e\x03\0\
    \x01\x12\x04\xa5\x07\x0c\x11\n\x20\n\x06\x04\x0e\x03\0\x02\0\x12\x04\xa7\
    \x07\x08\x16\x1a\x10\x20Id\x20of\x20the\x20node\n\n\x0f\n\x07\x04\x0e\
    \x03\0\x02\0\x05\x12\x04\xa7\x07\x08\x0e\n\x0f\n\x07\x04\x0e\x03\0\x02\0\
    \x01\x12\x04\xa7\x07\x0f\x11\n\x0f\n\x07\x04\x0e\x03\0\x02\0\x03\x12\x04\
    \xa7\x07\x14\x15\n\x17\n\x06\x04\x0e\x03\0\x02\x01\x12\x04\xa9\x07\x08\
    \x1b\x1a\x07\x20Label\n\n\x0f\n\x07\x04\x0e\x03\0\x02\x01\x06\x12\x04\
    \xa9\x07\x08\x10\n\x0f\n\x07\x04\x0e\x03\0\x02\x01\x01\x12\x04\xa9\x07\
    \x11\x16\n\x0f\n\x07\x04\x0e\x03\0\x02\x01\x03\x12\x04\xa9\x07\x19\x1a\n\
    =\n\x06\x04\x0e\x03\0\x02\x02\x12\x04\xab\x07\x08\x18\x1a-\x20Name\x20of\
    \x20the\x20call\x20or\x20identifier\x20or\x20parameter\n\n\x0f\n\x07\x04\
    \x0e\x03\0\x02\x02\x05\x12\x04\xab\x07\x08\x0e\n\x0f\n\x07\x04\x0e\x03\0\
    \x02\x02\x01\x12\x04\xab\x07\x0f\x13\n\x0f\n\x07\x04\x0e\x03\0\x02\x02\
    \x03\x12\x04\xab\x07\x16\x17\n'\n\x06\x04\x0e\x03\0\x02\x03\x12\x04\xad\
    \x07\x08\x1c\x1a\x17\x20Full\x20name\x20of\x20the\x20call\n\n\x0f\n\x07\
    \x04\x0e\x03\0\x02\x03\x05\x12\x04\xad\x07\x08\x0e\n\x0f\n\x07\x04\x0e\
    \x03\0\x02\x03\x01\x12\x04\xad\x07\x0f\x17\n\x0f\n\x07\x04\x0e\x03\0\x02\
    \x03\x03\x12\x04\xad\x07\x1a\x1b\n.\n\x06\x04\x0e\x03\0\x02\x04\x12\x04\
    \xaf\x07\x08\x1d\x1a\x1e\x20Method\x20signature\x20of\x20the\x20call\n\n\
    \x0f\n\x07\x04\x0e\x03\0\x02\x04\x05\x12\x04\xaf\x07\x08\x0e\n\x0f\n\x07\
    \x04\x0e\x03\0\x02\x04\x01\x12\x04\xaf\x07\x0f\x18\n\x0f\n\x07\x04\x0e\
    \x03\0\x02\x04\x03\x12\x04\xaf\x07\x1b\x1c\nP\n\x06\x04\x0e\x03\0\x02\
    \x05\x12\x04\xb1\x07\x08\x1c\x1a@\x20Boolean\x20to\x20indicate\x20if\x20\
    this\x20call\x20belongs\x20to\x20an\x20external\x20method\n\n\x0f\n\x07\
    \x04\x0e\x03\0\x02\x05\x05\x12\x04\xb1\x07\x08\x0c\n\x0f\n\x07\x04\x0e\
    \x03\0\x02\x05\x01\x12\x04\xb1\x07\r\x17\n\x0f\n\x07\x04\x0e\x03\0\x02\
    \x05\x03\x12\x04\xb1\x07\x1a\x1b\n\x1d\n\x06\x04\x0e\x03\0\x02\x06\x12\
    \x04\xb3\x07\x08\x18\x1a\r\x20Source\x20code\n\n\x0f\n\x07\x04\x0e\x03\0\
    \x02\x06\x05\x12\x04\xb3\x07\x08\x0e\n\x0f\n\x07\x04\x0e\x03\0\x02\x06\
    \x01\x12\x04\xb3\x07\x0f\x13\n\x0f\n\x07\x04\x0e\x03\0\x02\x06\x03\x12\
    \x04\xb3\x07\x16\x17\n\x20\n\x06\x04\x0e\x03\0\x02\x07\x12\x04\xb5\x07\
    \x08\x20\x1a\x10\x20Type\x20full\x20name\n\n\x0f\n\x07\x04\x0e\x03\0\x02\
    \x07\x05\x12\x04\xb5\x07\x08\x0e\n\x0f\n\x07\x04\x0e\x03\0\x02\x07\x01\
    \x12\x04\xb5\x07\x0f\x1b\n\x0f\n\x07\x04\x0e\x03\0\x02\x07\x03\x12\x04\
    \xb5\x07\x1e\x1f\n$\n\x06\x04\x0e\x03\0\x02\x08\x12\x04\xb7\x07\x08$\x1a\
    \x14\x20Parent\x20method\x20name\n\n\x0f\n\x07\x04\x0e\x03\0\x02\x08\x05\
    \x12\x04\xb7\x07\x08\x0e\n\x0f\n\x07\x04\x0e\x03\0\x02\x08\x01\x12\x04\
    \xb7\x07\x0f\x1f\n\x0f\n\x07\x04\x0e\x03\0\x02\x08\x03\x12\x04\xb7\x07\"\
    #\n!\n\x06\x04\x0e\x03\0\x02\t\x12\x04\xb9\x07\x08#\x1a\x11\x20Parent\
    \x20filename\n\n\x0f\n\x07\x04\x0e\x03\0\x02\t\x05\x12\x04\xb9\x07\x08\
    \x0e\n\x0f\n\x07\x04\x0e\x03\0\x02\t\x01\x12\x04\xb9\x07\x0f\x1d\n\x0f\n\
    \x07\x04\x0e\x03\0\x02\t\x03\x12\x04\xb9\x07\x20\"\n%\n\x06\x04\x0e\x03\
    \0\x02\n\x12\x04\xbb\x07\x08&\x1a\x15\x20Parent\x20package\x20name\n\n\
    \x0f\n\x07\x04\x0e\x03\0\x02\n\x05\x12\x04\xbb\x07\x08\x0e\n\x0f\n\x07\
    \x04\x0e\x03\0\x02\n\x01\x12\x04\xbb\x07\x0f\x20\n\x0f\n\x07\x04\x0e\x03\
    \0\x02\n\x03\x12\x04\xbb\x07#%\n#\n\x06\x04\x0e\x03\0\x02\x0b\x12\x04\
    \xbd\x07\x08$\x1a\x13\x20Parent\x20class\x20name\n\n\x0f\n\x07\x04\x0e\
    \x03\0\x02\x0b\x05\x12\x04\xbd\x07\x08\x0e\n\x0f\n\x07\x04\x0e\x03\0\x02\
    \x0b\x01\x12\x04\xbd\x07\x0f\x1e\n\x0f\n\x07\x04\x0e\x03\0\x02\x0b\x03\
    \x12\x04\xbd\x07!#\n\x1d\n\x06\x04\x0e\x03\0\x02\x0c\x12\x04\xbf\x07\x08\
    \x1f\x1a\r\x20Line\x20number\n\n\x0f\n\x07\x04\x0e\x03\0\x02\x0c\x05\x12\
    \x04\xbf\x07\x08\x0e\n\x0f\n\x07\x04\x0e\x03\0\x02\x0c\x01\x12\x04\xbf\
    \x07\x0f\x19\n\x0f\n\x07\x04\x0e\x03\0\x02\x0c\x03\x12\x04\xbf\x07\x1c\
    \x1e\n\x1f\n\x06\x04\x0e\x03\0\x02\r\x12\x04\xc1\x07\x08!\x1a\x0f\x20Col\
    umn\x20number\n\n\x0f\n\x07\x04\x0e\x03\0\x02\r\x05\x12\x04\xc1\x07\x08\
    \x0e\n\x0f\n\x07\x04\x0e\x03\0\x02\r\x01\x12\x04\xc1\x07\x0f\x1b\n\x0f\n\
    \x07\x04\x0e\x03\0\x02\r\x03\x12\x04\xc1\x07\x1e\x20\n\x0e\n\x04\x04\x0e\
    \x03\x01\x12\x06\xc4\x07\x04\xcb\x07\x05\n\r\n\x05\x04\x0e\x03\x01\x01\
    \x12\x04\xc4\x07\x0c\x11\n\x20\n\x06\x04\x0e\x03\x01\x02\0\x12\x04\xc6\
    \x07\x08\x17\x1a\x10\x20Source\x20node\x20id\n\n\x0f\n\x07\x04\x0e\x03\
    \x01\x02\0\x05\x12\x04\xc6\x07\x08\x0e\n\x0f\n\x07\x04\x0e\x03\x01\x02\0\
    \x01\x12\x04\xc6\x07\x0f\x12\n\x0f\n\x07\x04\x0e\x03\x01\x02\0\x03\x12\
    \x04\xc6\x07\x15\x16\n%\n\x06\x04\x0e\x03\x01\x02\x01\x12\x04\xc8\x07\
    \x08\x17\x1a\x15\x20Destination\x20node\x20id\n\n\x0f\n\x07\x04\x0e\x03\
    \x01\x02\x01\x05\x12\x04\xc8\x07\x08\x0e\n\x0f\n\x07\x04\x0e\x03\x01\x02\
    \x01\x01\x12\x04\xc8\x07\x0f\x12\n\x0f\n\x07\x04\x0e\x03\x01\x02\x01\x03\
    \x12\x04\xc8\x07\x15\x16\n\x1b\n\x06\x04\x0e\x03\x01\x02\x02\x12\x04\xca\
    \x07\x08*\x1a\x0b\x20Edge\x20type\n\n\x0f\n\x07\x04\x0e\x03\x01\x02\x02\
    \x06\x12\x04\xca\x07\x08\x1f\n\x0f\n\x07\x04\x0e\x03\x01\x02\x02\x01\x12\
    \x04\xca\x07\x20%\n\x0f\n\x07\x04\x0e\x03\x01\x02\x02\x03\x12\x04\xca\
    \x07()\n\x0e\n\x04\x04\x0e\x03\x02\x12\x06\xcd\x07\x04\xd0\x07\x05\n\r\n\
    \x05\x04\x0e\x03\x02\x01\x12\x04\xcd\x07\x0c\x11\n\x19\n\x06\x04\x0e\x03\
    \x02\x02\0\x12\x04\xcf\x07\x06\x1d\x1a\t\x20Node\x20id\n\n\x0f\n\x07\x04\
    \x0e\x03\x02\x02\0\x04\x12\x04\xcf\x07\x06\x0e\n\x0f\n\x07\x04\x0e\x03\
    \x02\x02\0\x05\x12\x04\xcf\x07\x0f\x15\n\x0f\n\x07\x04\x0e\x03\x02\x02\0\
    \x01\x12\x04\xcf\x07\x16\x18\n\x0f\n\x07\x04\x0e\x03\x02\x02\0\x03\x12\
    \x04\xcf\x07\x1b\x1c\n\x0e\n\x04\x04\x0e\x03\x03\x12\x06\xd2\x07\x04\xd5\
    \x07\x05\n\r\n\x05\x04\x0e\x03\x03\x01\x12\x04\xd2\x07\x0c\x11\n+\n\x06\
    \x04\x0e\x03\x03\x02\0\x12\x04\xd4\x07\x06\x1f\x1a\x1b\x20Flows\x20from\
    \x20source\x20to\x20sink\n\n\x0f\n\x07\x04\x0e\x03\x03\x02\0\x04\x12\x04\
    \xd4\x07\x06\x0e\n\x0f\n\x07\x04\x0e\x03\x03\x02\0\x06\x12\x04\xd4\x07\
    \x0f\x14\n\x0f\n\x07\x04\x0e\x03\x03\x02\0\x01\x12\x04\xd4\x07\x15\x1a\n\
    \x0f\n\x07\x04\x0e\x03\x03\x02\0\x03\x12\x04\xd4\x07\x1d\x1e\n\x0e\n\x04\
    \x04\x0e\x03\x04\x12\x06\xd7\x07\x04\xda\x07\x05\n\r\n\x05\x04\x0e\x03\
    \x04\x01\x12\x04\xd7\x07\x0c\x11\n\x0e\n\x06\x04\x0e\x03\x04\x02\0\x12\
    \x04\xd8\x07\x06\x1f\n\x0f\n\x07\x04\x0e\x03\x04\x02\0\x04\x12\x04\xd8\
    \x07\x06\x0e\n\x0f\n\x07\x04\x0e\x03\x04\x02\0\x06\x12\x04\xd8\x07\x0f\
    \x14\n\x0f\n\x07\x04\x0e\x03\x04\x02\0\x01\x12\x04\xd8\x07\x15\x1a\n\x0f\
    \n\x07\x04\x0e\x03\x04\x02\0\x03\x12\x04\xd8\x07\x1d\x1e\n\x0e\n\x06\x04\
    \x0e\x03\x04\x02\x01\x12\x04\xd9\x07\x06\x1f\n\x0f\n\x07\x04\x0e\x03\x04\
    \x02\x01\x04\x12\x04\xd9\x07\x06\x0e\n\x0f\n\x07\x04\x0e\x03\x04\x02\x01\
    \x06\x12\x04\xd9\x07\x0f\x14\n\x0f\n\x07\x04\x0e\x03\x04\x02\x01\x01\x12\
    \x04\xd9\x07\x15\x1a\n\x0f\n\x07\x04\x0e\x03\x04\x02\x01\x03\x12\x04\xd9\
    \x07\x1d\x1e\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\xdc\x07\x04\x14\n\r\n\x05\
    \x04\x0e\x02\0\x06\x12\x04\xdc\x07\x04\t\n\r\n\x05\x04\x0e\x02\0\x01\x12\
    \x04\xdc\x07\n\x0f\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xdc\x07\x12\x13\n\
    \x0c\n\x04\x04\x0e\x02\x01\x12\x04\xdd\x07\x04\x13\n\r\n\x05\x04\x0e\x02\
    \x01\x06\x12\x04\xdd\x07\x04\t\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\xdd\
    \x07\n\x0e\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xdd\x07\x11\x12b\x06pro\
    to3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(38);
            messages.push(PropertyValue::generated_message_descriptor_data());
            messages.push(ContainedRefs::generated_message_descriptor_data());
            messages.push(StringList::generated_message_descriptor_data());
            messages.push(BoolList::generated_message_descriptor_data());
            messages.push(IntList::generated_message_descriptor_data());
            messages.push(LongList::generated_message_descriptor_data());
            messages.push(FloatList::generated_message_descriptor_data());
            messages.push(DoubleList::generated_message_descriptor_data());
            messages.push(CpgStruct::generated_message_descriptor_data());
            messages.push(AdditionalNodeProperty::generated_message_descriptor_data());
            messages.push(AdditionalEdgeProperty::generated_message_descriptor_data());
            messages.push(CpgOverlay::generated_message_descriptor_data());
            messages.push(DiffGraph::generated_message_descriptor_data());
            messages.push(UsageSlice::generated_message_descriptor_data());
            messages.push(DataFlowSlice::generated_message_descriptor_data());
            messages.push(cpg_struct::Node::generated_message_descriptor_data());
            messages.push(cpg_struct::Edge::generated_message_descriptor_data());
            messages.push(cpg_struct::node::Property::generated_message_descriptor_data());
            messages.push(cpg_struct::edge::Property::generated_message_descriptor_data());
            messages.push(diff_graph::RemoveNode::generated_message_descriptor_data());
            messages.push(diff_graph::RemoveNodeProperty::generated_message_descriptor_data());
            messages.push(diff_graph::RemoveEdge::generated_message_descriptor_data());
            messages.push(diff_graph::RemoveEdgeProperty::generated_message_descriptor_data());
            messages.push(diff_graph::Entry::generated_message_descriptor_data());
            messages.push(usage_slice::TargetObj::generated_message_descriptor_data());
            messages.push(usage_slice::DefinedBy::generated_message_descriptor_data());
            messages.push(usage_slice::InvokedCalls::generated_message_descriptor_data());
            messages.push(usage_slice::ArgToCalls::generated_message_descriptor_data());
            messages.push(usage_slice::ObjectUsageSlice::generated_message_descriptor_data());
            messages.push(usage_slice::MethodUsageSlice::generated_message_descriptor_data());
            messages.push(usage_slice::Fields::generated_message_descriptor_data());
            messages.push(usage_slice::Procedures::generated_message_descriptor_data());
            messages.push(usage_slice::UserDefinedTypes::generated_message_descriptor_data());
            messages.push(data_flow_slice::Nodes::generated_message_descriptor_data());
            messages.push(data_flow_slice::Edges::generated_message_descriptor_data());
            messages.push(data_flow_slice::Flows::generated_message_descriptor_data());
            messages.push(data_flow_slice::Paths::generated_message_descriptor_data());
            messages.push(data_flow_slice::Graph::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(10);
            enums.push(NodePropertyName::generated_enum_descriptor_data());
            enums.push(EdgePropertyName::generated_enum_descriptor_data());
            enums.push(ModifierTypes::generated_enum_descriptor_data());
            enums.push(LANGUAGES::generated_enum_descriptor_data());
            enums.push(EvaluationStrategies::generated_enum_descriptor_data());
            enums.push(DispatchTypes::generated_enum_descriptor_data());
            enums.push(CONTROL_STRUCTURE_TYPES::generated_enum_descriptor_data());
            enums.push(NodeType::generated_enum_descriptor_data());
            enums.push(cpg_struct::edge::EdgeType::generated_enum_descriptor_data());
            enums.push(usage_slice::LabelType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
